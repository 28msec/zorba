/** \page collections Collections

<ul>
   <li> Table of Contents
   <ul>
     <li> \ref introduction
     <li> \ref coll_management
     <ul>
       <li> \ref coll_create_collection
       <li> \ref coll_delete_collection
       <li> \ref fn_collection_exists
       <li> \ref coll_list_collections
     </ul>
     <li> \ref coll_entries
     <ul>
       <li> \ref coll_insert_nodes
       <li> \ref coll_remove_nodes
       <li> \ref coll_index_of
       <li> \ref deprecated_coll_functs
       <ul>
         <li> \ref coll_import_xml
         <li> \ref coll_import_catalog
         <li> \ref coll_nodes_count
         <li> \ref coll_node_at
         <li> \ref coll_export_xml
       </ul>
     </ul>
   </ul>
 </ul>
 
\section introduction 1 Introduction
A collection is defined to be a sequence of nodes and is identified by a URI.
To access a collection, XQuery defines the fn:collection function.
This function takes an <tt>xs:string</tt> as argument and returns a sequence of nodes which is mapped to the URI resulting from interpreting the given <tt>xs:string</tt> as an <tt>xs:anyURI</tt> (eventually resolving it if the given string is not an absolute URI).

The XQuery specification leaves details about the semantics of collections to the particular implementation of an XQuery processor.
In some processors, for example, a collection results from returning a set of documents in a directory pointed to by a given file URI. 
Zorba takes a different approach: In the Zorba query processor, collections are simply mappings (URI -> sequence of nodes).
These mappings are entirely managed by the store.
Essentially, this means that the processor itself (similar to the XQuery specification) leaves details of the implementation to a particular store.
A store implementation has the freedom to choose where the data for a collection comes from and where it is stored.
For example, a filesystem store can return and store the documents in a directory like other processors do.
Another store, which is, for example, backed by a relational database, might return documents which are stored as blobs in rows of a relational table.
The main-memory store that is shipped with Zorba stores collection mappings in main-memory.
Essentially, this means that collections exist as long as the store exists.

Because collections are managed by the store the (XQuery) programmer needs to have a way to manage those collections. 
Therefore, Zorba provides an XQuery module which declares two types of functions:
<ul>
  <li> to manage collections (e.g. create or delete collections)
  <li> to manage the contents of collections (e.g. insert or remove nodes into or from a collection, resp.)
</ul>

The collection module can be used by importing the module with URI <tt>http://www.zorba-xquery.com/zorba/collection-functions</tt>.

For example,

\code
  import module namespace coll = "http://www.zorba-xquery.com/zorba/collection-functions";
\endcode

Many of the functions in this module are declared as updating functions (see XQuery Update Facility at <tt>http://www.w3.org/TR/xquery-update-10/</tt>). 
This means that their result is a pending update list (PUL). 
The changes made by such functions become visible if the PUL is applied in the store.
This can be done by

<ul>
  <li> executing the query using the applyUpdates function of the C/C++ API.
  <li> the apply expression of the XQuery Scripting Extension as described in <tt>http://www.w3.org/TR/xquery-sx-10/#id-apply</tt>.
</ul>

Most of the functions take an <tt>xs:string</tt> parameter with name <tt>uri</tt> as first argument.
This parameter is the name of the collection in question. 
The parameter is interpreted as an <tt>xs:anyURI</tt>.
If the parameter is a relative URI, this relative URI is resolved against the value of the base-URI property from the static context.

In the following, we describe the semantics of these functions in more detail.

\section coll_management 2 Managing Collections

\subsection coll_create_collection 2.1 Creating Collections

\code
  declare updating function create-collection($uri as xs:string)
\endcode

This function creates a new collection in the store. 
If a collection with name specified by the <tt>uri</tt> parameter already exists, an error is raised.

\code
  declare updating function create-collection($uri    as xs:anyURI,
                                              $nodes  as node()*) 
\endcode

This function creates a new collection as described above.
Additionally, the sequence of nodes passed using the second parameter is added to the new collection.

\subsection ex_2_1 Example:
\include q1.cxq

\subsection coll_delete_collection 2.2 Deleting Collections

\subsubsection coll_delete_one_collection 2.2.1 Deleting a Single Collection
\code
  declare updating function delete-collection($uri as xs:string)
\endcode

Ths function deletes the collection identified by the given URI.
If the collection does not exist, the error API0006_COLLECTION_NOT_FOUND is raised.

\subsection ex_2_2 Example:
\include q3.cxq

\subsubsection coll_delete_all_collections 2.2.2 Deleting All Collections
\code
  declare updating function delete-all-collections()
\endcode

This function deletes all existing collections.

\subsection fn_collection_exists 2.3 Checking if a Collection Exists

\code
  declare function collection-exists($uri as xs:string) as xs:boolean
\endcode

Returns true if a collection with the name <tt>uri</tt> exists in the store or false otherwise.

\subsection coll_list_collections 2.4 Listing Collections

\code
  declare function list-collections() as xs:anyURI*
\endcode

This function returns a sequence of URIs (i.e. of type <tt>xs:anyURI</tt>) of all collections available in the store.

\subsection ex_2_4 Example:
\include q4.cxq

\section coll_entries 3 Modifying the Contents of a Collection

In the following, we describe functions that can be used to modify the contents of a collection.
That way, the programmer can add or remove nodes to or from a collection, respectively.
Note that this module doesn't provide functions to modify a particular node in a collection.
For this, the features provided by the XQuery Update Facility (see http://www.w3.org/TR/xquery-update-10/) can be used.


\subsection coll_insert_nodes 3.1 Adding Nodes to a Collection

The following five functions add a sequence of nodes to the collection with the name specified by the <tt>uri</tt> parameter. 
All of those functions copy each of the nodes that is inserted.
This means that all nodes added to the collection will have a new node identity (see http://www.w3.org/TR/xpath-datamodel/#node-identity).
The semantics of node copying is as described in the ''Constructors'' section of the XQuery 1.0 specification.

If multiple nodes are inserted, the nodes remain adjacent and their order preserves the node ordering of the source expression (i.e. the parameter with the name newnode).

All function raise the error API0006_COLLECTION_NOT_FOUND if the collection does not exist.

<ul>
 <li> Insert nodes at the beginning of a collection.<br>
\code
  declare updating function insert-nodes-first( $uri      as xs:string,
                                                $newnode  as node()*)
\endcode
 <li> Insert nodes at the end of a collection.<br>
\code
  declare updating function insert-nodes-last($uri      as xs:string,
                                              $newnode  as node()*)
\endcode
 <li> Insert nodes before the node specified by the parameter with name target.
 The error API0029_NODE_DOES_NOT_BELONG_TO_COLLECTION is raised if the target node does not exist
 in the collection.<br>
\code
  declare updating function insert-nodes-before($uri      as xs:string,
                                                $target   as node(),
                                                $newnode  as node()*)
\endcode
 <li> Insert nodes after the node specified by the parameter with name target.
 The error API0029_NODE_DOES_NOT_BELONG_TO_COLLECTION is raised if the target node does not exist
 in the collection.<br>
\code
  declare updating function insert-nodes-after( $uri      as xs:string,
                                                $target   as node(),
                                                $newnode  as node()*)
\endcode
 <li> Insert nodes at the position speified by the parameter with name position.
 Note that in XQuery, the collection is a list of nodes whose indexes are one-based.
 If position is negative, the nodes will be inserted at the beginning of the collection.
 If position is greater or equal to the number of nodes in the collection, the node(s) will be inserted as the last node(s) in the collection.
\code
  declare updating function insert-nodes-at($uri      as xs:string,
                                            $position as xs:integer,
                                            $newnode  as node()*    )
\endcode
</ul>

\subsubsection ex_2_8 Example:
\include insert_nodes_first.xq

\subsection coll_remove_nodes 3.2 Removing Nodes from a Collection

The following two functions remove nodes from a collection with the name specified by the <tt>uri</tt> parameter.

Both function raise the error API0006_COLLECTION_NOT_FOUND if the collection does not exist.

<ul>
  <li> Remove a sequence of nodes specified by the parameter with name target.
  The error API0029_NODE_DOES_NOT_BELONG_TO_COLLECTION is raised if one of the nodes of the target sequence does not exist in the collection.<br>
\code
  declare updating function remove-nodes( $uri    as xs:string,
                                          $target as node()+)
\endcode
  <li> Remove the node at the position specified by the parameter with name position from the collection.
       Note: The collection is a list of nodes that is one-based indexed.
       The error API0030_NO_NODE_AT_GIVEN_POSITION is raised there is no node at the specified position.
\code
  declare updating function remove-node-at( $uri      as xs:string,
                                            $position as xs:integer )
\endcode
</ul>

The function will remove from the given collection the node positioned at <tt>position</tt>.

\subsubsection ex_2_14 Example:
\include remove_node_at_1.xq

\subsection coll_index_of 3.3 Getting the Index of a Node in a Collection

\code
  declare function index-of($uri    as xs:string,
                            $target as node()) as xs:integer
\endcode

This function returns the index of the node given by the parameter with name target within the collection identified by <tt>uri</tt>.
Note that a collection is a sequence of nodes that is one-based indexed.

The error API0029_NODE_DOES_NOT_BELONG_TO_COLLECTION is raised if the node does not exist in the given collection.

\subsection ex_2_17 Example:
\include index_of_1.xq

\subsection deprecated_coll_functs 3.4 Deprecated Functions

The following functions are deprecated and, hence, shouldn't be used anymore.
They will be removed in the next Zorba release.
The functionality provided by those functions can be implemented using the functions above and/or some additional libraries that Zorba will provided with the next release.

\subsubsection coll_import_xml 3.4.1 import-xml

\code
  declare function import-xml($uri as xs:anyURI) as none
\endcode

This function will import a given XML document, identified by the <tt>uri</tt> parameter, into a new collection.
The collection's URI will be the value of the <tt>uri</tt> parameter.
If the <tt>uri</tt> is found in the collection poll no import is done.

Error conditions:
If the XML file specified by the <tt>uri</tt> parameter does not exist, an error is raised API0033_FILE_OR_FOLDER_DOES_NOT_EXIST.
If the XML file cannot be opened, an error is raised API0034_FILE_OR_FOLDER_CANNOT_BE_OPENED.

\subsubsection coll_import_catalog 3.4.2 import-catalog

\code
  declare function import-catalog($uri as xs:anyURI) as none
\endcode

The function will open the given XML file and interpret it as a catalog.
Assuming <tt>uri</tt> is 'file://localhost/home/user_1/catalog.xml', it must have the following structure:

\code
<catalog>
  <doc href="file1.xml"/>
  <doc href="path/file2.xml"/>
  <doc href="path/file3.xml"/>
  ...
</catalog>
\endcode

Each of the documents referenced in the <tt>\<doc\></tt> tags is first looked up in the collection poll.
If it is already present, nothing is done, otherwise it is loaded as a collection, with the <tt>href</tt> attribute value as the associated URI.
The URIs of the catalog and the files may include a protocol specification, such as "file://" or "http://".
The function will not validate the catalog file's structure. In case it is malformed - no XML files will be imported.

In case a <tt>href</tt> attribute contains no path, only the name of the file (see the first href attribute in the example above) the file will be looked in the same path as the catalog ('file://localhost/home/user_1/file1.xml' in the example above).

Error conditions:
If the catalog file specified by the <tt>uri</tt> parameter or any of the files specified by the href attributes does not exist, an error is raised API0033_FILE_OR_FOLDER_DOES_NOT_EXIST.
If the catalog file or the href files cannot be opened, an error is raised API0034_FILE_OR_FOLDER_CANNOT_BE_OPENED.


\subsubsection coll_nodes_count 3.4.3 nodes-count

\code
  declare sequential function nodes-count($uri as xs:string) as xs:integer?
\endcode

The function returns the number of nodes in the given collection.

Error conditions:
If the specified collection does not exist, an error is raised API0006_COLLECTION_NOT_FOUND.
If the collection URI is empty and the default collection is not defined in the dynamic context, FODC0002 is raised.

\subsubsection ex_2_15 Example:
\include q38.cxq

\subsubsection coll_node_at 3.4.5 node-at

\code
  declare sequential function node-at($uri      as xs:string,
                                      $position as xs:integer ) as node()?
\endcode

The function will return the node positioned at <tt>position</tt> in the given collection.
Note: The collection is a list of nodes that is one based indexed.

Error conditions:
If the specified collection does not exist, an error is raised API0006_COLLECTION_NOT_FOUND.
If the collection has fewer nodes than <tt>position</tt> + 1 an error is raised API0030_NO_NODE_AT_GIVEN_POSITION.
If the collection URI is empty and the default collection is not defined in the dynamic context, FODC0002 is raised.

\subsubsection ex_2_16 Example:
\include node_at_1.xq

\subsubsection coll_export_xml 3.4.6 export-xml

\code
  declare sequential function export-xml( $uri        as xs:string,
                                          $targeturi  as xs:string ) as none
\endcode

Saves the given collection to the target URI as an XML file.
Intended supported targets (protocols) are:
"file:///path/file.xml" : (e.g. "file://c:/path/folder/file.xml") - saves the collection to a file, in the serialized form.
"http://www.example.com/path/file.xml" - saves the collection to a remote location, via the HTTP PUT request (to be implemented by the REST library).
If the protocol is omitted in the URI, "file://" is assumed.
The first function will use the collection's URI (the <tt>uri</tt> parameter) as the target URI.
The collection will be exported only if it can be serialized correctly - i.e. it is a well-formed XML document.

Error conditions:
If the collection can not be serialized correctly an error will be returned API0035_COLLECTION_CANNOT_BE_SERIALIZED.

*/
