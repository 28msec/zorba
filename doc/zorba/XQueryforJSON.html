<html><head><title>XQuery for JSON</title><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=lhDjYqiy3mZ0x6ROQEUoUw');ol{margin:0;padding:0}p{margin:0}.c10{list-style-type:disc;margin:0;padding:0}.c21{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c1{height:11pt;direction:ltr}.c9{color:#ff0000;font-style:italic}.c13{text-indent:-13.5pt;margin-left:76.5pt}.c2{color:#1155cc;text-decoration:underline}.c15{color:inherit;text-decoration:inherit}.c3{direction:ltr}.c6{text-align:justify}.c5{text-align:right}.c4{margin-left:144pt}.c11{font-style:italic}.c18{color:#ff9900}.c20{height:18pt}.c8{margin-left:36pt}.c19{text-align:center}.c17{color:#4a86e8}.c0{font-family:Consolas}.c7{color:#38761d}.c12{font-weight:bold}.c14{padding-left:0pt}.c16{margin-left:18pt}.title{padding-top:24pt;line-height:1.15;text-align:center;color:#4a86e8;font-size:36pt;font-family:Arial;font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:Georgia;padding-bottom:4pt}body{color:#000000;font-size:11pt;font-family:Arial}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#4a86e8;font-size:24pt;font-family:Arial;font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#ff9900;font-size:18pt;font-family:Arial;font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:Arial;font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#000000;font-size:12pt;font-family:Arial;font-weight:bold;padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#000000;font-size:11pt;font-family:Arial;font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:10pt;font-family:Arial;font-weight:bold;padding-bottom:2pt}</style></head><body class="c21"><p class="c3 title"><a name="h.li2wdq8unbq"></a><span>JSONiq for JSON users</span></p><p class="c3 title"><a name="h.5ipqqclfxk4n"></a><span class="c7">XQuery for JSON</span></p><hr><p class="c3 c19"><span>This tutorial introduces the JSONiq language, which declaratively manipulates JSON data.</span></p><p class="c3 c19"><span>Why don&#39;t you go ahead can try the queries of this document on our online demo interface?</span></p><p class="c3 c19"><span>&nbsp;</span><span class="c2 c12"><a class="c15" href="http://jsoniq.zorba-xquery.com/">http://jsoniq.zorba-xquery.com/</a></span></p><hr><p class="c1"><span></span></p><h2 class="c3 c20"><a name="h.8gra0ylxutrv"></a></h2><p class="c3 c16"><span class="c2"><a class="c15" href="#h.f453h84m2u1a">JSON</a></span></p><p class="c3 c16"><span class="c2"><a class="c15" href="#h.qtfakecy3fr7">Elevator Pitch</a></span></p><p class="c3 c16"><span class="c2"><a class="c15" href="#h.yugk1mszt0re">And here you go</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.4uvhbej4btrt">Like Monsieur Jourdain, you already knew some JSONiq</a></span></p><p class="c3 c16"><span class="c2"><a class="c15" href="#h.1gal1zhyffu4">JSONiq basics</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.ncbxtez2z3rn">The real JSONiq Hello, World!</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.ifcjheuaxoqc">Numbers and arithmetic operations</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.jmbc6c1fqqwx">Logical operations</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.iq1ixg5ywx0r">Strings</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.rv6w8p4wenfa">Sequences</a></span></p><p class="c3 c16"><span class="c2"><a class="c15" href="#h.7x2r8sj1zjwe">A bit more in depth</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.b6c9zq9um8cu">Variables</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.92ak2udyfghp">Iteration</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.zdhx60a5duyu">Conditions</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.ccs6lkxiixw4">Composability of Expressions</a></span></p><p class="c3 c16"><span class="c2"><a class="c15" href="#h.mjv7kyjurri2">JSON Navigation</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.xosiyb17dh24">Objects</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.mrf42gizl3y6">Arrays</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.hdc3dgohtdut">Pairs</a></span></p><p class="c3 c16"><span class="c2"><a class="c15" href="#h.eb0bxle2oykl">Relational Algebra</a></span></p><p class="c3 c16"><span class="c2"><a class="c15" href="#h.oii6pvliilhi">Access external data</a></span></p><p class="c3 c16"><span class="c2"><a class="c15" href="#h.bm3buqmzhtko">I want more</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.5itcphr8262b">Even more</a></span></p><p class="c3 c8"><span class="c2"><a class="c15" href="#h.j7oh3cyhem38">More is not enough</a></span></p><p><span></span></p><p class="c1"><span></span></p><h1 class="c3"><a name="h.f453h84m2u1a"></a><span>JSON</span></h1><p class="c3 c6"><span>As explained on </span><span class="c2"><a class="c15" href="http://www.json.org/">http://www.json.org/</a></span><span>, JSON is a lightweight data-interchange format designed for humans as well as for computers. It supports as values:</span></p><ol class="c10" start="1"><li class="c3 c6 c8 c14"><span>objects (string-to-value map)</span></li><li class="c3 c6 c8 c14"><span>arrays (ordered sequence of values)</span></li><li class="c3 c6 c8 c14"><span>strings</span></li><li class="c3 c6 c8 c14"><span>numbers</span></li><li class="c3 c6 c8 c14"><span>booleans (true, false)</span></li><li class="c3 c6 c8 c14"><span>null</span></li></ol><p class="c1"><span></span></p><p class="c3"><span>JSONiq provides declarative querying and updating capabilities on JSON data.</span></p><h1 class="c3"><a name="h.qtfakecy3fr7"></a><span>Elevator Pitch</span></h1><p class="c3 c6"><span>JSONiq is based on XQuery, which is a W3C standard (like XML and HTML). XQuery is a very powerful declarative language that manipulates XML data, but that is also a very good fit for JSON. Here is an appetizer before we start the tutorial from scratch.</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">let $stores :=</span></p><p class="c3"><span class="c0">[</span></p><p class="c3"><span class="c0">&nbsp; { &quot;store number&quot; : 1, &quot;state&quot; : &quot;MA&quot; },</span></p><p class="c3"><span class="c0">&nbsp; { &quot;store number&quot; : 2, &quot;state&quot; : &quot;MA&quot; },</span></p><p class="c3"><span class="c0">&nbsp; { &quot;store number&quot; : 3, &quot;state&quot; : &quot;CA&quot; },</span></p><p class="c3"><span class="c0">&nbsp; { &quot;store number&quot; : 4, &quot;state&quot; : &quot;CA&quot; }</span></p><p class="c3"><span class="c0">]</span></p><p class="c3"><span class="c0">let $sales := [</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;broiler&quot;, &quot;store number&quot; : 1, &quot;quantity&quot; : 20 &nbsp;},</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 100 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 50 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 50 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;blender&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 100 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;blender&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 150 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;socks&quot;, &quot;store number&quot; : 1, &quot;quantity&quot; : 500 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;socks&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 10 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;shirt&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 10 }</span></p><p class="c3"><span class="c0">]</span></p><p class="c3"><span class="c0">let $join :=</span></p><p class="c3"><span class="c0">&nbsp; for $store in jn:values($stores), $sale in jn:values($sales)</span></p><p class="c3"><span class="c0">&nbsp; where $store(&quot;store number&quot;) = $sale(&quot;store number&quot;)</span></p><p class="c3"><span class="c0">&nbsp; return {</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; &quot;nb&quot; : $store(&quot;store number&quot;),</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; &quot;state&quot; : $store(&quot;state&quot;),</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; &quot;sold&quot; : $sale(&quot;product&quot;)</span></p><p class="c3"><span class="c0">&nbsp; }</span></p><p class="c3"><span class="c0">return [$join]</span></p><p class="c3 c4"><span class="c0 c7">[ </span></p><p class="c3 c4"><span class="c0 c7">&nbsp; { &quot;nb&quot; : 1, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;broiler&quot; },</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; { &quot;nb&quot; : 1, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;socks&quot; },</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; { &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; { &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; { &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;socks&quot; },</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; { &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; { &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;blender&quot; },</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; { &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;blender&quot; },</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; { &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;shirt&quot; }</span></p><p class="c3 c4"><span class="c0 c7">&nbsp;]</span></p><p class="c1"><span></span></p><h1 class="c3"><a name="h.yugk1mszt0re"></a><span>And here you go</span></h1><h2 class="c3"><a name="h.4uvhbej4btrt"></a><span>Like Monsieur Jourdain, you already knew some JSONiq</span></h2><p class="c3 c6"><span>The first thing you need to know is that every well-formed JSON document is a JSONiq query as well.</span></p><p class="c1"><span></span></p><p class="c3 c6"><span>This means that you can copy-and-paste a JSON document into a query. The following are JSONiq queries that are &quot;idempotent&quot; (they just output themselves):</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">{ &quot;pi&quot; : 3.14, &quot;sq2&quot; : 1.4 }</span></p><p class="c3 c5"><span class="c0 c7">{ &quot;pi&quot; : 3.14, &quot;sq2&quot; : 1.4 }</span></p><p class="c1"><span class="c0 c7"></span></p><p class="c3"><span class="c0">[ 2, 3, 5, 7, 11, 13 ]</span></p><p class="c3 c5"><span class="c0 c7">[ 2, 3, 5, 7, 11, 13 ]</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">{</span></p><p class="c3"><span class="c0">&nbsp; &quot;operations&quot; : [</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; { &quot;binary&quot; : [ &quot;and&quot;, &quot;or&quot;] },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; { &quot;unary&quot; : [&quot;not&quot;] }</span></p><p class="c3"><span class="c0">&nbsp; ],</span></p><p class="c3"><span class="c0">&nbsp; &quot;bits&quot; : [</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; 0, 1</span></p><p class="c3"><span class="c0">&nbsp; ]</span></p><p class="c3"><span class="c0">}</span></p><p class="c3 c4"><span class="c0 c7">{</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; &quot;operations&quot; : [</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; &nbsp; { &quot;binary&quot; : [ &quot;and&quot;, &quot;or&quot; ] },</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; &nbsp; { &quot;unary&quot; : [ &quot;not&quot; ] }</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; ],</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; &quot;bits&quot; : [</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; &nbsp; 0, 1</span></p><p class="c3 c4"><span class="c0 c7">&nbsp; ]</span></p><p class="c3 c4"><span class="c0 c7">}</span></p><p class="c1 c5"><span class="c0 c7"></span></p><p class="c3"><span>This works with objects, arrays (even nested), strings, numbers, booleans, null. </span><span class="c11">The exceptions to this rule (but we are working on it!) are that:</span></p><p class="c3 c6"><span class="c11">(i) if a pair has a true, false or null value, there must be a space on at least one side of the colon (this will be fixed).</span></p><p class="c3 c6"><span class="c11">(ii) empty objects are not recognized</span></p><p class="c3 c6"><span class="c11">(iii) characters escaped with the \ in JSON strings are not recognized</span></p><p class="c1"><span class="c9 c0"></span></p><p class="c3 c6"><span>It also works the other way round: if your query outputs an object or an array, you can readily use it as a JSON document.</span></p><p class="c1"><span></span></p><p class="c3 c6"><span>JSONiq is a declarative language. This means that you only need to say </span><span class="c11">what</span><span>&nbsp;you want - the compiler will take care of the </span><span class="c11">how</span><span>. In the above queries, you are basically saying: I want to output this JSON content, and here it is.</span></p><h1 class="c3"><a name="h.1gal1zhyffu4"></a><span>JSONiq basics</span></h1><h2 class="c3"><a name="h.ncbxtez2z3rn"></a><span>The real JSONiq Hello, World!</span></h2><p class="c3"><span>Wondering what a hello world program looks like in JSONiq? Here it is:</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">&quot;Hello, World!&quot;</span></p><p class="c3 c5"><span class="c0 c7">Hello, World!</span></p><p class="c1"><span class="c0 c7"></span></p><p class="c3"><span>Not surprisingly, it outputs the string &quot;Hello, World!&quot;. Again, just say what you want and you will get it.</span></p><h2 class="c3"><a name="h.ifcjheuaxoqc"></a><span>Numbers and arithmetic operations</span></h2><p class="c3 c6"><span>Okay, so, now, you might be thinking: &quot;What is the use of this language if it just outputs what I put in?&quot; Of course, JSONiq can more than that. And still in a declarative way. Here is how it works with numbers:</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">2 + 2</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span>will surprisingly output:</span></p><p class="c3 c5"><span class="c0 c7">4</span></p><p class="c1"><span></span></p><p class="c3"><span>whereas</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">(38 + 2) div 2 + 11 * 2</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span>will output</span></p><p class="c3 c5"><span class="c0 c7">42</span></p><p class="c1"><span class="c0 c7"></span></p><p class="c3 c6"><span>(mind the division operator which is the &quot;div&quot; keyword. The slash has other semantics).</span></p><p class="c1"><span></span></p><p class="c3"><span>Like JSON, JSONiq works with decimals, too:</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">6.022e23 * 42</span></p><p class="c3 c5"><span class="c0 c7">2.52924E25</span></p><h2 class="c3"><a name="h.jmbc6c1fqqwx"></a><span>Logical operations</span></h2><p class="c3 c6"><span>JSONiq supports boolean operations.</span></p><p class="c1 c6"><span></span></p><p class="c3"><span class="c0">true and false</span></p><p class="c3 c5"><span class="c0 c7">false</span></p><p class="c1 c5"><span class="c0 c7"></span></p><p class="c3"><span class="c0">(true or false) and (false or true)</span></p><p class="c3 c5"><span class="c0 c7">true</span></p><p class="c1 c5"><span class="c0 c7"></span></p><p class="c3"><span>The unary not is a function (yes, JSONiq has functions, and they are in the same way as in many languages):</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">not(true)</span></p><p class="c3 c5"><span class="c0 c7">false</span></p><h2 class="c3"><a name="h.iq1ixg5ywx0r"></a><span>Strings</span></h2><p class="c3"><span>JSONiq is capable of manipulating strings as well, using functions:</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">concat(&quot;Hello &quot;, &quot;Captain Kirk&quot;)</span></p><p class="c3 c5"><span class="c0 c7">Hello Captain Kirk</span></p><p class="c1 c5"><span class="c0 c7"></span></p><p class="c3"><span class="c0">substring(&quot;Mister Spock&quot;, 8, 5)</span></p><p class="c3 c5"><span class="c0 c7">Spock</span></p><h2 class="c3"><a name="h.rv6w8p4wenfa"></a><span>Sequences</span></h2><p class="c3"><span>Until now, we only handled single values (an object, an array, a number, a string, a boolean). JSONiq supports sequences of values. You can build a sequence using commas:</span></p><p class="c1"><span></span></p><p class="c3"><span>1, 2, 3, 4, 5, 6, 7, 8, 9, 10</span></p><p class="c3 c5"><span class="c7">1 2 3 4 5 6 7 8 9 10</span></p><p class="c1"><span class="c7"></span></p><p class="c3"><span class="c0">1, </span><span class="c0">true</span><span class="c0">, 4.2e1, &quot;Life&quot;</span></p><p class="c3 c5"><span class="c0 c7">1 true 42 Life</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">{ &quot;Question&quot; : &quot;Ultimate&quot; }, [&quot;Life&quot;, &quot;The universe&quot;, &quot;and everything&quot;]</span></p><p class="c1 c5"><span class="c0"></span></p><p class="c3 c5"><span class="c0 c7">{ &quot;Question&quot; : &quot;Ultimate&quot; }[ &quot;Life&quot;, &quot;The universe&quot;, &quot;and everything&quot; ]</span></p><p class="c1 c5"><span class="c0"></span></p><p class="c3"><span>The &quot;to&quot; operator is very convenient, too:</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">1 to 100</span></p><p class="c3 c5"><span class="c7">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</span></p><p class="c3 c5"><span class="c7">21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40</span></p><p class="c3 c5"><span class="c7">41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60</span></p><p class="c3 c5"><span class="c7">61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80</span></p><p class="c3 c5"><span class="c7">81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100</span></p><p class="c1"><span></span></p><p class="c3"><span>Some functions even work on sequences:</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">sum(1 to 100)</span></p><p class="c3 c5"><span class="c0 c7">5050</span></p><p class="c1 c5"><span class="c0 c7"></span></p><p class="c3"><span class="c0">string-join((&quot;These&quot;, &quot;are&quot;, &quot;some&quot;, &quot;words&quot;), &quot;-&quot;)</span></p><p class="c3 c5"><span class="c0 c7">These-are-some-words</span></p><p class="c1 c5"><span class="c0 c7"></span></p><p class="c3"><span class="c0">count(10 to 20)</span></p><p class="c3 c5"><span class="c0 c7">11</span></p><p class="c1"><span class="c0 c7"></span></p><p class="c3"><span class="c0">avg(1 to 100)</span></p><p class="c3 c5"><span class="c0 c7">50.5</span></p><h1 class="c3"><a name="h.7x2r8sj1zjwe"></a><span>A bit more in depth</span></h1><h2 class="c3"><a name="h.b6c9zq9um8cu"></a><span>Variables</span></h2><p class="c3"><span>You can bind a sequence of values to a (dollar-prefixed) variable, like so:</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">let $x := &quot;Bearing 3 1 4 Mark 5. &quot;</span></p><p class="c3"><span class="c0">return concat($x, &quot;Engage!&quot;)</span></p><p class="c3 c5"><span class="c0 c7">Bearing 3 1 4 Mark 5. Engage!</span></p><p class="c1 c5"><span class="c0 c7"></span></p><p class="c1 c5"><span class="c0"></span></p><p class="c3"><span class="c0">let $x := (&quot;Kirk&quot;, &quot;Picard&quot;, &quot;Sisko&quot;)</span></p><p class="c3"><span class="c0">return string-join($x, &quot; and &quot;)</span></p><p class="c3 c5"><span class="c0 c7">Kirk and Picard and Sisko</span></p><p class="c1"><span class="c0 c7"></span></p><p class="c3"><span>You can bind as many variables as you want:</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">let $x := 1</span></p><p class="c3"><span class="c0">let $y := $x * 2</span></p><p class="c3"><span class="c0">let $z := $y + $x</span></p><p class="c3"><span class="c0">return [$x, $y, $z]</span></p><p class="c3 c5"><span class="c0 c7">[ 1, 2, 3 ]</span></p><p class="c1 c5"><span class="c0 c7"></span></p><p class="c3"><span>and even reuse the same name:</span></p><p class="c3"><span class="c0">let $x := 1</span></p><p class="c3"><span class="c0">let $x := $x + 2</span></p><p class="c3"><span class="c0">let $x := $x + 3</span></p><p class="c3"><span class="c0">return $x</span></p><p class="c3 c5"><span class="c0 c7">6</span></p><h2 class="c3"><a name="h.92ak2udyfghp"></a><span>Iteration</span></h2><p class="c3 c6"><span>In a way very similar to let, you can iterate over a sequence of values with the &quot;for&quot; keyword. Instead of binding the entire sequence of the variable, it will bind each value of the sequence in turn to this variable.</span></p><p class="c1 c6"><span></span></p><p class="c3 c6"><span class="c0">for $i in 1 to 10</span></p><p class="c3 c6"><span class="c0">return $i * 2</span></p><p class="c3 c5"><span class="c0 c7">2 4 6 8 10 12 14 16 18 20</span></p><p class="c1 c5"><span class="c0 c7"></span></p><p class="c3"><span>More interestingly, you can combine fors and lets like so:</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">let $sequence := 1 to 10</span></p><p class="c3"><span class="c0">for $value in $sequence</span></p><p class="c3"><span class="c0">let $square := $value * 2</span></p><p class="c3"><span class="c0">return $square</span></p><p class="c3 c5"><span class="c0 c7">2 4 6 8 10 12 14 16 18 20</span></p><p class="c1 c5"><span class="c0 c7"></span></p><p class="c3"><span>and even filter out some values:</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">let $sequence := 1 to 10</span></p><p class="c3"><span class="c0">for $value in $sequence</span></p><p class="c3"><span class="c0">let $square := $value * 2</span></p><p class="c3"><span class="c0">where $square &lt; 10</span></p><p class="c3"><span class="c0">return $square</span></p><p class="c3 c5"><span class="c0 c7">2 4 6 8</span></p><h2 class="c3"><a name="h.zdhx60a5duyu"></a><span>Conditions</span></h2><p class="c3"><span>You can make the output depend on a condition with an if-then-else construct:</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">for $x in 1 to 10</span></p><p class="c3"><span class="c0">return if ($x &lt; 5) then $x</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else -$x</span></p><p class="c3 c5"><span class="c0 c7">1 2 3 4 -5 -6 -7 -8 -9 -10</span></p><h2 class="c3"><a name="h.ccs6lkxiixw4"></a><span>Composability of Expressions</span></h2><p class="c3"><span>Now that you know of a couple of elementary JSONiq expressions, you can combine then in more elaborate expressions. For example, you can put any sequence of values in an array:</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">[ 1 to 10 ]</span></p><p class="c3 c5"><span class="c0 c7">[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</span></p><p class="c1 c5"><span class="c0 c7"></span></p><p class="c3"><span>Or you can dynamically compute the value of object pairs:</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">{</span></p><p class="c3"><span class="c0">&nbsp; &quot;Greeting&quot; : let $d := &quot;Mister Spock&quot;</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return concat(&quot;Hello, &quot;, $d),</span></p><p class="c3"><span class="c0">&nbsp; &quot;Farewell&quot; : string-join((&quot;Live&quot;, &quot;long&quot;, &quot;and&quot;, &quot;prosper&quot;),</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot; &quot;)</span></p><p class="c3"><span class="c0">}</span></p><p class="c1"><span class="c0 c7"></span></p><p class="c3 c5"><span class="c0 c7">{ &quot;Greeting&quot; : &quot;Hello, Mister Spock&quot;, &quot;Farewell&quot; : &quot;Live long and prosper&quot; }</span></p><p class="c1"><span class="c7"></span></p><p class="c3"><span>You can also dynamically generate pairs:</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">concat(&quot;Integer &quot;, 2) : 2 * 2</span></p><p class="c3 c5"><span class="c0 c7">&quot;Integer 2&quot; : 4</span></p><p class="c1 c5"><span class="c0 c7"></span></p><p class="c3"><span>and then wrap lots of them in an object:</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">{</span></p><p class="c3"><span class="c0">&nbsp; for $i in 1 to 10</span></p><p class="c3"><span class="c0">&nbsp; return concat(&quot;Square of &quot;, $i) : $i * $i</span></p><p class="c3"><span class="c0">}</span></p><p class="c3 c4"><span class="c0 c7">{</span></p><p class="c3 c4"><span class="c0 c7">&quot;Square of 1&quot; : 1,</span></p><p class="c3 c4"><span class="c0 c7">&quot;Square of 2&quot; : 4,</span></p><p class="c3 c4"><span class="c0 c7">&quot;Square of 3&quot; : 9,</span></p><p class="c3 c4"><span class="c0 c7">&quot;Square of 4&quot; : 16,</span></p><p class="c3 c4"><span class="c0 c7">&quot;Square of 5&quot; : 25,</span></p><p class="c3 c4"><span class="c0 c7">&quot;Square of 6&quot; : 36,</span></p><p class="c3 c4"><span class="c0 c7">&quot;Square of 7&quot; : 49,</span></p><p class="c3 c4"><span class="c0 c7">&quot;Square of 8&quot; : 64,</span></p><p class="c3 c4"><span class="c0 c7">&quot;Square of 9&quot; : 81,</span></p><p class="c3 c4"><span class="c0 c7">&quot;Square of 10&quot; : 100</span></p><p class="c3 c4"><span class="c0 c7">}</span></p><h1 class="c3"><a name="h.mjv7kyjurri2"></a><span>JSON Navigation</span></h1><p class="c3 c6"><span>Up to now, you learnt how to compose expressions so as to do some computations and to build pairs, objects and arrays. It also works the other way round: if you have some JSON data, you can access it and navigate.</span></p><p class="c1 c6"><span></span></p><p class="c3 c6"><span>All you need to know is: JSONiq views</span></p><ol class="c10" start="1"><li class="c3 c6 c8 c14"><span>an array as a sequence of values,</span></li><li class="c3 c6 c8 c14"><span>an object as a set of name/value pairs (we call them just: pairs)</span></li><li class="c3 c6 c8 c14"><span>a pair as a (name, value) tuple.</span></li></ol><h2 class="c3 c6"><a name="h.xosiyb17dh24"></a><span>Objects</span></h2><p class="c3 c6"><span>If you use an object as a functor and provide it with a string, it will return the pair named after its parameter:</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">let $person := {</span></p><p class="c3"><span class="c0">&nbsp; &quot;first name&quot; : &quot;Sarah&quot;,</span></p><p class="c3"><span class="c0">&nbsp; &quot;age&quot; : 13,</span></p><p class="c3"><span class="c0">&nbsp; &quot;gender&quot; : &quot;female&quot;,</span></p><p class="c3"><span class="c0">&nbsp; &quot;friends&quot; : [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot;]</span></p><p class="c3"><span class="c0">}</span></p><p class="c3"><span class="c0">return $person(&quot;first name&quot;)</span></p><p class="c3 c5"><span class="c0 c7">&quot;first name&quot; : &quot;Sarah&quot;</span></p><p class="c1 c5"><span class="c0 c7"></span></p><h2 class="c3"><a name="h.mrf42gizl3y6"></a><span>Arrays</span></h2><p class="c3 c6"><span>If you use an array as a functor and provide it with an integer, it will return the corresponding entry:</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">let $friends := [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot;]</span></p><p class="c3"><span class="c0">return $friends(2)</span></p><p class="c3 c5"><span class="c0 c7">Mary</span></p><h2 class="c3"><a name="h.hdc3dgohtdut"></a><span>Pairs</span></h2><p class="c3"><span>Given a pair, you can get its name and value using the functions jn:name and jn:value:</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">let $pair := &quot;name of the pair&quot; : &quot;value of the pair&quot;</span></p><p class="c3"><span class="c0">return { &nbsp;&quot;name&quot; : jn:name($pair), &quot;value&quot; : jn:value($pair) }</span></p><p class="c1"><span class="c0"></span></p><p class="c3 c5"><span class="c0 c7">{ &quot;name&quot; : &quot;name of the pair&quot;, &quot;value&quot; : &quot;value of the pair&quot; }</span></p><p class="c1"><span class="c7"></span></p><p class="c3"><span>This functions also exist in plural form for objects:</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">let $person := {</span></p><p class="c3"><span class="c0">&nbsp; &quot;name&quot; : &quot;Sarah&quot;,</span></p><p class="c3"><span class="c0">&nbsp; &quot;age&quot; : 13,</span></p><p class="c3"><span class="c0">&nbsp; &quot;gender&quot; : &quot;female&quot;,</span></p><p class="c3"><span class="c0">&nbsp; &quot;friends&quot; : [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot;]</span></p><p class="c3"><span class="c0">}</span></p><p class="c3"><span class="c0">return { &quot;names&quot; : [ jn:names($person)],</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;values&quot; : [ jn:values($person)]</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c3 c13"><span class="c0 c7">{</span></p><p class="c13 c3"><span class="c0 c7">&quot;names&quot; : [ &quot;name&quot;, &quot;age&quot;, &quot;gender&quot;, &quot;friends&quot; ],</span></p><p class="c13 c3"><span class="c0 c7">&quot;values&quot; : [ &quot;Sarah&quot;, 13, &quot;female&quot;, [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot; ] ]</span></p><p class="c13 c3"><span class="c0 c7">}</span></p><p class="c3"><span>jn:values can also be used for an array:</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">let $person := {</span></p><p class="c3"><span class="c0">&nbsp; &quot;name&quot; : &quot;Sarah&quot;,</span></p><p class="c3"><span class="c0">&nbsp; &quot;age&quot; : 13,</span></p><p class="c3"><span class="c0">&nbsp; &quot;gender&quot; : &quot;female&quot;,</span></p><p class="c3"><span class="c0">&nbsp; &quot;friends&quot; : [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot;]</span></p><p class="c3"><span class="c0">}</span></p><p class="c3"><span class="c0">return jn:values($person(&quot;friends&quot;))</span></p><p class="c3 c5"><span class="c7">[ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot; ]</span></p><p class="c1 c5"><span class="c7"></span></p><h1 class="c3"><a name="h.eb0bxle2oykl"></a><span>Relational Algebra</span></h1><p class="c3 c6"><span>Remember last century&#39;s SELECT FROM WHERE statements? Well, JSONiq didn&#39;t throw out the baby with the bathwater. It has selection, projection and join capability.</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">let $stores :=</span></p><p class="c3"><span class="c0">[</span></p><p class="c3"><span class="c0">&nbsp; { &quot;store number&quot; : 1, &quot;state&quot; : &quot;MA&quot; },</span></p><p class="c3"><span class="c0">&nbsp; { &quot;store number&quot; : 2, &quot;state&quot; : &quot;MA&quot; },</span></p><p class="c3"><span class="c0">&nbsp; { &quot;store number&quot; : 3, &quot;state&quot; : &quot;CA&quot; },</span></p><p class="c3"><span class="c0">&nbsp; { &quot;store number&quot; : 4, &quot;state&quot; : &quot;CA&quot; }</span></p><p class="c3"><span class="c0">]</span></p><p class="c3"><span class="c0">let $sales := [</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;broiler&quot;, &quot;store number&quot; : 1, &quot;quantity&quot; : 20 &nbsp;},</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 100 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 50 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 50 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;blender&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 100 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;blender&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 150 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;socks&quot;, &quot;store number&quot; : 1, &quot;quantity&quot; : 500 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;socks&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 10 },</span></p><p class="c3"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;shirt&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 10 }</span></p><p class="c3"><span class="c0">]</span></p><p class="c3"><span class="c0">let $join :=</span></p><p class="c3"><span class="c0">&nbsp; for $store in jn:values($stores), $sale in jn:values($sales)</span></p><p class="c3"><span class="c0">&nbsp; where $store(&quot;store number&quot;) = $sale(&quot;store number&quot;)</span></p><p class="c3"><span class="c0">&nbsp; return {</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; &quot;nb&quot; : $store(&quot;store number&quot;),</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; &quot;state&quot; : $store(&quot;state&quot;),</span></p><p class="c3"><span class="c0">&nbsp; &nbsp; &quot;sold&quot; : $sale(&quot;product&quot;)</span></p><p class="c3"><span class="c0">&nbsp; }</span></p><p class="c3"><span class="c0">return [$join]</span></p><p class="c3 c4"><span class="c0 c7">[ </span></p><p class="c3 c4"><span class="c0 c7">{ &quot;nb&quot; : 1, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;broiler&quot; },</span></p><p class="c3 c4"><span class="c0 c7">{ &quot;nb&quot; : 1, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;socks&quot; },</span></p><p class="c3 c4"><span class="c0 c7">{ &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c3 c4"><span class="c0 c7">{ &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c3 c4"><span class="c0 c7">{ &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;socks&quot; },</span></p><p class="c3 c4"><span class="c0 c7">{ &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c3 c4"><span class="c0 c7">{ &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;blender&quot; },</span></p><p class="c3 c4"><span class="c0 c7">{ &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;blender&quot; },</span></p><p class="c3 c4"><span class="c0 c7">{ &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;shirt&quot; }</span></p><p class="c3 c4"><span class="c0 c7">&nbsp;]</span></p><h1 class="c3"><a name="h.oii6pvliilhi"></a><span>Access external data</span></h1><p class="c3"><span>You can access a JSON file on your local disk with</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">jn:json(&quot;file.json&quot;)</span></p><p class="c3 c5"><span class="c0 c7">[ &quot;The&quot;, &quot;contents&quot;, &quot;of&quot;, &quot;your&quot;, &quot;file&quot; ]</span></p><p class="c1"><span></span></p><p class="c3"><span>Our implementation even supports collections of JSON objects or arrays:</span></p><p class="c1"><span></span></p><p class="c3"><span class="c0">dml:collection(&quot;my:data&quot;)</span></p><p class="c3 c5"><span class="c0 c7">{ &quot;foo&quot; : &quot;Your&quot; }</span></p><p class="c3 c5"><span class="c0 c7">{ &quot;foo&quot; : &quot;Collection&quot; }</span></p><p class="c3 c5"><span class="c0 c7">{ &quot;foo&quot; : &quot;of&quot; }</span></p><p class="c3 c5"><span class="c0 c7">{ &quot;foo&quot; : &quot;JSON&quot; }</span></p><p class="c3 c5"><span class="c0 c7">{ &quot;foo&quot; : &quot;objects&quot; }</span></p><h1 class="c3"><a name="h.bm3buqmzhtko"></a><span>I want more</span></h1><p class="c3 c6"><span>JSONiq supports JSON updates. You can declaratively update your JSON data. JSONiq provides functions that produce a list of updates. The list of updates that is eventually output by your program is then applied to your JSON data.</span></p><p class="c1"><span></span></p><p class="c3"><span>let $my-data := jn:json(&quot;persons.json&quot;)</span></p><p class="c3"><span>let $john := jn:value($my-data(&quot;John&quot;))</span></p><p class="c3"><span>let $mary := jn:value($my-data(&quot;Mary&quot;))</span></p><p class="c3"><span>return (jn:replace-value($john, &quot;status&quot;, &quot;married&quot;), j:replace-value($mary, &quot;status&quot;, &quot;married&quot;))</span></p><h2 class="c3"><a name="h.5itcphr8262b"></a><span>Even more</span></h2><p class="c3"><span>JSONiq can do way more that what is presented here. Here are a couple of highlights:</span></p><p class="c3 c6"><span>- JSONiq is a strongly typed language, but is smart enough to not bother you with types when unnecessary. It potentially supports static typing as well to detect errors before you even execute your program.</span></p><p class="c3"><span>- You can define your own functions and modules.</span></p><p class="c3"><span>- JSONiq provides you with loads of available modules.</span></p><p class="c3 c6"><span>- JSONiq has tons of further features such as switch, typeswitch and try-catch expressions, universal/existential quantifiers, path expressions, filtering expressions, functors, mappings, grouping, windowing.</span></p><h2 class="c3"><a name="h.j7oh3cyhem38"></a><span>More is not enough</span></h2><p class="c3 c6"><span>- JSONiq supports XML. Yes: you can manipulate JSON and XML with the same language! JSONiq is actually a superset of XQuery, a W3C standard, and extends its data model to support JSON.</span></p><p class="c3 c6"><span>- JSONiq supports scripting. If you need to write a full-fledged, side-effecting Web application, scripting is for you.</span></p></body></html>