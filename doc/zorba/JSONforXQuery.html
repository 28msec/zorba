<html><head><title>JSON for XQuery</title><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=lhDjYqiy3mZ0x6ROQEUoUw');ol{margin:0;padding:0}p{margin:0}.c22{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c19{list-style-type:disc;margin:0;padding:0}.c6{padding-left:0pt;text-align:justify;margin-left:36pt}.c0{height:11pt;direction:ltr}.c3{color:#38761d;font-family:Consolas}.c2{color:inherit;text-decoration:inherit}.c4{color:#1155cc;text-decoration:underline}.c1{direction:ltr}.c20{height:18pt}.c9{margin-left:58.5pt}.c13{text-indent:139.5pt}.c17{text-indent:144pt}.c7{margin-left:144pt}.c8{text-align:right}.c11{font-weight:bold}.c16{text-align:justify}.c10{margin-left:36pt}.c5{font-family:Consolas}.c18{color:#38761d}.c15{margin-left:49.5pt}.c21{text-align:center}.c23{color:#4a86e8}.c12{font-style:italic}.c14{margin-left:18pt}.title{padding-top:24pt;line-height:1.15;text-align:center;color:#4a86e8;font-size:36pt;font-family:Arial;font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:Georgia;padding-bottom:4pt}body{color:#000000;font-size:11pt;font-family:Arial}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#4a86e8;font-size:24pt;font-family:Arial;font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#ff9900;font-size:18pt;font-family:Arial;font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:Arial;font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#000000;font-size:12pt;font-family:Arial;font-weight:bold;padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#000000;font-size:11pt;font-family:Arial;font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:10pt;font-family:Arial;font-weight:bold;padding-bottom:2pt}</style></head><body class="c22"><p class="c1 title"><a name="h.li2wdq8unbq"></a><span>JSONiq for XQuery users</span></p><p class="c1 title"><a name="h.5ipqqclfxk4n"></a><span class="c18">JSON for XQuery</span></p><hr><p class="c1 c21"><span>This tutorial introduces the JSONiq language, which declaratively manipulates JSON data.</span></p><p class="c1 c21"><span>Why don&#39;t you go ahead can try the queries of this document on our online demo interface?</span></p><p class="c1 c21"><span>&nbsp;</span><span class="c4 c11"><a class="c2" href="http://jsoniq.zorba-xquery.com/">http://jsoniq.zorba-xquery.com/</a></span></p><hr><p class="c0"><span></span></p><h2 class="c1 c20"><a name="h.8gra0ylxutrv"></a></h2><p class="c1 c14"><span class="c4"><a class="c2" href="#h.f453h84m2u1a">JSON</a></span></p><p class="c1 c14"><span class="c4"><a class="c2" href="#h.qtfakecy3fr7">Elevator Pitch</a></span></p><p class="c1 c14"><span class="c4"><a class="c2" href="#h.yugk1mszt0re">And here you go</a></span></p><p class="c1 c10"><span class="c4"><a class="c2" href="#h.39rm37noeh9g">JSONiq types</a></span></p><p class="c1 c10"><span class="c4"><a class="c2" href="#h.j0wg8654ivtw">JSON Constructors</a></span></p><p class="c1 c10"><span class="c4"><a class="c2" href="#h.qe57mgdf5ql">JSON as a subset of JSONiq</a></span></p><p class="c1 c14"><span class="c4"><a class="c2" href="#h.mjv7kyjurri2">JSON Navigation</a></span></p><p class="c1 c10"><span class="c4"><a class="c2" href="#h.xosiyb17dh24">Objects</a></span></p><p class="c1 c10"><span class="c4"><a class="c2" href="#h.mrf42gizl3y6">Arrays</a></span></p><p class="c1 c10"><span class="c4"><a class="c2" href="#h.hdc3dgohtdut">Pairs</a></span></p><p class="c1 c14"><span class="c4"><a class="c2" href="#h.eb0bxle2oykl">Relational Algebra</a></span></p><p class="c1 c14"><span class="c4"><a class="c2" href="#h.oii6pvliilhi">Access external data</a></span></p><p class="c1 c14"><span class="c4"><a class="c2" href="#h.bm3buqmzhtko">I want more</a></span></p><p><span></span></p><p class="c0"><span></span></p><h1 class="c1"><a name="h.f453h84m2u1a"></a><span>JSON</span></h1><p class="c1 c16"><span>As explained on </span><span class="c4"><a class="c2" href="http://www.json.org/">http://www.json.org/</a></span><span>, JSON is a lightweight data-interchange format designed for humans as well as for computers. It supports as values:</span></p><ol class="c19" start="1"><li class="c6 c1"><span>objects (string-to-value map)</span></li><li class="c6 c1"><span>arrays (ordered sequence of values)</span></li><li class="c6 c1"><span>strings</span></li><li class="c6 c1"><span>numbers</span></li><li class="c6 c1"><span>booleans (true, false)</span></li><li class="c6 c1"><span>null</span></li></ol><p class="c0"><span></span></p><p class="c1"><span>JSONiq extends XQuery to query and update JSON data, like XML data.</span></p><h1 class="c1"><a name="h.qtfakecy3fr7"></a><span>Elevator Pitch</span></h1><p class="c1 c16"><span>Here is an appetizer before we start the tutorial from scratch.</span></p><p class="c0"><span></span></p><p class="c1"><span class="c5">let $stores :=</span></p><p class="c1"><span class="c5">[</span></p><p class="c1"><span class="c5">&nbsp; { &quot;store number&quot; : 1, &quot;state&quot; : &quot;MA&quot; },</span></p><p class="c1"><span class="c5">&nbsp; { &quot;store number&quot; : 2, &quot;state&quot; : &quot;MA&quot; },</span></p><p class="c1"><span class="c5">&nbsp; { &quot;store number&quot; : 3, &quot;state&quot; : &quot;CA&quot; },</span></p><p class="c1"><span class="c5">&nbsp; { &quot;store number&quot; : 4, &quot;state&quot; : &quot;CA&quot; }</span></p><p class="c1"><span class="c5">]</span></p><p class="c1"><span class="c5">let $sales := [</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;broiler&quot;, &quot;store number&quot; : 1, &quot;quantity&quot; : 20 &nbsp;},</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 100 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 50 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 50 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;blender&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 100 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;blender&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 150 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;socks&quot;, &quot;store number&quot; : 1, &quot;quantity&quot; : 500 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;socks&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 10 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;shirt&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 10 }</span></p><p class="c1"><span class="c5">]</span></p><p class="c1"><span class="c5">let $join :=</span></p><p class="c1"><span class="c5">&nbsp; for $store in jn:values($stores), $sale in jn:values($sales)</span></p><p class="c1"><span class="c5">&nbsp; where $store(&quot;store number&quot;) = $sale(&quot;store number&quot;)</span></p><p class="c1"><span class="c5">&nbsp; return {</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &quot;nb&quot; : $store(&quot;store number&quot;),</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &quot;state&quot; : $store(&quot;state&quot;),</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &quot;sold&quot; : $sale(&quot;product&quot;)</span></p><p class="c1"><span class="c5">&nbsp; }</span></p><p class="c1"><span class="c5">return [$join]</span></p><p class="c1 c7"><span class="c3">[ </span></p><p class="c1 c7"><span class="c3">&nbsp; { &quot;nb&quot; : 1, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;broiler&quot; },</span></p><p class="c1 c7"><span class="c3">&nbsp; { &quot;nb&quot; : 1, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;socks&quot; },</span></p><p class="c1 c7"><span class="c3">&nbsp; { &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c1 c7"><span class="c3">&nbsp; { &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c1 c7"><span class="c3">&nbsp; { &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;socks&quot; },</span></p><p class="c1 c7"><span class="c3">&nbsp; { &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c1 c7"><span class="c3">&nbsp; { &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;blender&quot; },</span></p><p class="c1 c7"><span class="c3">&nbsp; { &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;blender&quot; },</span></p><p class="c1 c7"><span class="c3">&nbsp; { &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;shirt&quot; }</span></p><p class="c1 c7"><span class="c3">&nbsp;]</span></p><p class="c0"><span></span></p><h1 class="c1"><a name="h.yugk1mszt0re"></a><span>And here you go</span></h1><h2 class="c1"><a name="h.39rm37noeh9g"></a><span>JSONiq types</span></h2><p class="c1"><span>JSONiq maps JSON types to XQuery. Numbers are xs:integer or xs:decimal, strings are xs:string, true and false are xs:boolean and null is a new atomic type jn:null.</span></p><p class="c0"><span></span></p><p class="c1"><span>JSONiq introduces new items: objects, arrays and pairs. Objects have pairs. Pairs have a string name and a value. Array have members which are values. Values are objects, arrays, XML nodes or atomic items.</span></p><p class="c0"><span></span></p><p class="c1"><span>The new item types for objects and arrays are object() and array(). json-item() is a supertype of both, and json-pair() is the item type for pairs.</span></p><h2 class="c1"><a name="h.j0wg8654ivtw"></a><span>JSON Constructors</span></h2><p class="c1"><span>JSONiq introduces JSON constructors, in a similar way to XML constructors.</span></p><p class="c0"><span></span></p><p class="c1"><span>You can put any expression in a array. The items in the sequence produced by the expression will become members of the array:</span></p><p class="c0"><span></span></p><p class="c1"><span class="c5">[ 1 to 10 ]</span></p><p class="c1 c8"><span class="c3">[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</span></p><p class="c0 c8"><span class="c3"></span></p><p class="c1"><span>Or you can dynamically compute an object:</span></p><p class="c0"><span></span></p><p class="c1"><span class="c5">{</span></p><p class="c1"><span class="c5">&nbsp; &quot;Greeting&quot; : (let $d := &quot;Mister Spock&quot;</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return concat(&quot;Hello, &quot;, $d)),</span></p><p class="c1"><span class="c5">&nbsp; &quot;Farewell&quot; : string-join((&quot;Live&quot;, &quot;long&quot;, &quot;and&quot;, &quot;prosper&quot;),</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot; &quot;)</span></p><p class="c1"><span class="c5">}</span></p><p class="c0"><span class="c3"></span></p><p class="c1 c8"><span class="c3">{ &quot;Greeting&quot; : &quot;Hello, Mister Spock&quot;, &quot;Farewell&quot; : &quot;Live long and prosper&quot; }</span></p><p class="c0"><span class="c18"></span></p><p class="c1"><span>You can also dynamically generate pairs:</span></p><p class="c0"><span class="c5"></span></p><p class="c1"><span class="c5">concat(&quot;Integer &quot;, 2) : 2 * 2</span></p><p class="c1 c8"><span class="c3">&quot;Integer 2&quot; : 4</span></p><p class="c0 c8"><span class="c3"></span></p><p class="c1"><span>and then wrap lots of them in an object:</span></p><p class="c0"><span class="c5"></span></p><p class="c1"><span class="c5">{</span></p><p class="c1"><span class="c5">&nbsp; for $i in 1 to 10</span></p><p class="c1"><span class="c5">&nbsp; return concat(&quot;Square of &quot;, $i) : $i * $i</span></p><p class="c1"><span class="c5">}</span></p><p class="c1 c7"><span class="c3">{</span></p><p class="c1 c7"><span class="c3">&quot;Square of 1&quot; : 1,</span></p><p class="c1 c7"><span class="c3">&quot;Square of 2&quot; : 4,</span></p><p class="c1 c7"><span class="c3">&quot;Square of 3&quot; : 9,</span></p><p class="c1 c7"><span class="c3">&quot;Square of 4&quot; : 16,</span></p><p class="c1 c7"><span class="c3">&quot;Square of 5&quot; : 25,</span></p><p class="c1 c7"><span class="c3">&quot;Square of 6&quot; : 36,</span></p><p class="c1 c7"><span class="c3">&quot;Square of 7&quot; : 49,</span></p><p class="c1 c7"><span class="c3">&quot;Square of 8&quot; : 64,</span></p><p class="c1 c7"><span class="c3">&quot;Square of 9&quot; : 81,</span></p><p class="c1 c7"><span class="c3">&quot;Square of 10&quot; : 100</span></p><p class="c1 c7"><span class="c3">}</span></p><p class="c0"><span></span></p><h2 class="c1"><a name="h.qe57mgdf5ql"></a><span>JSON as a subset of JSONiq</span></h2><p class="c1 c16"><span>Every well-formed JSON document is a JSONiq query as well. This means that you can copy-and-paste a JSON document into a query. The following are JSONiq queries that are &quot;idempotent&quot; (they just output themselves):</span></p><p class="c0"><span></span></p><p class="c1"><span class="c5">{ &quot;pi&quot; : 3.14, &quot;sq2&quot; : 1.4 }</span></p><p class="c1 c8"><span class="c3">{ &quot;pi&quot; : 3.14, &quot;sq2&quot; : 1.4 }</span></p><p class="c0"><span class="c3"></span></p><p class="c1"><span class="c5">[ 2, 3, 5, 7, 11, 13 ]</span></p><p class="c1 c8"><span class="c3">[ 2, 3, 5, 7, 11, 13 ]</span></p><p class="c0"><span class="c5"></span></p><p class="c1"><span class="c5">{</span></p><p class="c1"><span class="c5">&nbsp; &quot;operations&quot; : [</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; { &quot;binary&quot; : [ &quot;and&quot;, &quot;or&quot;] },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; { &quot;unary&quot; : [&quot;not&quot;] }</span></p><p class="c1"><span class="c5">&nbsp; ],</span></p><p class="c1"><span class="c5">&nbsp; &quot;bits&quot; : [</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; 0, 1</span></p><p class="c1"><span class="c5">&nbsp; ]</span></p><p class="c1"><span class="c5">}</span></p><p class="c1 c17"><span class="c3">{</span></p><p class="c1 c17"><span class="c3">&nbsp; &quot;operations&quot; : [</span></p><p class="c1 c17"><span class="c3">&nbsp; &nbsp; { &quot;binary&quot; : [ &quot;and&quot;, &quot;or&quot; ] },</span></p><p class="c1 c17"><span class="c3">&nbsp; &nbsp; { &quot;unary&quot; : [ &quot;not&quot; ] }</span></p><p class="c1 c17"><span class="c3">&nbsp; ],</span></p><p class="c1 c17"><span class="c3">&nbsp; &quot;bits&quot; : [</span></p><p class="c1 c17"><span class="c3">&nbsp; &nbsp; 0, 1</span></p><p class="c1 c17"><span class="c3">&nbsp; ]</span></p><p class="c1 c17"><span class="c3">}</span></p><p class="c0 c8"><span class="c3"></span></p><p class="c1 c16"><span>This works with objects, arrays (even nested), strings, numbers, booleans, null. </span><span class="c12">The exceptions to this rule (but we are working on it!) are that:</span></p><p class="c1 c16"><span class="c12">(i) if a pair has a true, false or null value, there must be a space on at least one side of the colon (this will be fixed).</span></p><p class="c1 c16"><span class="c12">(ii) empty objects are not recognized</span></p><p class="c1 c16"><span class="c12">(iii) characters escaped with the \ in JSON strings are not recognized</span></p><p class="c0"><span class="c5 c12"></span></p><p class="c1 c16"><span>It also works the other way round: if your query outputs an object or an array, you can readily use it as a JSON document.</span></p><p class="c0 c8"><span class="c3"></span></p><h1 class="c1"><a name="h.mjv7kyjurri2"></a><span>JSON Navigation</span></h1><p class="c1 c16"><span>I</span><span>f you have some JSON data, you can access it and navigate.</span></p><p class="c0 c16"><span></span></p><p class="c1 c16"><span>All you need to know is, again: JSONiq views</span></p><ol class="c19" start="1"><li class="c1 c6"><span>an array as a sequence of values,</span></li><li class="c6 c1"><span>an object as a set of pairs,</span></li><li class="c6 c1"><span>a pair as a (name, value) tuple.</span></li></ol><h2 class="c1 c16"><a name="h.xosiyb17dh24"></a><span>Objects</span></h2><p class="c1 c16"><span>If you use an object as a functor and provide it with a string, it will return the pair named after its parameter:</span></p><p class="c0"><span class="c5"></span></p><p class="c1"><span class="c5">let $person := {</span></p><p class="c1"><span class="c5">&nbsp; &quot;first name&quot; : &quot;Sarah&quot;,</span></p><p class="c1"><span class="c5">&nbsp; &quot;age&quot; : 13,</span></p><p class="c1"><span class="c5">&nbsp; &quot;gender&quot; : &quot;female&quot;,</span></p><p class="c1"><span class="c5">&nbsp; &quot;friends&quot; : [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot;]</span></p><p class="c1"><span class="c5">}</span></p><p class="c1"><span class="c5">return $person(&quot;first name&quot;)</span></p><p class="c1 c8"><span class="c3">&quot;first name&quot; : &quot;Sarah&quot;</span></p><p class="c0 c8"><span class="c3"></span></p><h2 class="c1"><a name="h.mrf42gizl3y6"></a><span>Arrays</span></h2><p class="c1 c16"><span>If you use an array as a functor and provide it with an integer, it will return the corresponding entry:</span></p><p class="c0"><span class="c5"></span></p><p class="c1"><span class="c5">let $friends := [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot;]</span></p><p class="c1"><span class="c5">return $friends(2)</span></p><p class="c1 c8"><span class="c3">Mary</span></p><h2 class="c1"><a name="h.hdc3dgohtdut"></a><span>Pairs</span></h2><p class="c1"><span>Given a pair, you can get its name and value using the functions jn:name and jn:value:</span></p><p class="c0"><span></span></p><p class="c1"><span class="c5">let $pair := &quot;name of the pair&quot; : &quot;value of the pair&quot;</span></p><p class="c1"><span class="c5">return { &nbsp;&quot;name&quot; : jn:name($pair), &quot;value&quot; : jn:value($pair) }</span></p><p class="c0"><span class="c5"></span></p><p class="c1 c8"><span class="c3">{ &quot;name&quot; : &quot;name of the pair&quot;, &quot;value&quot; : &quot;value of the pair&quot; }</span></p><p class="c0"><span class="c18"></span></p><p class="c1"><span>This functions also exist in plural form for objects:</span></p><p class="c0"><span></span></p><p class="c1"><span class="c5">let $person := {</span></p><p class="c1"><span class="c5">&nbsp; &quot;name&quot; : &quot;Sarah&quot;,</span></p><p class="c1"><span class="c5">&nbsp; &quot;age&quot; : 13,</span></p><p class="c1"><span class="c5">&nbsp; &quot;gender&quot; : &quot;female&quot;,</span></p><p class="c1"><span class="c5">&nbsp; &quot;friends&quot; : [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot;]</span></p><p class="c1"><span class="c5">}</span></p><p class="c1"><span class="c5">return { &quot;names&quot; : [ jn:names($person)],</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;values&quot; : [ jn:values($person)]</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c1 c9"><span class="c3">{</span></p><p class="c1 c9"><span class="c3">&quot;names&quot; : [ &quot;name&quot;, &quot;age&quot;, &quot;gender&quot;, &quot;friends&quot; ],</span></p><p class="c1 c9"><span class="c3">&quot;values&quot; : [ &quot;Sarah&quot;, 13, &quot;female&quot;, [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot; ] ]</span></p><p class="c1 c9"><span class="c3">}</span></p><p class="c1"><span>jn:values can also be used for an array:</span></p><p class="c0"><span></span></p><p class="c1"><span class="c5">let $person := {</span></p><p class="c1"><span class="c5">&nbsp; &quot;name&quot; : &quot;Sarah&quot;,</span></p><p class="c1"><span class="c5">&nbsp; &quot;age&quot; : 13,</span></p><p class="c1"><span class="c5">&nbsp; &quot;gender&quot; : &quot;female&quot;,</span></p><p class="c1"><span class="c5">&nbsp; &quot;friends&quot; : [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot;]</span></p><p class="c1"><span class="c5">}</span></p><p class="c1"><span class="c5">return jn:values($person(&quot;friends&quot;))</span></p><p class="c1 c8"><span class="c18">[ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot; ]</span></p><p class="c0 c8"><span class="c18"></span></p><h1 class="c1"><a name="h.eb0bxle2oykl"></a><span>Relational Algebra</span></h1><p class="c1 c16"><span>Remember last century&#39;s SELECT FROM WHERE statements? Well, JSONiq didn&#39;t throw out the baby with the bathwater. It has selection, projection and join capability.</span></p><p class="c0"><span></span></p><p class="c1"><span class="c5">let $stores :=</span></p><p class="c1"><span class="c5">[</span></p><p class="c1"><span class="c5">&nbsp; { &quot;store number&quot; : 1, &quot;state&quot; : &quot;MA&quot; },</span></p><p class="c1"><span class="c5">&nbsp; { &quot;store number&quot; : 2, &quot;state&quot; : &quot;MA&quot; },</span></p><p class="c1"><span class="c5">&nbsp; { &quot;store number&quot; : 3, &quot;state&quot; : &quot;CA&quot; },</span></p><p class="c1"><span class="c5">&nbsp; { &quot;store number&quot; : 4, &quot;state&quot; : &quot;CA&quot; }</span></p><p class="c1"><span class="c5">]</span></p><p class="c1"><span class="c5">let $sales := [</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;broiler&quot;, &quot;store number&quot; : 1, &quot;quantity&quot; : 20 &nbsp;},</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 100 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 50 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 50 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;blender&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 100 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;blender&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 150 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;socks&quot;, &quot;store number&quot; : 1, &quot;quantity&quot; : 500 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;socks&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 10 },</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;{ &quot;product&quot; : &quot;shirt&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 10 }</span></p><p class="c1"><span class="c5">]</span></p><p class="c1"><span class="c5">let $join :=</span></p><p class="c1"><span class="c5">&nbsp; for $store in jn:values($stores), $sale in jn:values($sales)</span></p><p class="c1"><span class="c5">&nbsp; where $store(&quot;store number&quot;) = $sale(&quot;store number&quot;)</span></p><p class="c1"><span class="c5">&nbsp; return {</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &quot;nb&quot; : $store(&quot;store number&quot;),</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &quot;state&quot; : $store(&quot;state&quot;),</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &quot;sold&quot; : $sale(&quot;product&quot;)</span></p><p class="c1"><span class="c5">&nbsp; }</span></p><p class="c1"><span class="c5">return [$join]</span></p><p class="c1 c13"><span class="c3">[ </span></p><p class="c1 c13"><span class="c3">{ &quot;nb&quot; : 1, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;broiler&quot; },</span></p><p class="c1 c13"><span class="c3">{ &quot;nb&quot; : 1, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;socks&quot; },</span></p><p class="c1 c13"><span class="c3">{ &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c1 c13"><span class="c3">{ &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c1 c13"><span class="c3">{ &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;socks&quot; },</span></p><p class="c1 c13"><span class="c3">{ &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c1 c13"><span class="c3">{ &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;blender&quot; },</span></p><p class="c1 c13"><span class="c3">{ &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;blender&quot; },</span></p><p class="c1 c13"><span class="c3">{ &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;shirt&quot; }</span></p><p class="c1 c13"><span class="c3">&nbsp;]</span></p><h1 class="c1"><a name="h.oii6pvliilhi"></a><span>Access external data</span></h1><p class="c1"><span>Our implementation supports collections of JSON objects or arrays:</span></p><p class="c0"><span></span></p><p class="c1"><span class="c5">dml:collection(&quot;my:data&quot;)</span></p><p class="c1 c8"><span class="c3">{ &quot;foo&quot; : &quot;Your&quot; }</span></p><p class="c1 c8"><span class="c3">{ &quot;foo&quot; : &quot;Collection&quot; }</span></p><p class="c1 c8"><span class="c3">{ &quot;foo&quot; : &quot;of&quot; }</span></p><p class="c1 c8"><span class="c3">{ &quot;foo&quot; : &quot;JSON&quot; }</span></p><p class="c1 c8"><span class="c3">{ &quot;foo&quot; : &quot;objects&quot; }</span></p><p class="c0 c8"><span class="c3"></span></p><p class="c1"><span>It is also possible to get JSON content with an HTTP request, or by parsing it from a string. Functions that handle this are available.</span></p><p class="c0"><span class="c3"></span></p><h1 class="c1"><a name="h.fopcxnkoydgt"></a><span>JSON and XML</span></h1><p class="c1 c16"><span>You can readily use XML and JSON in the same program. If you put a JSON array in an XML constructor, it will be flattened (its member values are recursively taken, even in arrays of arrays). If you put a JSON pair in an XML constructor, it will be unboxed (its value is taken).</span></p><p class="c0"><span></span></p><p class="c1"><span class="c5">let $data := {</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;&quot;color&quot; : &quot;blue&quot;,</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;&quot;closed&quot; : true,</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;&quot;points&quot; : [[10,10], [20,10], [20,20], [10,20]]</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;}</span></p><p class="c0"><span class="c5"></span></p><p class="c1"><span class="c5">let $stroke := attribute stroke { $data(&quot;color&quot;) }</span></p><p class="c1"><span class="c5">let $points := attribute points { $data(&quot;points&quot;) }</span></p><p class="c1"><span class="c5">return</span></p><p class="c1"><span class="c5">&nbsp; if ($data(&quot;closed&quot;)) then</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &lt;svg&gt;&lt;polygon&gt;{ $stroke, $points }&lt;/polygon&gt;&lt;/svg&gt;</span></p><p class="c1"><span class="c5">&nbsp; else</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &lt;svg&gt;&lt;polyline&gt;{ $stroke, $points }&lt;/polyline&gt;&lt;/svg&gt;</span></p><p class="c0"><span class="c5"></span></p><p class="c1 c15"><span class="c3">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></p><p class="c1 c15"><span class="c3">&lt;svg&gt;&lt;polygon stroke=&quot;blue&quot; points=&quot;10 10 20 10 20 20 10 20&quot;/&gt;&lt;/svg&gt;</span></p><p class="c0"><span></span></p><h1 class="c1"><a name="h.bm3buqmzhtko"></a><span>I want more</span></h1><p class="c1 c16"><span>JSONiq supports JSON updates. You can declaratively update your JSON data. JSONiq provides functions that produce a list of updates. The list of updates that is eventually output by your program is then applied to your JSON data.</span></p><p class="c0"><span></span></p><p class="c1"><span class="c5">let $my-data := jn:json(&quot;persons.json&quot;)</span></p><p class="c1"><span class="c5">let $john := jn:value($my-data(&quot;John&quot;))</span></p><p class="c1"><span class="c5">let $mary := jn:value($my-data(&quot;Mary&quot;))</span></p><p class="c1"><span class="c5">return (jn:replace-value($john, &quot;status&quot;, &quot;married&quot;),</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; j:replace-value($mary, &quot;status&quot;, &quot;married&quot;))</span></p><p class="c0"><span></span></p><p class="c1"><span>JSONiq works with the XQuery 3.0 standard (switch, typeswitch and try-catch expressions, universal/existential quantifiers, path expressions, filtering expressions, functors, mappings, grouping, windowing will work). The Zorba implementation is also compatible with the proprietary Zorba scripting.</span></p></body></html>