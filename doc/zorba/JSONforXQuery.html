<html><head><title>JSON for XQuery</title><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=lhDjYqiy3mZ0x6ROQEUoUw');ol{margin:0;padding:0}.c22{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c7{padding-left:0pt;text-align:justify;margin-left:36pt}.c17{list-style-type:disc;margin:0;padding:0}.c23{text-indent:-13pt;margin-left:77pt}.c5{color:#1155cc;text-decoration:underline}.c13{color:inherit;text-decoration:inherit}.c18{font-weight:bold}.c6{margin-left:18pt}.c15{text-indent:139.5pt}.c8{color:#38761d}.c16{color:#4a86e8}.c14{font-style:italic}.c2{text-align:right}.c9{text-align:justify}.c4{margin-left:144pt}.c19{margin-left:36pt}.c11{text-indent:156pt}.c3{height:11pt}.c0{font-family:"Consolas"}.c1{direction:ltr}.c20{text-align:center}.c12{margin-left:49.5pt}.c21{height:18pt}.c10{text-indent:144pt}.title{padding-top:24pt;line-height:1.15;text-align:center;color:#4a86e8;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#4a86e8;font-size:24pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#ff9900;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#000000;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#000000;font-size:11pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}</style></head><body class="c22"><p class="c1 title"><a name="h.li2wdq8unbq"></a><span>JSONiq for XQuery users</span></p><p class="c1 title"><a name="h.5ipqqclfxk4n"></a><span class="c8">JSON for XQuery</span></p><hr><p class="c1 c20"><span>This tutorial introduces the JSONiq language, which declaratively manipulates JSON data.</span></p><p class="c1 c20"><span>Why don&#39;t you go ahead can try the queries of this document on our online demo interface?</span></p><p class="c1 c20"><span>&nbsp;</span><span class="c5 c18"><a class="c13" href="http://jsoniq.zorba-xquery.com/">http://jsoniq.zorba-xquery.com/</a></span></p><hr><p class="c3 c1"><span></span></p><h2 class="c1 c21"><a name="h.8gra0ylxutrv"></a></h2><p class="c6 c1"><span class="c5"><a class="c13" href="#h.f453h84m2u1a">JSON</a></span></p><p class="c6 c1"><span class="c5"><a class="c13" href="#h.qtfakecy3fr7">Elevator Pitch</a></span></p><p class="c6 c1"><span class="c5"><a class="c13" href="#h.yugk1mszt0re">And here you go</a></span></p><p class="c19 c1"><span class="c5"><a class="c13" href="#h.39rm37noeh9g">JSONiq types</a></span></p><p class="c1 c19"><span class="c5"><a class="c13" href="#h.j0wg8654ivtw">JSON Constructors</a></span></p><p class="c19 c1"><span class="c5"><a class="c13" href="#h.qe57mgdf5ql">JSON as a subset of JSONiq</a></span></p><p class="c1 c6"><span class="c5"><a class="c13" href="#h.dewn8sw3husv">JSON Navigation</a></span></p><p class="c19 c1"><span class="c5"><a class="c13" href="#h.zcnazhl6374z">Objects</a></span></p><p class="c19 c1"><span class="c5"><a class="c13" href="#h.30wafxvenhgy">Arrays</a></span></p><p class="c6 c1"><span class="c5"><a class="c13" href="#h.eb0bxle2oykl">Relational Algebra</a></span></p><p class="c6 c1"><span class="c5"><a class="c13" href="#h.oii6pvliilhi">Access external data</a></span></p><p class="c6 c1"><span class="c5"><a class="c13" href="#h.fopcxnkoydgt">JSON and XML</a></span></p><p class="c6 c1"><span class="c5"><a class="c13" href="#h.bm3buqmzhtko">I want more</a></span></p><p class="c3 c1"><span></span></p><h1 class="c1"><a name="h.f453h84m2u1a"></a><span>JSON</span></h1><p class="c9 c1"><span>As explained on </span><span class="c5"><a class="c13" href="http://www.json.org/">http://www.json.org/</a></span><span>, JSON is a lightweight data-interchange format designed for humans as well as for computers. It supports as values:</span></p><ol class="c17" start="1"><li class="c7 c1"><span>objects (string-to-value map)</span></li><li class="c7 c1"><span>arrays (ordered sequence of values)</span></li><li class="c7 c1"><span>strings</span></li><li class="c7 c1"><span>numbers</span></li><li class="c7 c1"><span>booleans (true, false)</span></li><li class="c7 c1"><span>null</span></li></ol><p class="c3 c1"><span></span></p><p class="c1"><span>JSONiq extends XQuery to query and update JSON data, like XML data.</span></p><h1 class="c1"><a name="h.qtfakecy3fr7"></a><span>Elevator Pitch</span></h1><p class="c9 c1"><span>Here is an appetizer before we start the tutorial from scratch.</span></p><p class="c3 c1"><span></span></p><p class="c1"><span class="c0">let $stores :=</span></p><p class="c1"><span class="c0">[</span></p><p class="c1"><span class="c0">&nbsp; { &quot;store number&quot; : 1, &quot;state&quot; : &quot;MA&quot; },</span></p><p class="c1"><span class="c0">&nbsp; { &quot;store number&quot; : 2, &quot;state&quot; : &quot;MA&quot; },</span></p><p class="c1"><span class="c0">&nbsp; { &quot;store number&quot; : 3, &quot;state&quot; : &quot;CA&quot; },</span></p><p class="c1"><span class="c0">&nbsp; { &quot;store number&quot; : 4, &quot;state&quot; : &quot;CA&quot; }</span></p><p class="c1"><span class="c0">]</span></p><p class="c1"><span class="c0">let $sales := [</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;broiler&quot;, &quot;store number&quot; : 1, &quot;quantity&quot; : 20 &nbsp;},</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 100 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 50 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 50 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;blender&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 100 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;blender&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 150 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;socks&quot;, &quot;store number&quot; : 1, &quot;quantity&quot; : 500 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;socks&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 10 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;shirt&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 10 }</span></p><p class="c1"><span class="c0">]</span></p><p class="c1"><span class="c0">let $join :=</span></p><p class="c1"><span class="c0">&nbsp; for $store in jn:members($stores), $sale in jn:members($sales)</span></p><p class="c1"><span class="c0">&nbsp; where $store(&quot;store number&quot;) = $sale(&quot;store number&quot;)</span></p><p class="c1"><span class="c0">&nbsp; return {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &quot;nb&quot; : $store(&quot;store number&quot;),</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &quot;state&quot; : $store(&quot;state&quot;),</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &quot;sold&quot; : $sale(&quot;product&quot;)</span></p><p class="c1"><span class="c0">&nbsp; }</span></p><p class="c1"><span class="c0">return [$join]</span></p><p class="c4 c1"><span class="c8 c0">[ </span></p><p class="c4 c1"><span class="c8 c0">&nbsp; { &quot;nb&quot; : 1, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;broiler&quot; },</span></p><p class="c4 c1"><span class="c8 c0">&nbsp; { &quot;nb&quot; : 1, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;socks&quot; },</span></p><p class="c4 c1"><span class="c8 c0">&nbsp; { &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c4 c1"><span class="c0 c8">&nbsp; { &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c4 c1"><span class="c8 c0">&nbsp; { &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;socks&quot; },</span></p><p class="c4 c1"><span class="c8 c0">&nbsp; { &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c4 c1"><span class="c8 c0">&nbsp; { &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;blender&quot; },</span></p><p class="c4 c1"><span class="c8 c0">&nbsp; { &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;blender&quot; },</span></p><p class="c4 c1"><span class="c8 c0">&nbsp; { &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;shirt&quot; }</span></p><p class="c4 c1"><span class="c8 c0">&nbsp;]</span></p><p class="c3 c1"><span></span></p><h1 class="c1"><a name="h.yugk1mszt0re"></a><span>And here you go</span></h1><h2 class="c1"><a name="h.39rm37noeh9g"></a><span>JSONiq types</span></h2><p class="c1"><span>JSONiq maps JSON types to XQuery. Numbers are xs:integer or xs:decimal, strings are xs:string, true and false are xs:boolean and null is a new atomic type jn:null.</span></p><p class="c3 c1"><span></span></p><p class="c1"><span>By default, in JSONiq, for convenience, true, false and null are recognized as literals instead of name tests. However, this can be deactivated.</span></p><p class="c3 c1"><span></span></p><p class="c1"><span>JSONiq introduces new items: objects and arrays. Objects are sets of key/value pairs. Array have members which are values. Values are objects, arrays, XML nodes, functions or atomic items.</span></p><p class="c3 c1"><span></span></p><p class="c1"><span>The new item types for objects and arrays are object() and array(). json-item() is a supertype of both. structured-item() is a supertype for json-item() and node().</span></p><h2 class="c1"><a name="h.j0wg8654ivtw"></a><span>JSON Constructors</span></h2><p class="c1"><span>JSONiq introduces JSON constructors, in a similar way to XML constructors.</span></p><p class="c3 c1"><span></span></p><p class="c1"><span>You can put any expression in a array. The items in the sequence produced by the expression will become members of the array:</span></p><p class="c3 c1"><span></span></p><p class="c1"><span class="c0">[ 1 to 10 ]</span></p><p class="c2 c1"><span class="c8 c0">[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</span></p><p class="c2 c3 c1"><span class="c8 c0"></span></p><p class="c1"><span>Or you can dynamically compute an object:</span></p><p class="c3 c1"><span></span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">&nbsp; &quot;Greeting&quot; : (let $d := &quot;Mister Spock&quot;</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return concat(&quot;Hello, &quot;, $d)),</span></p><p class="c1"><span class="c0">&nbsp; &quot;Farewell&quot; : string-join((&quot;Live&quot;, &quot;long&quot;, &quot;and&quot;, &quot;prosper&quot;),</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot; &quot;)</span></p><p class="c1"><span class="c0">}</span></p><p class="c3 c1"><span class="c8 c0"></span></p><p class="c2 c1"><span class="c8 c0">{ &quot;Greeting&quot; : &quot;Hello, Mister Spock&quot;, &quot;Farewell&quot; : &quot;Live long and prosper&quot; }</span></p><p class="c3 c1"><span class="c8"></span></p><p class="c1"><span>You can also dynamically generate singleton objects:</span></p><p class="c3 c1"><span class="c0"></span></p><p class="c1"><span class="c0">{ concat(&quot;Integer &quot;, 2) : 2 * 2 }</span></p><p class="c2 c1"><span class="c8 c0">{ &quot;Integer 2&quot; : 4 }</span></p><p class="c2 c3 c1"><span class="c8 c0"></span></p><p class="c1"><span>and then wrap lots of them in an object:</span></p><p class="c3 c1"><span class="c0"></span></p><p class="c1"><span class="c0">{|</span></p><p class="c1"><span class="c0">&nbsp; for $i in 1 to 10</span></p><p class="c1"><span class="c0">&nbsp; return { concat(&quot;Square of &quot;, $i) : $i * $i }</span></p><p class="c1"><span class="c0">|}</span></p><p class="c4 c1"><span class="c8 c0">{</span></p><p class="c4 c1"><span class="c8 c0">&quot;Square of 1&quot; : 1,</span></p><p class="c1 c4"><span class="c8 c0">&quot;Square of 2&quot; : 4,</span></p><p class="c4 c1"><span class="c8 c0">&quot;Square of 3&quot; : 9,</span></p><p class="c4 c1"><span class="c8 c0">&quot;Square of 4&quot; : 16,</span></p><p class="c4 c1"><span class="c8 c0">&quot;Square of 5&quot; : 25,</span></p><p class="c4 c1"><span class="c8 c0">&quot;Square of 6&quot; : 36,</span></p><p class="c4 c1"><span class="c8 c0">&quot;Square of 7&quot; : 49,</span></p><p class="c4 c1"><span class="c8 c0">&quot;Square of 8&quot; : 64,</span></p><p class="c4 c1"><span class="c8 c0">&quot;Square of 9&quot; : 81,</span></p><p class="c4 c1"><span class="c8 c0">&quot;Square of 10&quot; : 100</span></p><p class="c4 c1"><span class="c8 c0">}</span></p><p class="c3 c1"><span></span></p><h2 class="c1"><a name="h.qe57mgdf5ql"></a><span>JSON as a subset of JSONiq</span></h2><p class="c9 c1"><span>As a rule of thumb, a well-formed JSON document is a JSONiq query as well. This means that you can copy-and-paste a JSON document into a query. The following are JSONiq queries that are &quot;idempotent&quot; (they just output themselves):</span></p><p class="c3 c1"><span></span></p><p class="c1"><span class="c0">{ &quot;pi&quot; : 3.14, &quot;sq2&quot; : 1.4 }</span></p><p class="c2 c1"><span class="c8 c0">{ &quot;pi&quot; : 3.14, &quot;sq2&quot; : 1.4 }</span></p><p class="c3 c1"><span class="c8 c0"></span></p><p class="c1"><span class="c0">[ 2, 3, 5, 7, 11, 13 ]</span></p><p class="c2 c1"><span class="c8 c0">[ 2, 3, 5, 7, 11, 13 ]</span></p><p class="c1 c3"><span class="c0"></span></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">&nbsp; &quot;operations&quot; : [</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; { &quot;binary&quot; : [ &quot;and&quot;, &quot;or&quot;] },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; { &quot;unary&quot; : [&quot;not&quot;] }</span></p><p class="c1"><span class="c0">&nbsp; ],</span></p><p class="c1"><span class="c0">&nbsp; &quot;bits&quot; : [</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; 0, 1</span></p><p class="c1"><span class="c0">&nbsp; ]</span></p><p class="c1"><span class="c0">}</span></p><p class="c1 c10"><span class="c8 c0">{</span></p><p class="c1 c10"><span class="c8 c0">&nbsp; &quot;operations&quot; : [</span></p><p class="c1 c10"><span class="c8 c0">&nbsp; &nbsp; { &quot;binary&quot; : [ &quot;and&quot;, &quot;or&quot; ] },</span></p><p class="c1 c10"><span class="c8 c0">&nbsp; &nbsp; { &quot;unary&quot; : [ &quot;not&quot; ] }</span></p><p class="c1 c10"><span class="c8 c0">&nbsp; ],</span></p><p class="c1 c10"><span class="c8 c0">&nbsp; &quot;bits&quot; : [</span></p><p class="c1 c10"><span class="c8 c0">&nbsp; &nbsp; 0, 1</span></p><p class="c1 c10"><span class="c8 c0">&nbsp; ]</span></p><p class="c1 c10"><span class="c8 c0">}</span></p><p class="c2 c3 c1"><span class="c8 c0"></span></p><p class="c9 c1"><span>This works with objects, arrays (even nested), strings, numbers, booleans, null. </span><span class="c14">The exceptions to this rule (but we are working on it!) are that:</span></p><p class="c9 c1"><span class="c14">(i) if a pair has a true, false or null value, there must be a space on at least one side of the colon (this will be fixed soon).</span></p><p class="c9 c1"><span class="c14">(ii) empty objects are not recognized</span></p><p class="c9 c1"><span class="c14">(iii) characters escaped with the \ in JSON strings are not recognized</span></p><p class="c3 c1"><span class="c14 c0"></span></p><p class="c9 c1"><span>It also works the other way round: if your query outputs an object or an array, you can directly use it as a JSON document.</span></p><p class="c2 c3 c1"><span class="c8 c0"></span></p><h1 class="c1"><a name="h.dewn8sw3husv"></a><span>JSON Navigation</span></h1><p class="c9 c1"><span>Up to now, you learnt how to compose expressions so as to do some computations and to build objects and arrays. It also works the other way round: if you have some JSON data, you can access it and navigate.</span></p><p class="c11 c3 c1"><span></span></p><p class="c9 c1"><span>All you need to know is: JSONiq views</span></p><ol class="c17" start="1"><li class="c1 c7"><span>an array as a sequence of values,</span></li><li class="c7 c1"><span>an object as a set of name/value pairs</span></li></ol><h2 class="c1 c9"><a name="h.zcnazhl6374z"></a><span>Objects</span></h2><p class="c9 c1"><span>If you use an object as a functor and provide it with a string, it will return the value associated with its parameter:</span></p><p class="c11 c3 c1"><span></span></p><p class="c1"><span class="c0">let $person := {</span></p><p class="c1"><span class="c0">&nbsp;&quot;first name&quot; : &quot;Sarah&quot;,</span></p><p class="c1"><span class="c0">&nbsp;&quot;age&quot; : 13,</span></p><p class="c1"><span class="c0">&nbsp;&quot;gender&quot; : &quot;female&quot;,</span></p><p class="c1"><span class="c0">&nbsp;&quot;friends&quot; : [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot;]</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">return $person(&quot;first name&quot;)</span></p><p class="c2 c11 c1"><span class="c8 c0">&quot;Sarah&quot;</span></p><p class="c11 c3 c1"><span class="c8 c0"></span></p><p class="c1"><span>You can also ask for all keys in an object:</span></p><p class="c3 c1"><span></span></p><p class="c1"><span class="c0">let $person := {</span></p><p class="c1"><span class="c0">&nbsp;&quot;name&quot; : &quot;Sarah&quot;,</span></p><p class="c1"><span class="c0">&nbsp;&quot;age&quot; : 13,</span></p><p class="c1"><span class="c0">&nbsp;&quot;gender&quot; : &quot;female&quot;,</span></p><p class="c1"><span class="c0">&nbsp;&quot;friends&quot; : [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot;]</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">return { &quot;keys&quot; : [ jn:keys($person)] }</span></p><p class="c11 c3 c1"><span class="c0"></span></p><p class="c2 c1 c23"><span class="c8 c0">{ &quot;keys&quot; : [ &quot;name&quot;, &quot;age&quot;, &quot;gender&quot;, &quot;friends&quot; ] }</span></p><h2 class="c1"><a name="h.30wafxvenhgy"></a><span>Arrays</span></h2><p class="c9 c1"><span>If you use an array as a functor and provide it with an integer, it will return the corresponding entry:</span></p><p class="c11 c3 c1"><span></span></p><p class="c1"><span class="c0">let $friends := [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot;]</span></p><p class="c1"><span class="c0">return $friends(2)</span></p><p class="c2 c11 c1"><span class="c8 c0">Mary</span></p><p class="c3 c1"><span class="c8 c0"></span></p><p class="c1"><span>It is also possible to get the size of an array:</span></p><p class="c11 c3 c1"><span></span></p><p class="c1"><span class="c0">let $person := {</span></p><p class="c1"><span class="c0">&nbsp;&quot;name&quot; : &quot;Sarah&quot;,</span></p><p class="c1"><span class="c0">&nbsp;&quot;age&quot; : 13,</span></p><p class="c1"><span class="c0">&nbsp;&quot;gender&quot; : &quot;female&quot;,</span></p><p class="c1"><span class="c0">&nbsp;&quot;friends&quot; : [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot;]</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">return { &quot;how many friends&quot; : jn:size($person(&quot;friends&quot;)) }</span></p><p class="c11 c3 c1"><span class="c0"></span></p><p class="c2 c11 c1"><span class="c8 c0">{ &quot;how many friends&quot; : 3 }</span></p><p class="c11 c3 c1"><span class="c8 c0"></span></p><p class="c1"><span>For convenience, there is a function that returns all elements in an array, as a sequence:</span></p><p class="c11 c3 c1"><span></span></p><p class="c1"><span class="c0">let $person := {</span></p><p class="c1"><span class="c0">&nbsp;&quot;name&quot; : &quot;Sarah&quot;,</span></p><p class="c1"><span class="c0">&nbsp;&quot;age&quot; : 13,</span></p><p class="c1"><span class="c0">&nbsp;&quot;gender&quot; : &quot;female&quot;,</span></p><p class="c1"><span class="c0">&nbsp;&quot;friends&quot; : [ &quot;Jim&quot;, &quot;Mary&quot;, &quot;Jennifer&quot;]</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">return jn:members($person(&quot;friends&quot;))</span></p><p class="c3 c1"><span class="c0"></span></p><p class="c2 c1 c11"><span class="c8 c0">Jim Mary Jennifer</span></p><h1 class="c1"><a name="h.eb0bxle2oykl"></a><span>Relational Algebra</span></h1><p class="c9 c1"><span>Remember last century&#39;s SELECT FROM WHERE statements? Well, JSONiq didn&#39;t throw out the baby with the bathwater. It has selection, projection and join capability.</span></p><p class="c3 c1"><span></span></p><p class="c1"><span class="c0">let $stores :=</span></p><p class="c1"><span class="c0">[</span></p><p class="c1"><span class="c0">&nbsp; { &quot;store number&quot; : 1, &quot;state&quot; : &quot;MA&quot; },</span></p><p class="c1"><span class="c0">&nbsp; { &quot;store number&quot; : 2, &quot;state&quot; : &quot;MA&quot; },</span></p><p class="c1"><span class="c0">&nbsp; { &quot;store number&quot; : 3, &quot;state&quot; : &quot;CA&quot; },</span></p><p class="c1"><span class="c0">&nbsp; { &quot;store number&quot; : 4, &quot;state&quot; : &quot;CA&quot; }</span></p><p class="c1"><span class="c0">]</span></p><p class="c1"><span class="c0">let $sales := [</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;broiler&quot;, &quot;store number&quot; : 1, &quot;quantity&quot; : 20 &nbsp;},</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 100 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 50 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;toaster&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 50 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;blender&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 100 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;blender&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 150 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;socks&quot;, &quot;store number&quot; : 1, &quot;quantity&quot; : 500 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;socks&quot;, &quot;store number&quot; : 2, &quot;quantity&quot; : 10 },</span></p><p class="c1"><span class="c0">&nbsp; &nbsp;{ &quot;product&quot; : &quot;shirt&quot;, &quot;store number&quot; : 3, &quot;quantity&quot; : 10 }</span></p><p class="c1"><span class="c0">]</span></p><p class="c1"><span class="c0">let $join :=</span></p><p class="c1"><span class="c0">&nbsp; for $store in jn:members($stores), $sale in jn:members($sales)</span></p><p class="c1"><span class="c0">&nbsp; where $store(&quot;store number&quot;) = $sale(&quot;store number&quot;)</span></p><p class="c1"><span class="c0">&nbsp; return {</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &quot;nb&quot; : $store(&quot;store number&quot;),</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &quot;state&quot; : $store(&quot;state&quot;),</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &quot;sold&quot; : $sale(&quot;product&quot;)</span></p><p class="c1"><span class="c0">&nbsp; }</span></p><p class="c1"><span class="c0">return [$join]</span></p><p class="c15 c1"><span class="c8 c0">[ </span></p><p class="c15 c1"><span class="c8 c0">{ &quot;nb&quot; : 1, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;broiler&quot; },</span></p><p class="c15 c1"><span class="c8 c0">{ &quot;nb&quot; : 1, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;socks&quot; },</span></p><p class="c15 c1"><span class="c8 c0">{ &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c15 c1"><span class="c8 c0">{ &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c15 c1"><span class="c8 c0">{ &quot;nb&quot; : 2, &quot;state&quot; : &quot;MA&quot;, &quot;sold&quot; : &quot;socks&quot; },</span></p><p class="c15 c1"><span class="c8 c0">{ &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;toaster&quot; },</span></p><p class="c1 c15"><span class="c8 c0">{ &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;blender&quot; },</span></p><p class="c15 c1"><span class="c8 c0">{ &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;blender&quot; },</span></p><p class="c15 c1"><span class="c8 c0">{ &quot;nb&quot; : 3, &quot;state&quot; : &quot;CA&quot;, &quot;sold&quot; : &quot;shirt&quot; }</span></p><p class="c15 c1"><span class="c8 c0">&nbsp;]</span></p><h1 class="c1"><a name="h.oii6pvliilhi"></a><span>Access external data</span></h1><p class="c1"><span>Our implementation supports collections of JSON objects or arrays:</span></p><p class="c3 c1"><span></span></p><p class="c1"><span class="c0">dml:collection(&quot;my:data&quot;)</span></p><p class="c2 c1"><span class="c8 c0">{ &quot;foo&quot; : &quot;Your&quot; }</span></p><p class="c2 c1"><span class="c8 c0">{ &quot;foo&quot; : &quot;Collection&quot; }</span></p><p class="c2 c1"><span class="c8 c0">{ &quot;foo&quot; : &quot;of&quot; }</span></p><p class="c2 c1"><span class="c8 c0">{ &quot;foo&quot; : &quot;JSON&quot; }</span></p><p class="c2 c1"><span class="c8 c0">{ &quot;foo&quot; : &quot;objects&quot; }</span></p><p class="c2 c3 c1"><span class="c8 c0"></span></p><p class="c1"><span>It is also possible to get JSON content with an HTTP request, or by parsing it from a string. Functions that handle this are available.</span></p><p class="c3 c1"><span class="c8 c0"></span></p><h1 class="c1"><a name="h.fopcxnkoydgt"></a><span>JSON and XML</span></h1><p class="c9 c1"><span>You can readily use XML and JSON in the same program. If you put a JSON array in an XML constructor, it will be flattened (its member values are recursively taken, even in arrays of arrays). If you put a JSON pair in an XML constructor, it will be unboxed (its value is taken).</span></p><p class="c3 c1"><span></span></p><p class="c1"><span class="c0">let $data := {</span></p><p class="c1"><span class="c0">&nbsp; &quot;color&quot; : &quot;blue&quot;,</span></p><p class="c1"><span class="c0">&nbsp; &quot;closed&quot; : true,</span></p><p class="c1"><span class="c0">&nbsp; &quot;points&quot; : [[10,10], [20,10], [20,20], [10,20]]</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">let $stroke := attribute stroke { $data(&quot;color&quot;) }</span></p><p class="c1"><span class="c0">let $points := attribute points { jn:flatten($data(&quot;points&quot;)) }</span></p><p class="c1"><span class="c0">return</span></p><p class="c1"><span class="c0">&nbsp; if ($data(&quot;closed&quot;)) then</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &lt;svg&gt;&lt;polygon&gt;{ $stroke, $points }&lt;/polygon&gt;&lt;/svg&gt;</span></p><p class="c1"><span class="c0">&nbsp; else</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &lt;svg&gt;&lt;polyline&gt;{ $stroke, $points }&lt;/polyline&gt;&lt;/svg&gt;</span></p><p class="c3 c1"><span class="c0"></span></p><p class="c2 c1 c12"><span class="c8 c0">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></p><p class="c2 c1 c12"><span class="c8 c0">&lt;svg&gt;&lt;polygon stroke=&quot;blue&quot; points=&quot;10 10 20 10 20 20 10 20&quot;/&gt;&lt;/svg&gt;</span></p><p class="c3 c1"><span></span></p><h1 class="c1"><a name="h.bm3buqmzhtko"></a><span>I want more</span></h1><p class="c9 c1"><span>JSONiq supports JSON updates. You can declaratively update your JSON data. JSONiq provides functions that produce a list of updates. The list of updates that is eventually output by your program is then applied to your JSON data.</span></p><p class="c3 c1"><span></span></p><p class="c1"><span class="c0">copy $people := {</span></p><p class="c1"><span class="c0">&nbsp;&quot;John&quot; : { &quot;status&quot; : &quot;single&quot; },</span></p><p class="c1"><span class="c0">&nbsp;&quot;Mary&quot; : { &quot;status&quot; : &quot;single&quot; } }</span></p><p class="c1"><span class="c0">modify (replace json value of $people(&quot;John&quot;)(&quot;status&quot;) with &quot;married&quot;,</span></p><p class="c1"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;replace json value of $people(&quot;Mary&quot;)(&quot;status&quot;) with &quot;married&quot;)</span></p><p class="c1"><span class="c0">return $people</span></p><p class="c11 c3 c1"><span class="c0"></span></p><p class="c1 c2"><span class="c8 c0">{ &quot;John&quot; : { &quot;status&quot; : &quot;married&quot; }, &quot;Mary&quot; : { &quot;status&quot; : &quot;married&quot; } }</span></p><p class="c3 c1"><span></span></p><p class="c1"><span>JSONiq works with the XQuery 3.0 standard (switch, typeswitch and try-catch expressions, universal/existential quantifiers, path expressions, filtering expressions, functors, mappings, grouping, windowing will work). The Zorba implementation is also compatible with the proprietary Zorba scripting.</span></p><p class="c3 c1"><span></span></p><p class="c9 c1"><span>The complete JSONiq specification is available on </span><span class="c5"><a class="c13" href="http://www.jsoniq.org/">http://www.jsoniq.org/</a></span></p><p class="c3 c1"><span></span></p></body></html>