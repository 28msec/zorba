/** \page eval Eval

 
\section evalgrammar Eval Function Signatures

<pre>

declare function reflection:eval-simple($query as xs:string) as item()*

declare updating function reflection:eval-simple($query as xs:string)

declare sequential function reflection:eval-simple($query as xs:string) as item()*

</pre>


\section evalsemantics Eval Semantics

As shown above, there are three variants of the eval function. Their purpose is 
to execute an xquery program from inside another xquery program. The xquery 
program that invokes an eval function will be referred to as the "outer" 
program, and the xquery program that is executed by the eval invocation will 
be referred to as the "inner" program. The inner program is given as a string 
argument to the eval function. Typically, the outer program constructs this 
string dynamically, e.g., based on data extracted from documents and/or the 
values of external variables. The eval function treats this string as the 
"source code" of an xquery main module; it parses the string, compiles the 
resulting parse tree, executes the resulting execution plan, and finally 
returns the result (if any) to the outer program.

The inner program "inherits" the static and dynamic contextes of the outer
program. Specifically, evaluation of the inner program is done in static and 
dynamic contextes that are initialized as copies of the static and dynamic 
contextes of the outer program at the place where the eval invocation appears 
at. This means that, for example, all variables that are in-scope at the place 
where the eval function is called from, are also in-scope inside the inner
program and can be referenced there without having to be re-declared. On the other
hand, declarations that appear in the prolog of the inner main module or are
imported by the inner main module from library modules, hide their corresponding
inherited declarations. For example, if the inner main module declares 
a variable or function with the same name as an inherited variable or function, 
the inner variable/function hides the inherited one. 

If the inner program declares an external variable with the same name as an 
inherited variable, the value of the inherited variable is used to initialize 
the inner external variable. If, however, an inner external variable has no 
default initializer and no corresponding inherited variable, it will remain 
uninitialized, causing the inner program to raise an error when executed.  
 
The three variants of eval differ in their expectations about the category of 
the root expression of the inner query: eval-simple expects the root 
expression to be a simple expression; eval-updating expects the root 
expression to be an updating expression and returns the resulting PUL to the
outer program; eval-sequential expects the root expression to be a sequential
expression. If the root expression turns out having a category other than the
expected one, an error is raised [err:???]. 


\section evalexamples Eval Examples


\subsection example1 Example 1
<code>
import module namespace refl = "http://www.zorba-xquery.com/modules/reflection";

declare variable $outerGlobal := 10;

declare function local:outerFunc($p) { $outerGlobal + $p };

<result xmlns:eval="www.foo.org">
{
  let $outerLet := 10
  return refl:eval-simple("<eval:result>
                           {$outerGlobal + $outerLet + local:outerFunc(5)}
                           </eval:result>")
}
</result>
</code>

The result of the above query is:

<code>
<result xmlns:eval="www.foo.org">
<eval:result>35</eval:result>
</result>
</code>

The example shows that the inner query inherits the static and dynamic context
of the outer query at the place where the call to the eval function is made. 
Specifically, in this example, the inner query accesses from the outer contextes
the global variable $outerGlobal, the LET variable $outerLet, the function 
local:outerFunc, and the binding of prefix "eval" to the namespace "www.foo.org".


\subsection example1 Example 2


<code>
import module namespace refl = "http://www.zorba-xquery.com/modules/reflection";

declare variable $outerGlobal := 10;

declare function local:outerFunc($p) { $outerGlobal + $p };

declare variable $query :=
"
declare variable $innerGlobal := 3; 

declare function local:innerFunc($p) { $innerGlobal + $outerGlobal + $p };
 
<eval:result>
{ $outerGlobal + $outerLet + local:outerFunc(5) + local:innerFunc(4) }
</eval:result>
";

<result xmlns:eval="www.foo.org">
{
  let $outerLet := 10
  return refl:eval-simple($query)
}
</result>
</code>

This example is similar to the previous one, but it shows that the inner query
may have its own prolog as well. The result of the above query is:

<code>
<result xmlns:eval="www.foo.org">
<eval:result>52</eval:result>
</result>
</code>


\subsection example1 Example 3


<code>
import module namespace refl = "http://www.zorba-xquery.com/modules/reflection";

let $x := 10
return refl:eval-simple("declare variable $x := 11; $x + 1")
</code>

The result of the above query is 12. The example shows that the declaration of 
variable $x in the inner query hides variable $x from the outer query.


\subsection example4 Example 4

\include eval_spec_ex_4.xq

In this example, the namespace prefix ns1 is inherited by the evaluated query, which also binds the prefix ns2 to the same namespace. The correct result for this query is 42.


\subsection example6 Example 6
\include eval_spec_ex_6.xq

This example should return 3 (nodes are atomized before being passed to eval).


\subsection example9 Example 9
\include eval_spec_ex_9.xq

This eval expression accesses $x in two ways â€” both in the ExprSingle and in the evaluated code. The result should be 42.


\subsection example10 Example 10
\include eval_spec_ex_10.xq

The correct answer is 42. This query illustrates that references to global variables within a user-defined function's body are resolved in the original dynamic context that the function was compiled against, not in the innermost dynamic context available.

*/
