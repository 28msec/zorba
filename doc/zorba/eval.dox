/** \page eval Eval

 
\section evalgrammar Eval Function Signatures

<pre>

declare function reflection:eval-simple($query as xs:string) as item()*

declare updating function reflection:eval-simple($query as xs:string)

declare sequential function reflection:eval-simple($query as xs:string) as item()*

</pre>


\section evalsemantics Eval Semantics

As shown above, there are three variants of the eval function. Their purpose is 
to execute an xquery program from inside another xquery program. The xquery 
program that invokes an eval function will be referred to as the "outer" 
program, and the xquery program that is executed by the eval invocation will 
be referred to as the "inner" program. The inner program is given as a string 
argument to the eval function. Typically, the outer program constructs this 
string dynamically, e.g., based on data extracted from documents and/or the 
values of external variables. The eval function treats this string as the 
"source code" of an xquery main module; it parses the string, compiles the 
resulting parse tree, executes the resulting execution plan, and finally 
returns the result (if any) to the outer program.

The inner program "inherits" the static and dynamic contextes of the outer
program. Specifically, evaluation of the inner program is done in static and 
dynamic contextes that are initialized as copies of the static and dynamic 
contextes of the outer program at the place where the eval invocation appears 
at. This means that, for example, all variables that are in-scope at the place 
where the eval function is called from, are also in-scope inside the inner
program and can referenced there without having to be re-declared. On the other
hand, declarations that appear in the prolog of the inner main module or are
imported by the main module from library modules, hide their corresponding
inherited declarations. For example, if the inner main module declares 
a variable or function with the same name as an inherited variable or function, 
the inner variable/function hides the inherited one. 

If the inner program declares an external variable with the same name as an 
inherited variable, the value of the inherited variable is used to initialize 
the inner external variable. If, however, an inner external variable has no 
default initializer and no corresponding inherited variable, it will remain 
uninitialized, causing the inner program to raise an error when executed.  
 
The three variants of eval differ in their expectation about the category of 
the QueryBody expression of the given query: eval-simple expects the QueryBody 
expression to be a simple expression; eval-updating expects the QueryBody 
expression to be an updating expression and returns the resulting PUL to the
outer program; eval-simple expects the QueryBody expression to be a sequential
expression. If the inner QueryBody turns out having a category other than the
expected one, an error is raised [err:???]. 


\section evalexamples Eval Examples


\subsection example1 Example 1
\include eval_spec_ex_1.xq

The query above is invalid as it re-declares the UsingClause bindings, which are implicitly defined in the evaluated prolog. It should raise err:XQST0049

\subsection example2 Example 2
\include eval_spec_ex_2.xq

The above query is valid and produces the result 42. It illustrates that evaluated code has access to global variables of the enclosing query.

\subsection example3 Example 3
\include eval_spec_ex_3.xq

This example, which in a conforming implementation should return the integer 42, illustrates that both global variables and user-defined functions from the enclosing query are available to the evaluated query, which may in turn contain its own user-defined functions.

\subsection example4 Example 4
\include eval_spec_ex_4.xq

In this example, the namespace prefix ns1 is inherited by the evaluated query, which also binds the prefix ns2 to the same namespace. The correct result for this query is 42.

\subsection example5 Example 5
\include eval_spec_ex_5.xq

This eval query attempts to use a FLWOR variable from the surrounding query without declaring it in the UsingClause; it should raise err:XPST0008 (undefined variable).

\subsection example6 Example 6
\include eval_spec_ex_6.xq

This example should return 3 (nodes are atomized before being passed to eval).

\subsection example7 Example 7
\include eval_spec_ex_7.xq

Since the UsingClause lists two variables with equal QName's, this query should raise err:XQST0049

\subsection example8 Example 8
\include eval_spec_ex_8.xq

As eval expects a single item, this query should raise err:XPTY0004

\subsection example9 Example 9
\include eval_spec_ex_9.xq

This eval expression accesses $x in two ways â€” both in the ExprSingle and in the evaluated code. The result should be 42.

\subsection example10 Example 10
\include eval_spec_ex_10.xq

The correct answer is 42. This query illustrates that references to global variables within a user-defined function's body are resolved in the original dynamic context that the function was compiled against, not in the innermost dynamic context available.

*/
