<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <title>XQuery Scripting Extension Proposal</title><style type="text/css">
/**/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
            border-bottom-width: 1pt;
            margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
table.small    { font-size: x-small; }

a.judgment:visited, a.judgment:link { font-family: sans-serif;
                                      color: black; 
                                      text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                                          text-decoration: none }
a.env:visited, a.env:link { color: black; 
                            text-decoration: none }
/**/
      </style><link rel="stylesheet" type="text/css" href="W3C-WD.css">
   </head>
   <body>
      <h1>XQuery Scripting Extension Proposal</h1>
      <h2>Authors</h2>
      <ul>
         <li>Matthias Brantner, 28msec, Inc., matthias.brantner@28msec.com</li>
         <li>Daniela Florescu, Oracle Corporation, daniela.florescu@oracle.com</li>
         <li>Ghislain Fourny, FLWOR Foundation, ghislain.fourny@flworfound.org</li>
         <li>Josh Spiegel, Oracle Corporation, josh.spiegel@oracle.com</li>
      </ul>
      <h1>Abstract</h1>
      <p>This specification defines an extension to XQuery 3.0
                  and XQuery Update Facility 1.0.
                  It introduces statements including the apply, local variable declaration, assignment,
                  while, exit and block statements, as well as statement counterparts to FLWOR, If, Switch,
                  Typeswitch, Trycatch expressions. Statements do not return any value but can have side
                  effects such as applying a PUL or reassigning a variable.
                  It also introduces block expressions, which may contain statements and thus also have
                  side effects. Such expressions must be evaluated in a specific order, which is
                  described here. Subsequent expressions can see the effects of the expressions that came before them. 
               
      </p>
      <hr>
      <h1>Table of Contents</h1>
      <ol>
         <li><a href="#Introduction">Introduction</a><ol></ol>
            <ol></ol>
         </li>
         <li><a href="#id-extensions-to-processing-model">Extensions to the Processing Model</a><ol></ol>
            <ol>
               <li><a href="#id-statements">Statements</a></li>
               <li><a href="#id-expressions">Expressions</a></li>
               <li><a href="#id-evaluation-order">Evaluation Order</a></li>
               <li><a href="#id-snapshot-scope">Snapshots</a></li>
               <li><a href="#id-nested-snapshots">Nested Snapshots</a></li>
               <li><a href="#id-variable-revalidation">Variable Binding Revalidation</a></li>
               <li><a href="#id-query-body">Main module</a></li>
            </ol>
         </li>
         <li><a href="#id-extensions-to-prolog">Extensions to the Prolog</a><ol></ol>
            <ol>
               <li><a href="#id-assignable-global-var">Global Variable Declarations</a></li>
               <li><a href="#id-function-decl">Function Declarations</a></li>
            </ol>
         </li>
         <li><a href="#id-new-statements">Statements</a><ol></ol>
            <ol>
               <li><a href="#id-apply">Apply Statement</a></li>
               <li><a href="#id-assignment">Assignment Statement</a></li>
               <li><a href="#id-break">Break Statement</a></li>
               <li><a href="#id-continue">Continue Statement</a></li>
               <li><a href="#id-exit">Exit Statement</a></li>
               <li><a href="#id-vardecl-statement">Variable Declaration Statement</a></li>
               <li><a href="#id-while-statement">While Statement</a></li>
            </ol>
         </li>
         <li><a href="#id-statements-expressions">Statement counterparts of existing expressions</a><ol></ol>
            <ol>
               <li><a href="#id-flwor-statement">FLWOR Statements and Expressions</a></li>
               <li><a href="#id-if-statement">Conditional Statements and Expressions</a></li>
               <li><a href="#id-switch-statement">Switch Statements and Expressions</a></li>
               <li><a href="#id-trycatch-statement">Try-Catch Statements and Expressions</a></li>
               <li><a href="#id-typeswitch-statement">Typeswitch Statements and Expressions</a></li>
               <li><a href="#id-block-statement">Block Statements and Expressions</a></li>
            </ol>
         </li>
         <li><a href="#id-expr-changes">Changes to existing expressions</a><ol></ol>
            <ol>
               <li><a href="#id-node-constructors-statements">Direct and Computed Node Constructors</a></li>
               <li><a href="#id-predicate-quantified">Predicate and quantified expressions.</a></li>
               <li><a href="#id-other-expr">Other Expressions</a></li>
            </ol>
         </li>
         <li><a href="#id-example">Example</a><ol></ol>
            <ol></ol>
         </li>
         <li><a href="#id-extra-grammatical">Extra-Grammatical Constraints</a><ol></ol>
            <ol></ol>
         </li>
         <li><a href="#id-lookahead">Alternative simplified grammar for LL-Parsers</a><ol></ol>
            <ol></ol>
         </li>
      </ol>
      <ol></ol>
      <hr>
      <h1><a name="Introduction"></a>1. Introduction
      </h1>
            
      
            
      <p>XQuery Scripting Extension Proposal extends XQuery 3.0, enabling it to
                  serve as a scripting language in order to satisfy XQuery Scripting Requirements. 
                  A prerequisite for this extension is XQuery Update Facility 1.0. 
                  The following abbreviations are used in this specification: 
                 
         [<b>XQUF</b> is an abbreviation for XQuery Update Facility 1.0.]
         
                 
         [<b>XQSX</b> is an abbreviation for XQuery Scripting Extension.]
         
      </p>
      
            
      <p>XQSX has the following properties:</p>
            
      <ul>
         <li>
                      
            <p>It is a strict superset of XQuery 3.0, in the
                           sense that all valid XQuery 3.0 expressions are also
                           valid XQSX expressions and have the same meaning. 
                         
            </p>
                    
         </li>
         <li>
                      
            <p>It is a strict superset of XQUF, in the
                           sense that all valid XQUF expressions are also
                           valid XQSX expressions and have the same meaning. 
                         
            </p>
                    
         </li>
      </ul>
            
      <p>This specification makes use of the prefix ann for some annotations, bound with the namespace http://www.zorba-xquery.com/annotations</p>
          
      <h1><a name="id-extensions-to-processing-model"></a>2. Extensions to the Processing Model
      </h1>
              
      
              
      <p>
                   Expressions in XQSX may have side-effects that are visible to subsequent expressions (according to their
                   evaluation order). This requires a number of extensions to the 
                   XQuery 3.0 and XQUF processing model.
                 
      </p>
      
              
      <h2><a name="id-statements"></a>2.1. Statements
      </h2>
                
                
      <p>
         [A <b>statement</b> is a grammatical construct which
                     does not return anything (no XDM, no PUL) but can have side-effects. Statements have to be executed
                     in the evaluation order defined in XQSX.]
         
      </p>
                
      <p>XQSX introduces the following statements:
                     
         <ul>
            <li>
               <p>Apply statements</p>
            </li>
            <li>
               <p>Variable declaration statements</p>
            </li>
            <li>
               <p>Variable assignment statements</p>
            </li>
            <li>
               <p>Control flow statements: While, Break, Continue and Exit</p>
            </li>
            <li>
               <p>Statements which have expression counterparts:
                                  If-Then-Else, FLWOR, Try-Catch, Switch, Typeswitch and Block.
               </p>
            </li>
         </ul>
                   
      </p>
              
              
              
      <h2><a name="id-expressions"></a>2.2. Expressions
      </h2>
                
              
      <h3><a name="id-updating-constraint"></a>2.2.1. Updating Expressions
      </h3>
                
                
      <p>
                     XQSX builds on top of XQuery 3.0 and XQuery Update 1.0, so that it keeps
                     the same constraints about an expression being simple (if it returns an empty PUL), updating (if it
                     returns an empty XDM) or vacuous (if both are empty).
      </p>
                  
      <p>This specification takes into account the fact that the XQUF specification might evolve and allow an updating
                     expression to return both a PUL and an XDM. We use the terminology of "non-updating" for simple expressions.
      </p>
                
      <p>The composability constraints and category rules for updating expressions are inherited
                     from the XQUF specification. Composability constraints are given for updating expressions in new expressions as
         well
                   as for sequential expressions.
      </p>
              
              
      <h3><a name="id-sequential"></a>2.2.2. Sequential Expressions
      </h3>
                
                
      <p>
                     In addition to the updating/non-updating categorization, XQSX
                     introduces another dimension to classify expressions: sequential/non-sequential expressions.
      </p>
                
      <ol>
         <li>
                          
            <p>
                               
               [A <b>sequential expression</b>
                                 is an expression that can have side effects other than constructing a new node or raising an error.]
               
                               Side effects include applying updates to an XDM instance,
                               altering the dynamic context, or affecting the flow of control.
            </p>
                          
            <p>An expression is sequential if it contains, directly or nested:</p>
                          
            <ul>
               <li>
                                    
                  <p>a call to a sequential function.</p>
                                  
               </li>
               <li>
                                    
                  <p>an assign statement, and the affected variable is declared outside
                                         of the expression.
                  </p>
                                  
               </li>
               <li>
                                    
                  <p>an apply statement, the operand of which is updating.</p>
                                  
               </li>
               <li>
                                    
                  <p>a break or continue statement without FLWOR or while statement inbetween in the expression tree.</p>
                                  
               </li>
               <li>
                                    
                  <p>an exit statement.</p>
                                  
               </li>
            </ul>
                          
            <p>
                               The side effects of a sequential expression are immediately effective
                               and are visible to subsequent expressions. 
                               Because of their side effects, sequential expressions must be evaluated
                               in evaluation order, as defined in this specification.
                               In addition to its side effects, a sequential expression may return
                               an XDM instance.
            </p>
                        
         </li>
         <li>
                          
            <p>
                               
               [A <b>non-sequential expression</b>
                                 is an expression that is is not sequential.]
               
            </p>
                        
         </li>
      </ol>
                
      <p>The classification of each expression into one of the above categories is
                     performed by static analysis.
      </p>
                
      <p>
                     Note that updating/non-updating and sequential/non-sequential are two orthogonal classification dimensions.
                     Hence, an expression can be non-updating and non-sequential, non-updating and sequential,
                     or updating and non-sequential.
                   
      </p>
              
            
              
              
      <h2><a name="id-evaluation-order"></a>2.3. Evaluation Order
      </h2>
                
                
      <p>
                     
         [XQSX defines an <b>evaluation order</b> on
                       many kinds of XQuery expressions, which is the order that operand expressions must be evaluated in order
                       to determine what side-effects are visible to later expressions.]
         
      </p>
                
      <p>Unless otherwise stated, a sequential expression or a statement must be executed exactly once.</p>
                
      <p>
                     An implementation may use any execution strategy as long as the result complies with
                     the semantics of this ordering.
      </p>
              
              
            
      <h2><a name="id-snapshot-scope"></a>2.4. Snapshots
      </h2>
              
              
      <p>The term <b>snapshot</b> is defined in XQuery Update Facility as follows:
                    
         [A <b>snapshot</b> is a scope
                    within which expressions are evaluated with respect to a fixed
                    XDM instance, accessible through the dynamic context's bindings,
                    and updates are held pending.]
         
                    A snapshot is terminated by invocation of the upd:applyUpdates operation.
                    Unlike XQUF, XQSX
                    permits an XQuery program to contain more than one snapshot.
      </p>
      
      
              
      <p>
                   XQuery 1.0 and XPath 2.0 Functions and Operators defines certain functions as stable. Stable functions
                   such as fn:current-time and fn:doc are defined to return the same result given the same
                   arguments within an execution scope.
                   XQSX permits an XQuery program to contain more than one execution scope.
      </p>
      
      
              
      <p>In XQSX, a snapshot and execution scope is defined as the lapse between two side effects to the environment, reachable
                   through the dynamic context, on which
                 the XQuery program operates.
      </p>
              
      <p>Each of the following events marks the end of the current snapshot and execution scope, and the beginning of a new one:</p>
              
      <ul>
         <li>
            <p>The invocation of upd:applyUpdates,</p>
         </li>
         <li>
            <p>Calling an external, sequential function,</p>
         </li>
         <li>
            <p>Assigning a new value to a variable.</p>
         </li>
      </ul>
              
            
              
      <h2><a name="id-nested-snapshots"></a>2.5. Nested Snapshots
      </h2>
                
      
              
      <p>
                   To avoid nested snapshots, it is forbidden for an expression to be both updating and sequential. If such is the
         case,
                   a static error is raised.
                 
      </p>
              
            
      
              
      <h2><a name="id-variable-revalidation"></a>2.6. Variable Binding Revalidation
      </h2>
              
              
      <p>
                   To ensure type soundness, variable bindings are revalidated at the end of each scope to check that
                   any updates applied have not made them invalid with repect to their declared types. It is a dynamic
                   error  if, after applying a pending update list (using upd:applyUpdates),
                   the XDM instance bound to any in-scope variable does not match the static type of that variable according
                   to SequenceType matching rules.
                 
      </p>
            
      
              
      <h2><a name="id-query-body"></a>2.7. Main module
      </h2>
                
                <pre>
0 - <a name="MainModule" class="ext">MainModule</a> ::= <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Prolog" class="new">Prolog</a> <a href="Program" class="new">Program</a>
    </pre><pre>
1 - <a name="Program" class="ext">Program</a> ::= <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a>
    </pre><pre>
4 - <a name="StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> ::= <a href="#Statements" class="new">Statements</a> <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a>?
    </pre>
                <p>A main module is redefined to be be a prolog followed by a program.</p>
                
      <p>A program corresponds to the body of a block expression, except that the final expression
                     may be omitted. If such is the case, the final expression is considered to be the empty sequence.
                   
      </p>
                
      <p>The program is evaluated like a block expression. The semantics are those of XQuery 3.0 or
                     XQuery Update Facility 1.0, i.e.,
                     its XDM value is the result of the program and the PUL it returns is applied
      </p>
                
      <hr>
      <p><b>Note:</b></p>
                  
      <p>The current XQUF specification only allows either a non-empty XDM or a non-empty PUL to be returned.</p>
                
      <hr>
              
              
            
      <h1><a name="id-extensions-to-prolog"></a>3. Extensions to the Prolog
      </h1>
              
      
              
      <h2><a name="id-assignable-global-var"></a>3.1. Global Variable Declarations
      </h2>
                
                <pre>
[unchanged] AnnotatedDecl ::= "declare" Annotation* (VarDecl | FunctionDecl)
    </pre><pre>
[unchanged] Annotation : =  "%" EQName ( "(" Literal ("," Literal)* ")" ) ?
    </pre><pre>
[unchanged] VarDecl	::= "variable" "$" VarName TypeDeclaration? ((":=" VarValue) | ("external" (":=" VarDefaultValue)?)))
    </pre>
                
                  <b>Definitions:</b>
                      
      <p>
                           XQSX allows the built-in annotations %ann:assignable and %ann:nonassignable
                           to be used in a Prolog variable declaration. If both annotations are used, a static error is raised.
      </p>
                      
      <p>
         [An <b>assignable prolog variable</b> is a global
                           variable whose declaration specifies %ann:assignable, and
                           may have its
                           value changed by an assign statement.]
         
      </p>
                      
      <p>
         [An <b>unassignable prolog variable</b> is a global
                           variable whose declaration specifies %ann:nonassignable, and may not have its
                           value changed by an assign statement.]
         
      </p>
                      
      <p>If an assignment qualifier is not used, the default is unassignable.
                         
      </p>
                    
                  <b>Composability Constraints:</b>
                      
      <p>The initializing expression of a prolog variable (whether assignable or not)
                           must be a non-updating and non-sequential expression .
      </p>
                    
                  <b>Semantics:</b>
                    
      <p>The semantics of declaring assignable variables are the same as the semantics of unassignable variables, except that
                     the static type of an assignable variable without a declared type is always item()*.
                       
      </p>
                  
                
              
      
      
              
      <h2><a name="id-function-decl"></a>3.2. Function Declarations
      </h2>
                
                <pre>
32 - <a name="FunctionDecl" class="ext">FunctionDecl</a> ::= "function" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-EQName" class="un">EQName</a> "(" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-ParamList" class="un">ParamList</a>? ")"
                      ("as" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-SequenceType" class="un">SequenceType</a>)? ("{" <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> "}" | "external"))
    </pre><pre>
[unchanged] Annotation : =  "%" EQName ( "(" Literal ("," Literal)* ")" ) ?
    </pre><pre></pre><pre>
4 - <a name="StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> ::= <a href="#Statements" class="new">Statements</a> <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a>?
    </pre>
                
                  <b>Definitions:</b>
                      
      <p>
                           XQSX allows the built-in annotations %ann:sequential and %ann:nonsequential
                           to be used in a Prolog function declaration. If both annotations are used, a static error is raised.
      </p>
                      
      <p>
                           
         [A <b>non-sequential function</b>
                           is a function whose declaration specifies %ann:nonsequential .
                             ]
         
                           
      </p>
                      
      <p>
                           
         [A <b>sequential function</b>
                             is a function whose declaration specifies the annotation %ann:sequential.]
         
                         
      </p>
                      
      <p>If a qualifier is not used, the default is non-sequential.</p>
                    
                  <b>Composability Constraints:</b>
                      
      <p>A function body corresponds to a block expression, except that the final expression may be omitted
                           (i.e., there are only statements). If such is the case,
                           the final expression is considered to be the empty sequence. Therefore in the following explanations,
                           we identify the function body with a block expression.
      </p>
                      
      <p>
                           The body of an non-sequential function
                           must be a non-sequential expression, except if the only reason why the expression
                           is sequential is that it contains an exit statement. Otherwise,
                           a static error is raised.
      </p>
                    
                  <b>Semantics:</b>
                      
      <p>The semantics of functions
                           are as follows. The function body is evaluated like a block expression.
                           Its result is determined
                           by the first exit statement encountered during evaluation of the Block. 
                           If no exit statement is encountered, the result of the function is the value returned by the block expression
                           (an empty XDM and an empty PUL if the final expression is omitted).
                           Other than that, the semantics is as defined
                           in XQuery Update Facility 1.0.
      </p>
                    
                
              
              
            
      <h1><a name="id-new-statements"></a>4. Statements
      </h1>
            
            
      <p>XQSX extends the XQuery 1.0 syntax
                 by adding statements to the grammar. A statement may or may not have
                 side effects, and does not return anything.
                 There are the following kinds of statements:
      </p>
            <pre>
5 - <a name="Statement" class="new">Statement</a> ::=
      <a href="#ApplyStatement" class="new">ApplyStatement</a>
    | <a href="#AssignStatement" class="new">AssignStatement</a>
    | <a href="#BlockStatement" class="new">BlockStatement</a>
    | <a href="#BreakStatement" class="new">BreakStatement</a>
    | <a href="#ContinueStatement" class="new">ContinueStatement</a>
    | <a href="#ExitStatement" class="new">ExitStatement</a>
    | <a href="#FLWORStatement" class="new">FLWORStatement</a>
    | <a href="#IfStatement" class="new">IfStatement</a>
    | <a href="#SwitchStatement" class="new">SwitchStatement</a>
    | <a href="#TryCatchStatement" class="new">TryCatchStatement</a>
    | <a href="#TypeswitchStatement" class="new">TypeswitchStatement</a>
    | <a href="#VarDeclStatement" class="new">VarDeclStatement</a>
    | <a href="#WhileStatement" class="new">WhileStatement</a>
    </pre>
            
            <p>This part presents the statements that have no expression counterpart because they provide
                 new semantic features.
      </p>
            
            
      <h2><a name="id-apply"></a>4.1. Apply Statement
      </h2>
              
              <pre>
6 - <a name="ApplyStatement" class="new">ApplyStatement</a> ::= <a href="#ExprSimple" class="new">ExprSimple</a> ";"
    </pre>
              
                <b>Composability Constraints:</b>
                    
      <p>(none).</p>
                  
                <b>Semantics:</b>
                    
      <p>
                         After the evaluation of SimpleExpr, the
                         pending update list returned by
                         this expression is applied (by upd:applyUpdates).
                         The XDM instance
                         returned by this expression is discarded.
                       
      </p>
                  
                <b>Evaluation order:</b>
                    
      <p>
                         SimpleExpr is evaluated exactly once before the semantics of the Apply Statement is applied.
                       
      </p>
                  
              <b>Example:</b>
                  <pre>
delete nodes ($user, $items, $bids);
            </pre>
                
              
            
            
            <h2><a name="id-assignment"></a>4.2. Assignment Statement
      </h2>
              
              <pre>
7 - <a name="AssignStatement" class="new">AssignStatement</a> ::= "$" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-VarName" class="un">VarName</a> ":=" <a href="#ExprSingle" class="ext">ExprSingle</a> ";"
    </pre>
              
                <b>Composability Constraints:</b>
                    
      <p>The operand must be non-updating.</p>
                  
                <b>Semantics:</b>
                    
      <p>The variable on the left-hand side of the assignment must be in scope and declared assignable, otherwise a
                         static error  is raised. In particular, it must have been declared
                         by a variable declaration, local or in the prolog.
      </p>
                    
      <hr>
      <p><b>Note:</b></p>
                      
      <p>Variables bound in FLWOR, typeswitch, or quantified expressions or statements, as well as function
                           parameters, may not appear
                           on the left-hand side of an assignment.
      </p>
                    
      <hr>
                    
      <p>
                         The expression on the right-hand side is evaluated,
                         resulting in an XDM instance.
                       
      </p>
                    
      <p>If the XDM instance
                         returned by the expression on the right-hand side does not match the declared type
                         of the variable according to SequenceType matching rules,
                         a type error is raised . 
                         If the types match, the XDM instance
                         returned by the expression is bound to the variable (added to variable values
                         in the dynamic context.)
      </p>
                  
                <b>Evaluation order:</b>
                    
      <p>
                         The operand expression is evaluated exactly once before the semantics of the Assignment Statement is applied.
                       
      </p>
                  
                <b>Example:</b>
                    <pre>
$result := "Bidding exceeded 60000";
              </pre>
                  
              
            
            
      
            
            <h2><a name="id-break"></a>4.3. Break Statement
      </h2>
              
              <pre>
9 - <a name="BreakStatement" class="new">BreakStatement</a> ::= "break" "loop" ";"
    </pre>
              
              
                <b>Composability Constraints:</b>
                    
      <p>(none)</p>
                  
                <b>Semantics:</b>
                    
      <p>A break statement interrupts the execution of the innermost while or FLWOR statement. The execution
                       of the program continues as if the execution of the while or FLWOR statement had properly finished.
      </p>
                    
      <p>A static error is raised if there is no enclosing while or FLWOR statement.</p>
                    
      <hr>
      <p><b>Note:</b></p>
                      
      <p>A break statement does not interfere with a FLWOR expression, only with FLWOR statements.</p>
                    
      <hr>
                  
                <b>Example:</b>
                    <pre>
break loop;              </pre>
                  
              
            
            
            
            
            <h2><a name="id-continue"></a>4.4. Continue Statement
      </h2>
              
              <pre>
10 - <a name="ContinueStatement" class="new">ContinueStatement</a> ::= "continue" "loop" ";"
    </pre>
              
              
                <b>Composability Constraints:</b>
                    
      <p>(none)</p>
                  
                <b>Semantics:</b>
                    
      <p>A continue statement interrupts the current execution of the operand or return statement of the
                         innermost while or FLWOR statement.
                         In the case of a while statement, the resumes with a new evaluation of the test expression and,
                         possibly, of the inner statement. In the case of a FLWOR statement, the execution resumes with
                         the next tuple.
                       
      </p>
                    
      <hr>
      <p><b>Note:</b></p>
                      
      <p>A continue statement does not interfere with a FLWOR expression, only with FLWOR statements.</p>
                    
      <hr>
                  
                <b>Example:</b>
                    <pre>
continue loop;              </pre>
                  
              
            
            
            
            
            <h2><a name="id-exit"></a>4.5. Exit Statement
      </h2>
              
              <pre>
11 - <a name="ExitStatement" class="new">ExitStatement</a> ::= "exit" "returning" <a href="#ExprSingle" class="ext">ExprSingle</a> ";"
    </pre>
              
              
                <b>Composability Constraints:</b>
                    
      <p>(none)</p>
                  
                <b>Semantics:</b>
                    
      <p>An exit statement serves to define the result of the enclosing function or query body.</p>
                    
      <p>
                         The operand expression of the exit expression is evaluated, resulting in an
                         XDM instance
                         and a pending update list.
                       
      </p>
                    
      <p>If an exit statement is evaluated within the body of a function,
                         further evaluation of the function body is interrupted and the
                         XDM instance and
                         pending update list returned by
                         the operand expression are returned as the result of the function call.
      </p>
                    
      <p>If an exit statement is evaluated within a query body
                         (i.e., not within the body of a function), further evaluation of the query
                         is interrupted and the XDM instance and
                         pending update list
                         returned by the operand expression are returned as the result of the query.
      </p>
                    
      <hr>
      <p><b>Note:</b></p>
                      
      <p>An exit statement in a block terminates evaluation of the
                           enclosing function body or program, not just the immediately enclosing block.
      </p>
                    
      <hr>
                  
                <b>Evaluation order:</b>
                    
      <p>
                         The operand expression is evaluated exactly once before the semantics of the Exit Statement is applied.
                         Subsequent expressions or statements within the enclosing function body or query are not evaluated at all.
                       
      </p>
                  
                <b>Example:</b>
                    <pre>
exit returning local:error(concat("You cannot use the ",
                                  $request/method,
                                  " method with this URL."));              </pre>
                  
              
            
      
            <h2><a name="id-vardecl-statement"></a>4.6. Variable Declaration Statement
      </h2>
              
              <pre>
20 - <a name="VarDeclStatement" class="new">VarDeclStatement</a> ::= ("local" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Annotation" class="un">Annotation</a>*)? "variable" "$" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-VarName" class="un">VarName</a> <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-TypeDeclaration" class="un">TypeDeclaration</a>? (":=" <a href="#ExprSingle" class="ext">ExprSingle</a>)?
    ("," "$" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-VarName" class="un">VarName</a> <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-TypeDeclaration" class="un">TypeDeclaration</a>? (":=" <a href="#ExprSingle" class="ext">ExprSingle</a>)?)* ";"
    </pre>
              <p>
         [The expression on
                   the right-hand side of a block variable declaration is called an
                   <b>initializing expression</b>.]
         
      </p>
              
      <p>
         [The <b>scope expression</b> of a variable declaration
                   is the innermost block expression, control flow clause (then/else clause,
                   Switch/Typeswitch/FLWOR return clause, while body clause), function body or program
                   containing the variable declaration expression.]
         
      </p>
              
                <b>Composability Constraints:</b>
                   
      <p>The initializing expression must be non-updating.</p>
                  
                <b>Semantics:</b>
                    
      <p>A variable declaration defines a local variable whose scope
                         is the remainder of its scope expression (not including its initializing expression). 
                         The variable defined in a variable declaration occludes (hides)
                         any variable of the same name that is in scope at the location where the innermost block appears.
      </p>
                    
      <p>The variable may be annotated as assignable or as unassignable. By default, it is assignable.
                         It may only be modified by assignment
                         statements if it is assignable.
      </p>
                    
      <hr>
      <p><b>Note:</b></p>
                      
      <p>The default for local variable declarations is different from variables declared in the prolog.
                         The latter are unassignable if there is no annotation.
      </p>
                    
      <hr>
                    
      <p>It is a static error  if two or more variables declared in the same scope expression
                         have the same expanded QName.
      </p>
                    
      <p>The type of each declared variable is added to in-scope variables
                         in the static context of subsequent expressions in the enclosing block, function body or program. 
                         If a variable has both an explicit type declaration and an
                         initializing expression,
                         the value of the initializing expression must match
                         the declared type according to SequenceType matching rules; otherwise a type error is raised .
                         If no explicit type is declared and the variable is assignable, the type of the variable is item()*.
                         If no explicit type is declared and the variable is unassignable, the type is statically inferred from the
         initializing expression.
      </p>
                    
      <p>The block variable declaration evaluates its initializing expression
                         and binds the resulting XDM instance to the variable values in
                         the dynamic context of subsequent expressions in the enclosing block, function body or program.
                         If no initializing expression is present, the variable has no initial value. 
                         A reference to a variable, other than on the left-hand side of an assignment expression,
                         is an error if the variable has no value in variable values
                         when the reference is evaluated .
      </p>
                  
                <b>Evaluation order:</b>
                    
      <p>
                         The operand expression is evaluated exactly once before the semantics of the Declaration Statement is applied.
                       
      </p>
                  
                <b>Example:</b>
                    <pre>
variable $uid := doc("users.xml")/users/user_tuple
                 [name = "Roger Smith"]/userid;              </pre>
                  
              
            
            
            
            
            <h2><a name="id-while-statement"></a>4.7. While Statement
      </h2>
              
              <pre>
21 - <a name="WhileStatement" class="new">WhileStatement</a> ::= "while" "(" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a> ")" <a href="#Statement" class="new">Statement</a>
    </pre>
              
                <b>Composability Constraints:</b>
                    
      <p>
         [The expression enclosed in the
                         parentheses of a while expression is called a <b>test expression</b>.]
         
      </p>
                      
      <p>The test expression must be non-updating and non-sequential.</p>
                  
                <b>Semantics:</b>
                    
      <p>The while statement is used for conditional iteration.  It is evaluated as follows:</p>
                    
      <p>
                         The test expression is evaluated, resulting in an
                         XDM instance.
                       
      </p>
                    
      <p>
                         If the effective Boolean value of the test expression
                         is false, the block is not evaluated. If the effective Boolean value of the
                         test expression is true, the statement is evaluated repeatedly. 
                         Each evaluation of the statement may cause side effects that affect the result of re-evaluating the
                         test expression. 
                         The test expression is re-evaluated after each evaluation of the statement. 
                         This process continues until the effective Boolean value of the test expression
                         is evaluated to be false.
                       
      </p>
                  
                <b>Evaluation order:</b>
                    
      <p>
                         The statement is executed exactly once after each evaluation of the test expression until its EBV is false.
                       
      </p>
                  
                <b>Example:</b>
                    
      <p>In the following query, a while statement is used to compute a sequence
                         containing all the Fibonacci numbers that are less than 100.
      </p>
                    <pre>
variable $a as xs:integer := 0;
variable $b as xs:integer := 1;  
variable $c as xs:integer := $a + $b;
variable $fibseq as xs:integer* := ($a, $b);

while ($c &lt; 100) { 
  $fibseq := ($fibseq, $c);
  $a := $b;
  $b := $c;
  $c := $a + $b;
}
              </pre>
                  
              
            
      
          <h1><a name="id-statements-expressions"></a>5. Statement counterparts of existing expressions
      </h1>
            
            
      <p>XQSX defines statement counterparts for control flow
               expressions (FLWOR, IfThenElse, Switch, Typeswitch, Trycatch). It also defines an evaluation order
               for statements and sequential expressions. An expression or statement following another according
               to this evaluation order sees the side effects of this other expression or statement.
      </p>
      
            
      <p>Composability Contraints for updating expressions that are operands of any expressions defined in XQUF
                 are extended to
                 operand expressions of their statement counterparts (non-return expressions in FLWOR statements, test expressions
         in
                 conditional statements, switch statements and typeswitch statements).
      </p>
            
            
      <h2><a name="id-flwor-statement"></a>5.1. FLWOR Statements and Expressions
      </h2>
              
                
      <p>In addition to FLWOR Expressions, XQSX introduces FLWOR Statements,
                     defined like FLWOR Expressions except that the final clause is
                     a statement.
      </p>
                <pre>
12 - <a name="FLWORStatement" class="new">FLWORStatement</a> ::= <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-InitialClause" class="un">InitialClause</a> <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-IntermediateClause" class="un">IntermediateClause</a>* <a href="#DoStatement" class="new">ReturnStatement</a>
    </pre>
              
                <b>Composability Constraints:</b>
                    
      <hr>
      <p><b>Note:</b></p>
                      
      <p>
                           The XQUF specification currently forbids clauses other than return clauses of a FLWOR expression to be updating.
                           Furthermore, it specifies that the category (updating or not) of a FLWOR expression is
                           the same as that of its return clause.
                         
      </p>
                    
      <hr>
                    
      <p>The expressions in the for, let, window, order-by, group-by, where and count clauses must be
                       non-sequential.
      </p>
                  
                <b>Semantics:</b>
                    
      <p>The semantics of FLWOR Expressions is unchanged.</p>
                    
      <p>For FLWOR Statements, the input tuple stream is generated as described in XQuery 3.0.
                         The return statement is executed once for each tuple in its input tuple stream,
                         using the variable bindings in the respective tuples, in the order in which these tuples
                         appear in the input tuple stream.
      </p>
                  
                <b>Evaluation order:</b>
                    
      <p>The return clauses are evaluated in the order in which these tuples
                         appear in the input tuple stream.
      </p>
                  
                <b>Example:</b>
                    <pre>
for $book in book:search($eventNode/preceding-sibling::xhtml:input[1])
return 
insert node
&lt;xhtml:tr&gt;
  &lt;xhtml:td&gt;{data($book/title)}&lt;/xhtml:td&gt;
  &lt;xhtml:td&gt;{data($book/isbn)}&lt;/xhtml:td&gt;
  &lt;xhtml:td/&gt;
&lt;/xhtml:tr&gt;
as last into $table;
              </pre>
                    <p>The same with bulk updates:</p>
                    <pre>
(for $book in book:search($eventNode/preceding-sibling::xhtml:input[1])
return 
insert node
&lt;xhtml:tr&gt;
  &lt;xhtml:td&gt;{data($book/title)}&lt;/xhtml:td&gt;
  &lt;xhtml:td&gt;{data($book/isbn)}&lt;/xhtml:td&gt;
  &lt;xhtml:td/&gt;
&lt;/xhtml:tr&gt;
as last into $table);
              </pre>
                  
              
            
            
            <h2><a name="id-if-statement"></a>5.2. Conditional Statements and Expressions
      </h2>
              
              
      <p>In addition to Conditional Expressions, XQSX introduces Conditional Statements,
                   defined like Conditional Expressions except that the then and the else clause are
                   statements.
      </p>
              <pre>
14 - <a name="IfStatement" class="new">IfStatement</a> ::= "if" "(" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a> ")" "then" <a href="#Statement" class="new">Statement</a> "else" <a href="#Statement" class="new">Statement</a>
    </pre>
              
                <b>Composability Constraints:</b>
                    
      <hr>
      <p><b>Note:</b></p>
                      
      <p>
                           The XQUF specification currently forbids the test expression to be updating.
                         
      </p>
                    
      <hr>
                    
      <p>The test expression must be non-sequential.</p>
                  
                <b>Semantics:</b>
                    
      <p>The semantics of Conditional Expressions is unchanged.</p>
                    
      <p>For Conditional Statements, the test expression is evaluated.
                         If the EBV of its returned XDM is true, then the then statement is executed,
                         otherwise the else statement is executed.
                       
      </p>
                  
                <b>Evaluation order:</b>
                    
      <p>Depending on the EBV of the test expression, either the then clause or the
                         else clause (but not both) is evaluated, exactly once.
      </p>
                  
                <b>Example:</b>
                    <pre>
if($newbid &lt;= 60000) then {
  insert nodes
  &lt;bid_tuple&gt;
    { $uid, $item/itemno }
    &lt;bid&gt;{ $newbid }&lt;/bid&gt; 
    &lt;bid_date&gt;{ fn:current-date() }&lt;/bid_date&gt; 
  &lt;/bid_tuple&gt;
  into doc("bids.xml")/bids;
  $result := concat("What a bargain! You got a helicopter for ",
                    $newbid);
} else {
  $result := "Bidding exceeded 60000";
  $maximumExceeded := true();
}
              </pre>
                  
              
            
      
            <h2><a name="id-switch-statement"></a>5.3. Switch Statements and Expressions
      </h2>
              
              
      <p>In addition to Switch Expressions, XQSX introduces Switch Statements,
                   defined like Switch Expressions except that the return clauses are
                   statements.
      </p>
              <pre>
15 - <a name="SwitchStatement" class="new">SwitchStatement</a> ::= "switch" "(" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a> ")" <a href="#SwitchCaseStatement" class="new">SwitchCaseStatement</a>+ "default" "return" <a href="#Statement" class="new">Statement</a>
    </pre>
              
                <b>Composability Constraints:</b>
                    
      <hr>
      <p><b>Note:</b></p>
                      
      <p>The XQUF specification does not yet take into account the switch expressions introduced in XQuery 3.0.
                           It is outside of the scope of this XQuery Scripting specification to do so, but until the XQUF 3.0 specification
                           is ready we consider that all operand expressions must be non-updating.
      </p>
                    
      <hr>
                    
      <p>The switch operand expression must be non-sequential.</p>
                  
                <b>Semantics:</b>
                    
      <p>The semantics of Switch Expressions is unchanged.</p>
                    
      <p>For Switch Statements, the return statement in the effective
                         case is executed.
                       
      </p>
                  
                <b>Evaluation order:</b>
                    
      <p>Only the return clause in the effective case is evaluated, exactly once.</p>
                  
              
            
            
            
      <h2><a name="id-trycatch-statement"></a>5.4. Try-Catch Statements and Expressions
      </h2>
              
              
      <p>In addition to Try-Catch Expressions, XQSX introduces Try-Catch Statements,
                   defined like Try-Catch Expressions except that the try and catch clauses are
                   statements.
      </p>
              <pre>
17 - <a name="TryCatchStatement" class="new">TryCatchStatement</a> ::= "try" <a href="#BlockStatement" class="new">BlockStatement</a> ("catch" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-CatchErrorList" class="un">CatchErrorList</a> <a href="#BlockStatement" class="new">BlockStatement</a>)+
    </pre>
              
                <b>Composability Constraints:</b>
                    
      <hr>
      <p><b>Note:</b></p>
                      
      <p>The XQUF specification does not yet take into account the try-catch expressions introduced in XQuery 3.0.
                           It is outside of the scope of this XQuery Scripting specification to do so, but until XQUF 3.0 is ready
                           we will consider that try and catch expressions must be either all updating or all non-updating.
      </p>
                    
      <hr>
                  
                <b>Semantics:</b>
                    
      <p>The semantics of Try-Catch Expressions is unchanged.</p>
                    
      <p>For Try-Catch Statements, the try statement is executed.
                         If this execution raises a dynamic error or a type error, the first catch statement
                         that "matches" the error value is executed.
                       
      </p>
                  
                <b>Evaluation order:</b>
                   
      <p>If no error is dynamic or type error is raised during the evaluation of the try clause,
                      no catch clause gets executed. Otherwise, the execution of the try clause is interrupted when
                      this error is raised, and only the first catch statement that "matches" the error value is executed,
                      exactly once.
      </p>
                 
              
            
            
            
      <h2><a name="id-typeswitch-statement"></a>5.5. Typeswitch Statements and Expressions
      </h2>
              
              
      <p>In addition to Typeswitch Expressions, XQSX introduces Typeswitch Statements,
                   defined like Typeswitch Expressions except that the try and catch clauses are
                   statements.
      </p>
              <pre>
18 - <a name="TypeswitchStatement" class="new">TypeswitchStatement</a> ::= "typeswitch" "(" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a> ")" <a href="#CaseStatement" class="new">CaseStatement</a>+ "default" ("$" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-VarName" class="un">VarName</a>)? "return" <a href="#Statement" class="new">Statement</a>
    </pre>
              
                <b>Composability Constraints:</b>
                    
      <hr>
      <p><b>Note:</b></p>
                      
      <p>
                           The XQUF specification currently forbids the operand expressions of a typeswitch expression to be updating.
                         
      </p>
                    
      <hr>
                    
      <p>The test expression must be non-sequential.</p>
                  
                <b>Semantics:</b>
                    
      <p>The semantics of Typeswitch Expressions is unchanged.</p>
                    
      <p>For Typeswitch Statements, the return statement in the effective
                         case is executed.
                       
      </p>
                  
                <b>Evaluation order:</b>
                    
      <p>Only the return clause in the effective case is evaluated.</p>
                  
              
            
            
            
      <h2><a name="id-block-statement"></a>5.6. Block Statements and Expressions
      </h2>
              
              
      <p>A block statement is a concatenation of zero, one or more statements, surrounded by curly braces.</p>
              
      <p>A block expression is a concatenation of zero, one or more statements and one expression, surrounded by curly braces.</p>
              <pre>
30 - <a name="PrimaryExpr" class="ext">PrimaryExpr</a> ::=
      <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Literal" class="un">Literal</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-VarRef" class="un">VarRef</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-ParenthesizedExpr" class="un">ParenthesizedExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-ContextItemExpr" class="un">ContextItemExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-FunctionCall" class="un">FunctionCall</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-OrderedExpr" class="un">OrderedExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-UnorderedExpr" class="un">UnorderedExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Constructor" class="un">Constructor</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-FunctionItemExpr" class="un">FunctionItemExpr</a>
  |   <a href="#BlockExpr" class="new">BlockExpr</a>
    </pre><pre>
31 - <a name="BlockExpr" class="new">BlockExpr</a> ::= "{" <a href="#StatementsAndExpr" class="new">StatementsAndExpr</a> "}
    </pre><pre>
3 - <a name="StatementsAndExpr" class="new">StatementsAndExpr</a> ::= <a href="#Statements" class="new">Statements</a> <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a>
    </pre><pre>
2 - <a name="Statements" class="new">Statements</a> ::= <a href="#Statement" class="new">Statement</a>*
    </pre><pre>
8 - <a name="BlockStatement" class="new">BlockStatement</a> ::= "{" <a href="#Statements" class="new">Statements</a> "}"
    </pre>
              
                <b>Composability Constraints:</b>
                      
      <p>If the final expression is non-updating, the block expression is non-updating.
                         If the final expression is updating, the block expression is updating.
      </p>
                  
                <b>Semantics:</b>
                    
      <p>Each statement, as well as the final expression if any, is evaluated.</p>
                    
      <p>The result of a block expression is the XDM and PUL returned by its final expression.</p>
                  
                <b>Evaluation order:</b>
                    
      <p>The statements (and the final expression for a Block Expression) are evaluated in the order they appear.</p>
                  
                <b>Example:</b>
                    <pre>
{
variable $uid := doc("users.xml")/users/user_tuple[name = "Roger Smith"]/userid;
variable $topbid := max(doc("bids.xml")/bids/bid_tuple[itemno = 1002]/bid);
variable $newbid := $topbid * 1.1;

insert nodes
&lt;bid_tuple&gt; 
  &lt;userid&gt;{ data($uid) }&lt;/userid&gt; 
  &lt;itemno&gt;1002&lt;/itemno&gt; 
  &lt;bid&gt;{ $newbid }&lt;/bid&gt; 
  &lt;bid_date&gt;1999-03-03&lt;/bid_date&gt; 
&lt;/bid_tuple&gt;
into doc("bids.xml")/bids;

&lt;new_bid&gt;{ $newbid }&lt;/new_bid&gt;
}
              </pre>
                  
              
            
          <h1><a name="id-expr-changes"></a>6. Changes to existing expressions
      </h1>
            
            
            
      <h2><a name="id-node-constructors-statements"></a>6.1. Direct and Computed Node Constructors
      </h2>
              
              
      <p>Node constructors are extended to allow statements in their content.</p>
              <pre>
24 - <a name="CommonContent" class="ext">CommonContent</a> ::= <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-PredefinedEntityRef" class="un">PredefinedEntityRef</a> | <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-CharRef" class="un">CharRef</a> | "{{" | "}}" | "{" <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> "}"
</pre><pre>
25 - <a name="ContentExpr" class="ext">ContentExpr</a> ::= <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a>

26 - CompDocConstructor ::= "document" "{" <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> "}"

27 - CompAttrConstructor ::= "attribute" (<a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-EQName" class="un">EQName</a> | ("{" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a> "}")) "{" <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> "}"

28 - CompPIConstructor ::= "processing-instruction" (<a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-NCName" class="un">NCName</a> | ("{" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a> "}")) "{" <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> "}"

29 - CompCommentConstructor ::= "comment" "{" <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> "}"
    </pre>
              
                <b>Composability Constraints:</b>
                    
      <p>(none)</p>
                  
                <b>Semantics:</b>
                    
      <p>The semantics are the same as in XQuery 3.0.</p>
                    
      <p>StatementsAndOptionalExpr corresponds a block expression and is evaluated as such,
                         except that the final expression may be omitted
                         (i.e., there are only statements). If such is the case,
                         the final expression is considered to be the empty sequence.
      </p>
                  
                <b>Evaluation order:</b>
                    
      <p>The operands are evaluated from left to right.</p>
                  
              
            
            
      <h2><a name="id-predicate-quantified"></a>6.2. Predicate and quantified expressions.
      </h2>
              
              
                <b>Composability Constraints:</b>
                    
      <p>
                         A quantified or predicate expression must be non-sequential.
                       
      </p>
                    
      <hr>
      <p><b>Note:</b></p>
                      
      <p>
                           The motivation behind this restriction is that their operands can be converted to for or where clauses in
         FLWOR expressions in the query plan.
                         
      </p>
                    
      <hr>
                  
              
            
            
      <h2><a name="id-other-expr"></a>6.3. Other Expressions
      </h2>
              
              
      <p>
                   All expressions not listed above are extended as follows.
                   This includes the following kinds of expressions:
                 
      </p>
              
      <ul>
         <li>
                        
            <p>Path expressions</p>
                      
         </li>
         <li>
                        
            <p>Concatenation expressions</p>
                      
         </li>
         <li>
                        
            <p>Function calls</p>
                      
         </li>
         <li>
                        
            <p>Range expressions</p>
                      
         </li>
         <li>
                        
            <p>Transform expressions</p>
                      
         </li>
         <li>
                        
            <p>Union, intersect, and except expressions</p>
                      
         </li>
         <li>
                        
            <p>Arithmetic, comparison, and logical expressions</p>
                      
         </li>
         <li>
                        
            <p>Ordered and unordered expressions</p>
                      
         </li>
         <li>
                        
            <p>Instance of, cast, castable, and treat expressions</p>
                      
         </li>
         <li>
                        
            <p>Validate expressions</p>
                      
         </li>
         <li>
                        
            <p>Extension expressions (pragmas)</p>
                      
         </li>
      </ul>
              
                <b>Composability Constraints:</b>
                    
      <p>(node)</p>
                  
                <b>Evaluation Order:</b>
                    
      <p>
                         Operand expressions are evaluated from left to right, bottom-up in the expression tree.
                       
      </p>
                  
              
              
      <hr>
      <p><b>Note:</b></p>
                
      <p>
                     Since insert, delete, replace and rename are updating expressions, their operands must be non-effecting,
                     such that the evaluation order is irrelevant
                     for them.
                   
      </p>
              
      <hr>
              
      <hr>
      <p><b>Note:</b></p>
                
      <p>
                     In transform expressions, since the modify clause must be updating (or vacuous) according to XQUF,
                     it must also be non-sequential. Furthermore, XQUF specifies that the return clause sees that the side-effect
                     of applying the PUL returned by the modify expression is visible to the return expression.
                   
      </p>
              
      <hr>
            
          
      <h1><a name="id-example"></a>7. Example
      </h1>
            
            
      <p>The following function returns true or false
                  according to whether its parameter is a known user name, and logs the event:
      </p>
            <pre>declare %ann:sequential function validate-and-log($username as xs:string)
    as xs:boolean {
  variable $log as document-node() := fn:doc("log.xml"); 

  variable $entry as element() :=
    &lt;access-attempt&gt;
      &lt;timestamp&gt;{fn:current-dateTime()}&lt;/timestamp&gt;
      &lt;user-name&gt;{$username}&lt;/user-name&gt;
      &lt;access-allowed/&gt;
    &lt;/access-attempt&gt; ;

  variable  $result as xs:boolean;

  if ($username = doc("users.xml")/current-users/user/name )
  then {
    replace value of node $entry/access-allowed with "Yes";
    $result := true();
  } else {
    replace value of node $entry/access-allowed with "No";
   $result := false();
  }
  
  insert node $entry as last into $log; 
  
  fn:put($log, "log.xml"); 
  
  $result
} 
</pre>
          <h1><a name="id-extra-grammatical"></a>8. Extra-Grammatical Constraints
      </h1>
            
            
      <p>Although the grammar allows syntactically an empty program, this is now allowed.</p>
            
      <p>A program must consist of at least one statement, or at least an expression.</p>
          
      <h1><a name="id-lookahead"></a>9. Alternative simplified grammar for LL-Parsers
      </h1>
          
          
      <p>For implementors using LL-parsers, the grammar described in this specification (which is LR(1)) needs
               an arbitrary lookahead (as opposed to a lookahead of 1 for LR-parsers).
               This arbitrary lookahead can be removed
             by using a subset of this proposal specified by the following changes. This makes the grammar LL(2).
      </p>
          
      <p>In a nutshell, block expressions are not available, and statements that could be mistaken for the beginning of
               an expression (with a lookahead of 2) need to be put in block statements.
               This happens in function bodies, node constructors and block expressions.
      </p>
          <pre>
[unchanged] PrimaryExpr ::= /* as in XQuery 3.0, no BlockExpr */
      Literal
  |   VarRef
  |   ParenthesizedExpr
  |   ContextItemExpr
  |   FunctionCall
  |   OrderedExpr
  |   UnorderedExpr
  |   Constructor
  |   FunctionItemExpr

Statement ::= Statement1 | Statement2

Statement1 :=
   AssignStatement
 | BlockStatement
 | BreakStatement
 | ContinueStatement
 | ExitStatement
 | VarDeclStatement
 | WhileStatement

Statement2 :=
   ApplyStatement
 | FLWORStatement
 | IfStatement
 | SwitchStatement
 | TryCatchStatement
 | TypeswitchStatement
 
StatementsAndOptionalExpr ::= Statements1 Expr?

Statements1 := Statement1*
 
    </pre>
        <hr>
      <h1>Complete Grammar</h1>
      <h2>Grammar Proposal</h2>
      (Non-terminals without a rule correspond to those, unchanged, in XQuery 3.0/XQuery Update 1.0)
      
      <h3>New query body for main modules</h3><pre>
0 - <a name="MainModule" class="ext">MainModule</a> ::= <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Prolog" class="new">Prolog</a> <a href="Program" class="new">Program</a>
    
1 - <a name="Program" class="ext">Program</a> ::= <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a>
    </pre><h3>Mixing Expressions and Statements</h3><pre xml:space="preserve">
          
2 - <a name="Statements" class="new">Statements</a> ::= <a href="#Statement" class="new">Statement</a>*
    
          
3 - <a name="StatementsAndExpr" class="new">StatementsAndExpr</a> ::= <a href="#Statements" class="new">Statements</a> <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a>
    
          
4 - <a name="StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> ::= <a href="#Statements" class="new">Statements</a> <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a>?
    
      </pre><h3>Statements</h3><pre xml:space="preserve">
          
5 - <a name="Statement" class="new">Statement</a> ::=
      <a href="#ApplyStatement" class="new">ApplyStatement</a>
    | <a href="#AssignStatement" class="new">AssignStatement</a>
    | <a href="#BlockStatement" class="new">BlockStatement</a>
    | <a href="#BreakStatement" class="new">BreakStatement</a>
    | <a href="#ContinueStatement" class="new">ContinueStatement</a>
    | <a href="#ExitStatement" class="new">ExitStatement</a>
    | <a href="#FLWORStatement" class="new">FLWORStatement</a>
    | <a href="#IfStatement" class="new">IfStatement</a>
    | <a href="#SwitchStatement" class="new">SwitchStatement</a>
    | <a href="#TryCatchStatement" class="new">TryCatchStatement</a>
    | <a href="#TypeswitchStatement" class="new">TypeswitchStatement</a>
    | <a href="#VarDeclStatement" class="new">VarDeclStatement</a>
    | <a href="#WhileStatement" class="new">WhileStatement</a>
    

          
6 - <a name="ApplyStatement" class="new">ApplyStatement</a> ::= <a href="#ExprSimple" class="new">ExprSimple</a> ";"
    

          
7 - <a name="AssignStatement" class="new">AssignStatement</a> ::= "$" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-VarName" class="un">VarName</a> ":=" <a href="#ExprSingle" class="ext">ExprSingle</a> ";"
    

          
8 - <a name="BlockStatement" class="new">BlockStatement</a> ::= "{" <a href="#Statements" class="new">Statements</a> "}"
    

          
9 - <a name="BreakStatement" class="new">BreakStatement</a> ::= "break" "loop" ";"
    

          
10 - <a name="ContinueStatement" class="new">ContinueStatement</a> ::= "continue" "loop" ";"
    

          
11 - <a name="ExitStatement" class="new">ExitStatement</a> ::= "exit" "returning" <a href="#ExprSingle" class="ext">ExprSingle</a> ";"
    

          
12 - <a name="FLWORStatement" class="new">FLWORStatement</a> ::= <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-InitialClause" class="un">InitialClause</a> <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-IntermediateClause" class="un">IntermediateClause</a>* <a href="#DoStatement" class="new">ReturnStatement</a>
    
          
13 - <a name="ReturnStatement" class="new">ReturnStatement</a> ::= "return" <a href="#Statement" class="new">Statement</a>
    

          
14 - <a name="IfStatement" class="new">IfStatement</a> ::= "if" "(" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a> ")" "then" <a href="#Statement" class="new">Statement</a> "else" <a href="#Statement" class="new">Statement</a>
    

          
15 - <a name="SwitchStatement" class="new">SwitchStatement</a> ::= "switch" "(" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a> ")" <a href="#SwitchCaseStatement" class="new">SwitchCaseStatement</a>+ "default" "return" <a href="#Statement" class="new">Statement</a>
    
          
16 - <a name="SwitchCaseStatement" class="new">SwitchCaseStatement</a> ::= ("case" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-SwitchCaseOperand" class="un">SwitchCaseOperand</a>)+ "return" <a href="#Statement" class="new">Statement</a>
    

          
17 - <a name="TryCatchStatement" class="new">TryCatchStatement</a> ::= "try" <a href="#BlockStatement" class="new">BlockStatement</a> ("catch" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-CatchErrorList" class="un">CatchErrorList</a> <a href="#BlockStatement" class="new">BlockStatement</a>)+
    

          
18 - <a name="TypeswitchStatement" class="new">TypeswitchStatement</a> ::= "typeswitch" "(" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a> ")" <a href="#CaseStatement" class="new">CaseStatement</a>+ "default" ("$" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-VarName" class="un">VarName</a>)? "return" <a href="#Statement" class="new">Statement</a>
    
          
19 - <a name="CaseStatement" class="new">CaseStatement</a> ::= "case" ("$" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-VarName" class="un">VarName</a> "as")? <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-SequenceType" class="un">SequenceType</a> "return" <a href="#Statement" class="new">Statement</a>
    

          
20 - <a name="VarDeclStatement" class="new">VarDeclStatement</a> ::= ("local" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Annotation" class="un">Annotation</a>*)? "variable" "$" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-VarName" class="un">VarName</a> <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-TypeDeclaration" class="un">TypeDeclaration</a>? (":=" <a href="#ExprSingle" class="ext">ExprSingle</a>)?
    ("," "$" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-VarName" class="un">VarName</a> <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-TypeDeclaration" class="un">TypeDeclaration</a>? (":=" <a href="#ExprSingle" class="ext">ExprSingle</a>)?)* ";"
    

          
21 - <a name="WhileStatement" class="new">WhileStatement</a> ::= "while" "(" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a> ")" <a href="#Statement" class="new">Statement</a>
    
      </pre><h3>Expressions</h3>
      (Separating control-flow expressions)
      <pre>
22 - <a name="ExprSingle" class="ext">ExprSingle</a> ::=
      <a href="#ExprSimple" class="new">ExprSimple</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-FLWORExpr" class="un">FLWORExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-IfExpr" class="un">IfExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-SwitchExpr" class="un">SwitchExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-TryCatchExpr" class="un">TryCatchExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-TypeswitchExpr" class="un">TypeswitchExpr</a>
    
23 - <a name="ExprSimple" class="new">ExprSimple</a> ::=
      <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-QuantifiedExpr" class="un">QuantifiedExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-OrExpr" class="un">OrExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-update-10/#prod-xquery-InsertExpr" class="up">InsertExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-update-10/#prod-xquery-DeleteExpr" class="up">DeleteExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-update-10/#prod-xquery-RenameExpr" class="up">RenameExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-update-10/#prod-xquery-ReplaceExpr" class="up">ReplaceExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-update-10/#prod-xquery-TransformExpr" class="up">TransformExpr</a>    </pre>
      (Direct element constructors)
      <pre>
24 - <a name="CommonContent" class="ext">CommonContent</a> ::= <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-PredefinedEntityRef" class="un">PredefinedEntityRef</a> | <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-CharRef" class="un">CharRef</a> | "{{" | "}}" | "{" <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> "}"
</pre>
      (Computed element constructors)
      <pre>
25 - <a name="ContentExpr" class="ext">ContentExpr</a> ::= <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a>

26 - CompDocConstructor ::= "document" "{" <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> "}"

27 - CompAttrConstructor ::= "attribute" (<a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-EQName" class="un">EQName</a> | ("{" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a> "}")) "{" <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> "}"

28 - CompPIConstructor ::= "processing-instruction" (<a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-NCName" class="un">NCName</a> | ("{" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Expr" class="un">Expr</a> "}")) "{" <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> "}"

29 - CompCommentConstructor ::= "comment" "{" <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> "}"
    </pre>
      (Block expression)
      <pre>
30 - <a name="PrimaryExpr" class="ext">PrimaryExpr</a> ::=
      <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Literal" class="un">Literal</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-VarRef" class="un">VarRef</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-ParenthesizedExpr" class="un">ParenthesizedExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-ContextItemExpr" class="un">ContextItemExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-FunctionCall" class="un">FunctionCall</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-OrderedExpr" class="un">OrderedExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-UnorderedExpr" class="un">UnorderedExpr</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-Constructor" class="un">Constructor</a>
  |   <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-FunctionItemExpr" class="un">FunctionItemExpr</a>
  |   <a href="#BlockExpr" class="new">BlockExpr</a>
    
31 - <a name="BlockExpr" class="new">BlockExpr</a> ::= "{" <a href="#StatementsAndExpr" class="new">StatementsAndExpr</a> "}
    </pre><h3>Function body</h3><pre>
32 - <a name="FunctionDecl" class="ext">FunctionDecl</a> ::= "function" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-EQName" class="un">EQName</a> "(" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-ParamList" class="un">ParamList</a>? ")"
                      ("as" <a href="http://www.w3.org/TR/xquery-30/#doc-xquery30-SequenceType" class="un">SequenceType</a>)? ("{" <a href="#StatementsAndOptionalExpr" class="new">StatementsAndOptionalExpr</a> "}" | "external"))
    </pre></body>
</html>
