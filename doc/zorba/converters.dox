/** \page converters Conversion Functions

<ul>
   <li> Table of Contents
   <ul>
     <li> \ref conv_intro
     <li> \ref conv_json
     <ul>
       <li> \ref json_namespace
       <li> \ref json_signatures
       <ul>
        <li> \ref json_parse
        <li> \ref json_serialize
       </ul>
       <li> \ref json_in_serializer
     </ul>
     <li> \ref conv_json_ml
     <ul>
       <li> \ref json_ml_namespace
       <li> \ref json_ml_signatures
       <ul>
        <li> \ref json_ml_parse
        <li> \ref json_ml_serialize
       </ul>
       <li> \ref json_ml_in_serializer
     </ul>
    <li> \ref appendix_converters
   </ul>
 </ul>

\section conv_intro 1 Introduction
In the XQuery specification, XQuery is described as a language capable of expressing queries on XML data.
This makes XQuery the perfect choice for a data processing language on the Web because XML is widely used there.
However, there are also some other data formats presents on the Web.
For example, <a href="http://www.json.org/" target="_blank">JSON</a> (JavaScript Object Notation) is the most common data format for applications which are written in JavaScript.

Zorba implements a set of functions that opens XQuery developers the door to processing other data formats (like JSon)
In this document, we describe these functions in detail.


\section conv_json 2 JSON
JSon is a lightweight hierachical data-interchange format.
Like XML, it is easy for humans to read and write. Moreover, it is easy for machines to parse and generate.

In order to process JSON with XQuery, Zorba implements a mapping between JSON and XML that was proposed by John Snelson in his article <a href="http://snelson.org.uk/archives/2008/02/parsing_json_in.php#more" target="_blank">Parsing JSON into XQuery</a>.

In this article, he describes the following recursive mapping declarations.

<table border="1" cellpadding="0" cellspacing="0">
<tr>
  <td><b>JSON</b></td>
  <td><b>type(JSON)</b></td>
  <td><b>toXML(JSON)</b></td>
</tr>
<tr>
  <td>JSON</td>
  <td>N/A</td>
  <td><json type="type(JSON)">toXML(JSON)</json></td>
</tr>
<tr>
  <td>{ "key1": value1, "key2": value2 }</td>
  <td>object</td>
  <td>\<pair name="key1" type="type(value1)">toXML(value1)</pair><pair name="key2" type="type(value2)">toXML(value2)</pair></td>
</tr>
<tr>
  <td>[ value1, value2 ]</td>
  <td>array</td>
  <td>\<item type="type(value1)">toXML(value1)</item><item type="type(value2)">toXML(value2)\</item></td>
</tr>
<tr>
  <td>"value"</td>
  <td>string</td>
  <td>value</td>
</tr>
<tr>
  <td>number</td>
  <td>number</td>
  <td>number</td>
</tr>
<tr>
  <td>true / false</td>
  <td>boolean</td>
  <td>true / false</td>
</tr>
<tr>
  <td>null</td>
  <td>null</td>
  <td>empty</td>
</tr>
</table>

Zorba implements this mapping in two functions: the <em>parse</em> function is used for parsing a sequence of JSON strings into a sequence of elements, the <em>serialize</em> function implements the reverse process, i.e. serializing a sequence of elements into a sequence of valid JSON strings.
In the following, we describe those functions and give some examples.

\subsection json_namespace 2.1 JSon Module Namespace

The <em>parse</em> and <em>serialize</em> functions are available in the JSON module <tt>"http://www.zorba-xquery.com/zorba/json-functions"</tt>.
In order to use this functionality, you have to import this module in the prolog of your XQuery module as follows:

\code
  import module namespace zorba-json = "http://www.zorba-xquery.com/zorba/json-functions";
\endcode

\subsection json_signatures 2.2 JSon Functions

\subsection json_parse 2.2.1 Parsing JSON into the XQuery Data Model (XDM).

The parse function can be used for parsing a sequence of valid JSON strings into a sequence of XDM elements.

\code
  declare function zorba-json:parse($text as xs:string*) as xs:element*
\endcode

The function raises the API0060 error if any of the strings passed as parameter are not a valid JSON (see \ref appendix_converters).


The following XQuery (taken from John Snelson's article mentioned above) demonstrates the usage of the parse function.

\include parse3.xq

For example, executing this query and serializing its result to XML yields the following:

\code
  <json type="object">
    <pair name="firstName" type="string">John</pair>
    <pair name="lastName" type="string">Smith</pair>
    <pair name="address" type="object">
      <pair name="streetAddress" type="string">21 2nd Street</pair>
      <pair name="city" type="string">New York</pair>
      <pair name="state" type="string">NY</pair>
      <pair name="postalCode" type="number">10021</pair>
    </pair>
    <pair name="phoneNumbers" type="array">
      <item type="string">212 732-1234</item>
      <item type="string">646 123-4567</item>
    </pair>
  </json>
  <json type="object">
    <pair name="firstName" type="string">John</pair>
    <pair name="state" type="null"/>
    <pair name="bool" type="boolean">true</pair>
    <pair name="numbers" type="array">
      <item type="number">1</item>
      <item type="number">2</item>
      <item type="number">3</item>
    </pair>
    <pair name="address" type="object">
      <pair name="streetAddress" type="string">21 2nd Street</pair>
      <pair name="state" type="null"/>
      <pair name="postalCode" type="number">10021</pair>
      <pair name="literals" type="array">
        <item type="boolean">true</item>
        <item type="boolean">false</item>
        <item type="null"/>
      </pair>
      <pair name="delivery" type="object">
        <pair name="streetAddress" type="string">StreetName</pair>
        <pair name="city" type="string">CityName</pair>
        <pair name="state" type="string">StateName</pair>
      </pair>
    </pair>
    <pair name="strings" type="array">
      <item type="string">one</item>
      <item type="string">two</item>
      <item type="string">three</item>
      <item type="string">four</item>
    </pair>
  </json>
\endcode

\subsection json_serialize 2.2.2 zorba-json:serialize

The serialize function takes a sequence of elements as parameter and transforms each element into a valid JSON string according to the mapping depicted above.
The function delaration is as follows:

\code
  declare function zorba-json:serialize($xml as xs:element*) as xs:string*
\endcode

There are two error scenarios: (1) If the passed elements do not have a valid JSON structure, the API0061 error is raised, (2) if the passed parameter is not an element, the API0062 error is raised (also see \ref appendix_converters).

In the following, we demonstrate the use of the JSON serialize function.

\include serialize2.xq

\subsection json_in_serializer 2.3 The JSON Serialization Method
The JSON serialization process is also implemented in the serializer component of Zorba.
This is similar to using any of the serialization methods defined in the "XSLT 2.0 and XQuery 1.0 Serialization" specification at http://www.w3.org/TR/xslt-xquery-serialization/.
This method can be triggered by the Zorba command line utility or by any of the Zorba programming APIs.

In the following three examples, we use use the %Zorba command line utility to serialize the result of a query generate JSON by using the <em>--serialization-parameter,-z</em> option.

In contrast to the serialize function described above, the JSON serializer has to be passed a single element node adhering to the structure presented above (see \ref conv_json).
This is because a valid JSON document is required to have a single root object.
If a query returns a sequence with more then one element, the API0066 error is raised (see \ref appendix_converters and Example 3 below).

<b>Example 1:</b>
\verbatim
zorba -q "<json type='object'><pair name='firstName' type='string'>John</pair></json>" -z method=json
\endverbatim

<b>Result of Example 1:</b>
\verbatim
{"firstName": "John"}
\endverbatim

<b>Example 2:</b>
\verbatim
zorba -q "<ul>1</ul>" -z method=json
\endverbatim

<b>Output of Example 2:</b>
\verbatim
[API0061] Could not serialize element with string representation {1}. Error: {This is not a Json element.}
\endverbatim

<b>Example 3</b>
\verbatim
zorba -q "(<json type='object'><pair name='firstName' type='string'>John</pair></json>, 2)" -z method=json
\endverbatim

<b>Output of Example 3:</b>
\verbatim
{"firstName": "John"}
[API0066] Cannot serialize a sequence if 'json' or 'jsonml' method was selected.
\endverbatim

\section conv_json_ml 3 JsonML
<a href="http://jsonml.org" target="_blank">JsonML</a> (JSON Markup Language) is an application of the <a href="http://www.json.org/" target="_blank">JSON</a> (JavaScript Object Notation) format.
The purpose of JsonML is to provide a compact format for transporting XML-based markup as JSON.
In contrast to the JSON mapping depicted above (see \ref conv_json), JsonML allows a losslessly conversion back and forth.

Zorba implements the JsonML structure defined at http://www.ibm.com/developerworks/library/x-jsonml/#N10138.
Analogoulsy to the JSON conversion, this functionality is implemented in a parse and serialize function, respectively.

More details about <a href="http://jsonml.org" target="_blank">JsonML</a> can be found in the following article: <a href="https://www.ibm.com/developerworks/library/x-jsonml/" target="_blank">Get to know JsonML</a>.


\subsection json_ml_namespace 3.1 JsonML Module Namespace

The <em>parse</em> and <em>serialize</em> functions are available in the JsonML moudle <tt>"http://www.zorba-xquery.com/zorba/json-ml-functions"</tt>.

\code
  import module namespace zorba-json-ml = "http://www.zorba-xquery.com/zorba/json-ml-functions";
\endcode

\subsection json_ml_signatures 3.2 JsonML Functions

\subsection json_ml_parse 3.2.1 Parising JsonML into the XQuery Data Model (XDM) 

The parse function can be used to parse a sequence of valid JSON strings to XDM elements.
It is declared as follows

\code
  declare function zorba-json-ml:parse($text as xs:string*) as xs:element*
\endcode

The API0063 error is raised if one of the strings that are passed as parameters are not valid Json (also see \ref appendix_converters).


\subsection ex_json_ml_parse Example:
\include jsonml_parse1.xq

\subsection res_json_ml_parse Result:
\code
<ul>
  <li>true</li>
  <li href="driving.html" title="Driving">Second item</li>
  <li/>
  <li>-1.4E+13</li>
</ul>
<table class="maintable">
  <tr class="odd">
    <th>Situation</th>
    <th>Result</th>
  </tr>
  <tr class="even">
    <td><a href="driving.html" title="Driving">Driving</a></td>
    <td>Busy</td>
  </tr>
</table>
\endcode


\subsection json_ml_serialize 3.2.2 zorba-json-ml:serialize

The serialize function takes a sequence of elements and transforms each of them into a sequence of JsonML strings.

\code
  declare function zorba-json-ml:serialize($xml as xs:element*) as xs:string*
\endcode

If one of the passed elements does not have a valid JsonML structure, the API0064 error is raised.
If the passed parameter is not an element, the API0065 error is raised.

\subsection ex_json_ml_serialize Example:
\include jsonml_serialize1.xq

\subsection res_json_ml_parse Result:
\code
["ul",
  ["li", "true"],
  ["li",{"href":"driving.html"}, {"title":"Driving"}, "Second item"],
  ["li"],
  ["li", "-1.4E+13"]
]
["table", {"class":"maintable"},
  ["tr", {"class":"odd"},
    ["th", "Situation"],
    ["th", "Result"]
  ],
  ["tr", {"class":"even"},
    ["td", ["a", {"href":"driving.html"}, {"title":"Driving"}, "Driving"]],
    ["td", "Busy"]
  ]
]
\endcode

\subsection json_ml_note Note:
Calling <b>zorba-json-ml:serialize(zorba-json-ml:parse($some_string))</b> will not always produce <b>$some_string</b>. \n
This is caused by the fact that <b>jsonml:serialize</b> does dot know the exact type of the JSON value (true, false, null, numbers) and treats them all as strings. \n
Here are some possible cases where this can happen:

\code
  import module namespace jsonml = "http://www.zorba-xquery.com/zorba/json-ml-functions";

  jsonml:serialize(jsonml:parse(('[ "ul",
                  [ "li", true],
                  [ "li", null],
                  [ "li", -14e12]
                  ]')))
\endcode

will output the following result:

\code
["ul",
  ["li", "true"],
  ["li"],
  ["li", "-1.4E+13"]
]
\endcode

\subsection json_ml_in_serializer 3.3 The JsonML Serialization Method

The JsonML serialization functionality is also implemented in the serializer component of Zorba.

In the following, we give some examples that demonstrate this using the zorba command line utility using the <b>--serialization-parameter,-z</b> option. \n
Please note that the result of query has to be a sequence with one element.

Here are some examples: 

Note that is you pass a sequence of items, only the first item in the sequence will be processed and then an error is raised API0066 (see \ref appendix_converters).\n See example 3 below: 

<b>Example 1:</b>
\verbatim
zorba -q "<ul>1</ul>" -z method=jsonml
\endverbatim

<b>Output of Example 1:</b>
\verbatim
["ul", "1"]
\endverbatim

<b>Example 2</b>
\verbatim
zorba -q "<?pi content?>" -z method=jsonml
\endverbatim

<b>Output of Example 2:</b>
\verbatim
[API0064] Could not serialize element with string representation {content}. Error: {This is not a JsonML element.}
\endverbatim

<b>Example 3</b>
\verbatim
zorba -q "(<ul>1</ul>, <?pi content?>)" -z method=jsonml
\endverbatim

<b>Output of Example 3:</b>
\verbatim
["ul", "1"]
[API0066] Cannot serialize a sequence if 'json' or 'jsonml' method was selected.
\endverbatim

\section appendix_converters Appendix A:  Error codes

  API0060 - API0060_CONV_JSON_PARSE - is raised if the string could not be parsed.<br/>
  API0061 - API0061_CONV_JSON_SERIALIZE - is raised if the element could not be serialized.<br/>
  API0062 - API0062_CONV_JSON_PARAM - is raised is the passed param is not an element.<br/>
  API0063 - API0063_CONV_JSON_ML_PARSE - is raised if the string could not be parsed.<br/>
  API0064 - API0064_CONV_JSON_ML_SERIALIZE - is raised if the element could not be serialized.<br/>
  API0065 - API0065_CONV_JSON_ML_PARAM - is raised is the passed parameter is not an element.<br/>
  API0066 - API0066_JSON_SEQUENCE_CANNOT_BE_SERIALIZED - Cannot serialize a sequence with more than one element if the 'json' or 'jsonml' method was selected.

*/
