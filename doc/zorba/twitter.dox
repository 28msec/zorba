/** \page twitter Implementing a command line Twitter client in XQuery

\section twitter_instruction Introduction

This is a tutorial which explains how to implement a simple Twitter client for
the command line. Some basic XQuery knowledge is needed for this tutorial.
This tutorial will introduce you into the following techniques:
<ul>
  <li>Writing an external module for Zorba using C++</li>
  <li>Using XQuery scripting</li>
  <li>Using introspection and reflection in Zorba</li>
  <li>Very basic usage of XQuery full text</li>
  <li>Using Zorbas OAuth client</li>
  <li>Using the EXPath http-client to implement a client for a RESTFul web service</li>
  <li>How to use collections (i.e. the XQuery Data Definition Falcility XQDDF)</li>
</ul>

The demonstrated Twitter client is a very simple command line client that provides the user
with the following features:

<ul>
  <li>She can lookup the 20 last tweets with typing the command "tweet"</li>
  <li>She can make a tweet persistent by "liking" the tweet. I.e. typing "like <TWEET_ID>"</li>
  <li>She can translate a tweet into nearly any language by typing "translate <LANG_CODE> <TWEET_ID>"</li>
  <li>She can search the liked tweets with the search command - this will use XQuery full text</li>
</ul>

\section twitter_api_key Get your twitter API keys

Before you can get started you need to get an API key from twitter - you'll need that to make
REST calls to twitter. So go to <a href="https://dev.twitter.com/apps/new">https://dev.twitter.com/apps/new</a>,
log in (or first create an account if you don't have one) and you will be presented to a form you have to fill out:

\image html twitter_register_app.png

After you have created your app you will get presented to a page with all information you'll need to hack your
client. The information you will need, is the consumer-key and the consumer-secret (you can also get them later
by going to "My Applications" which you will find in a menu when you hover your mouse over your user name in the
upper right corner).

\image html twitter_keys.png

\section twitter_command_line_module Writing a module for handling the command line input/output

<b>note:</b> If you are not interested in implementing external modules, you can skip this section
and just use the code in the examples folder in your Zorba installation.

Since Zorba does not provide a module to handle input and output on the command line, we need to provide
this feature ourselves. Luckily this is very simple. All we have to do is to write a new module with three
functions and the implementation of them. One will be implemented directly in XQuery, the other one
in C++.

\subsection twitter_command_line_module_dir_structure The directory structure

First we build our directory structure. In principle we are very free how to do that, but here is the
probably simplest way described. A module can ship its own tests (not described here) and its own 
C++ implementation.

So start by creating a folder for the module (for example "commandline") and the following subfolders:

<ul>
  <li>commandline
    <ul>
      <li>src
        <ul>
          <li>commandline.xq.src</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

As you can see, it is just a directory named src and a directory named commandline.xq.src. Our new module will
be in a file called commandline.xq (in the "src" folder) and loookes like this:

\subsection twitter_command_line_module_xquery Writing the XQuery code for the module

\code
  module namespace cli = 'http://www.zorba-xquery.com/examples/commandline';
  
  declare namespace ann = "http://www.zorba-xquery.com/annotations";
  declare namespace ver = "http://www.zorba-xquery.com/options/versioning";
  
  declare option ver:module-version "1.0";
  
  declare variable $cli:endl as xs:string := "
  ";
  
  (:~
   : This functions blocks until the user has entered a line
   : on the command line and pressed enter.
   :
   : @return The entered line as a string.
   :)
  declare %ann:sequential function cli:get-line() as xs:string external;
  
  (:~
   : This functions prints the given string to the standard output file.
   :
   : @param $string The string to print.
   :)
  declare %ann:sequential function cli:print($string as xs:string) as empty-sequence() external;
  
  (:~
   : This functions prints the given string to the standard output file.
   : and appends a new line.
   :
   : @param $string The string to print.
   :)
  declare %ann:sequential function cli:print-line($string as xs:string) as empty-sequence() {
    cli:print(concat($string, $cli:endl));
  };
  
\endcode

So here we have our three functions. Since they all have side effects, they need to be declared
as sequential, which is done with the %ann:sequential annotation. The external keyword tells zorba
that a function is implemented outside of XQuery. Zorba will then try to find a implementation
of the function in a shared library file.

So in a next step we need to write the C++ implementation of our two external functions.

\subsection twitter_command_line_module_cxx_code Writing the C++ code for the module

Writing the C++ file is very easy. In our case we put everything in one file, but for more complex
modules you can just put several files in the ".xq.src" directory and the build system would link
everything together for you. So we just create a file named commandline.cpp in the src/commandline.xq.src
folder and fill it with the following content:

\code
  #include <iostream>
  
  #include <zorba/zorba.h>
  #include <zorba/external_module.h>
  #include <zorba/function.h>
  #include <zorba/empty_sequence.h>
  #include <zorba/singleton_item_sequence.h>
  
  using namespace zorba;
  
  namespace commandline {
    
    class CommandLineModule : public ExternalModule
    {
    private:
      ItemFactory* theFacory;
      ExternalFunction* thePrintFunction;
      ExternalFunction* theGetLineFunction;
    public:
      const static String COMMANDLINE_MODULE_NAMESPACE;
    public:
      CommandLineModule();
      ~CommandLineModule();
    public:
      virtual String getURI() const { return COMMANDLINE_MODULE_NAMESPACE; }
      virtual void destroy();
      virtual ExternalFunction* getExternalFunction(const String& localName);
    };
  
    class CommandLineFunction : public NonContextualExternalFunction
    {
    protected:
      CommandLineModule* theModule;
      ItemFactory* theFactory;
    public:
      CommandLineFunction(CommandLineModule* aModule, ItemFactory* aFactory)
      : theModule(aModule), theFactory(aFactory) {}
    };
    
    class PrintFunction : public CommandLineFunction
    {
    public:
      PrintFunction(CommandLineModule* aModule, ItemFactory* aFactory)
      : CommandLineFunction(aModule, aFactory) {}
    public:
      virtual String getLocalName() const { return "print"; }
      virtual String getURI() const { return CommandLineModule::COMMANDLINE_MODULE_NAMESPACE; }
      virtual ItemSequence_t
      evaluate(const ExternalFunction::Arguments_t& args) const;
    };
    
    class GetLineFunction : public CommandLineFunction
    {
    public:
      GetLineFunction(CommandLineModule* aModule, ItemFactory* aFactory)
      : CommandLineFunction(aModule, aFactory) {}
    public:
      virtual String getLocalName() const { return "get-line"; }
      virtual String getURI() const { return CommandLineModule::COMMANDLINE_MODULE_NAMESPACE; }
      virtual ItemSequence_t
      evaluate(const ExternalFunction::Arguments_t& args) const;
    };
    
    const String CommandLineModule::COMMANDLINE_MODULE_NAMESPACE = "http://www.zorba-xquery.com/examples/commandline";
    
    CommandLineModule::CommandLineModule()
    : theFacory(Zorba::getInstance(0)->getItemFactory()), thePrintFunction(new PrintFunction(this, theFacory)),
    theGetLineFunction(new GetLineFunction(this, theFacory))
    {
    }
    
    CommandLineModule::~CommandLineModule()
    {
      delete thePrintFunction;
      delete theGetLineFunction;
    }
    
    void CommandLineModule::destroy()
    {
      delete this;
    }
    
    ExternalFunction* CommandLineModule::getExternalFunction(const zorba::String &localName)
    {
      if (localName == "print")
        return thePrintFunction;
      else if (localName == "get-line")
        return theGetLineFunction;
      else
        return 0;
    }
    
    ItemSequence_t PrintFunction::evaluate(const ExternalFunction::Arguments_t &args) const
    {
      Iterator_t lIter = args[0]->getIterator();
      lIter->open();
      Item lItem;
      lIter->next(lItem);
      lIter->close();
      std::cout << lItem.getStringValue();
      return ItemSequence_t(new EmptySequence());
    }
    
    ItemSequence_t GetLineFunction::evaluate(const ExternalFunction::Arguments_t &args) const
    {
      std::string lInput;
      std::getline(std::cin, lInput);
      Item res = theFactory->createString(lInput.c_str());
      return ItemSequence_t(new SingletonItemSequence(res));
    }
    
  } //end of namespace commandline
  
  
  #ifdef WIN32                                                                                               
  #  define DLL_EXPORT __declspec(dllexport)                                                                 
  #else                                                                                                      
  #  define DLL_EXPORT __attribute__ ((visibility("default")))                                               
  #endif                                                                                                     
  
  extern "C" DLL_EXPORT zorba::ExternalModule* createModule() {                                              
    return new commandline::CommandLineModule();                                                                
  }
\endcode

That looks taff! But when you look at it more closely you will see, that it is actually quite easy
code. Let's start with the following lines:

\code
  #ifdef WIN32                                                                                               
  #  define DLL_EXPORT __declspec(dllexport)                                                                 
  #else                                                                                                      
  #  define DLL_EXPORT __attribute__ ((visibility("default")))                                               
  #endif                                                                                                     
  
  extern "C" DLL_EXPORT zorba::ExternalModule* createModule() {                                              
    return new commandline::CommandLineModule();                                                                
  }
\endcode

These tell the compiler to export a c function named "createModule" which will return
something of type "zorba::ExternalModule*". Zorba will use the dlopen() function to
load the shared library and will call exactly this module and bind the external module
you implemented in it's static context.

Whenever you implement a new module, you will copy and paste this method to one of your
.cpp files and just make sure to return an ExternalModule object you implemented. So as
you can see, all you have to do is to provide an implementation for the ExternalModule class
you can find in Zorbas public C++ API.

So first we derive from the ExternalModule class:

\code
    class CommandLineModule : public ExternalModule
    {
    private:
      ItemFactory* theFacory;
      ExternalFunction* thePrintFunction;
      ExternalFunction* theGetLineFunction;
    public:
      const static String COMMANDLINE_MODULE_NAMESPACE;
    public:
      CommandLineModule();
      ~CommandLineModule();
    public:
      virtual String getURI() const { return COMMANDLINE_MODULE_NAMESPACE; }
      virtual void destroy();
      virtual ExternalFunction* getExternalFunction(const String& localName);
    };
\endcode

So we have to implement three virtual methods:
<ul>
  <li>
    <em>getURI</em>, which just returns a string of the namespace of the module
    you are providing an implementation for.
  </li>
  <li>
    <em>destroy</em>, a method which will simply delete the module and all corresponding
    functions. This is needed, because on some operating systems (for example Windows),
    it is not allowed to delete a module which was allocated inside another shared library.
  </li>
  <li>
    <em>getExternalFunction</em> This method just returns an instance of ExternalFunction
    (another pure virtual class we have to implement) for a provided local name. This method
    will be called with for example "get-line" as argument and we have to make sure to return
    an implementation of ExternalFunction which can handle calls to our "get-line" function.
  </li>
</ul>

The implementation of the module class is trivial, so we won't look into it in detail. If you want
to implement your own module, you probably want to copy and paste this example and just change the
URI and the name of the classes and local names. 

More interesting are the two ExternalFunction classes we have. To make our live easier, we just started
by writing a generic subclass for all (i.e. both) our external functions:

\code
    class CommandLineFunction : public NonContextualExternalFunction
    {
    protected:
      CommandLineModule* theModule;
      ItemFactory* theFactory;
    public:
      CommandLineFunction(CommandLineModule* aModule, ItemFactory* aFactory)
      : theModule(aModule), theFactory(aFactory) {}
    };
\endcode

So as we can see this is just a class which holds the module and the item factory (which we need later to
produce a result in our implementation). It derives from NonContextualExternalFunction. Non-contextual means,
that we do not need access to the dynamic context. If you need access to it, you can derive from ContextualFunction
(the virtual method evaluate will then just have a slightly different signature).

Let's look into the implementation of the get-line function:

\code
    class GetLineFunction : public CommandLineFunction
    {
    public:
      GetLineFunction(CommandLineModule* aModule, ItemFactory* aFactory)
      : CommandLineFunction(aModule, aFactory) {}
    public:
      virtual String getLocalName() const { return "get-line"; }
      virtual String getURI() const { return CommandLineModule::COMMANDLINE_MODULE_NAMESPACE; }
      virtual ItemSequence_t
      evaluate(const ExternalFunction::Arguments_t& args) const;
    };
\endcode

So this is again a class with three methods we have to implement:

<ul>
  <li>
    <em>getLocalName</em> just returns the local name of the function - so in our example
    just the string "get-line".
  </li>
  <li>
    <em>getURI</em> has to return the namespace of the module the function is in - so the same string
    than we return in the getURI method of the ExternalModule implementation.
  </li>
  <li>
    <em>evaluate</em> is the method which gets called whenever the corresponding XQuery function gets
    called. So here the magic has to happen.
  </li>
</ul>

Phew, nearly done. Now we just need to implement the logic of the module...

So let's first look into the evaluate method of "get-line":

\code
    ItemSequence_t GetLineFunction::evaluate(const ExternalFunction::Arguments_t &args) const
    {
      std::string lInput;
      std::getline(std::cin, lInput);
      Item res = theFactory->createString(lInput.c_str());
      return ItemSequence_t(new SingletonItemSequence(res));
    }
\endcode

Since "get-line" does not take any arguments we can ignore the "args" argument for this evaluate
method. So first we just get a line from std::cin with the getline function from the STL - not a
lot of magic here. Then we use the item factory to create a string item. Internally everything is
an item and we can use the item factory to create such items. Since our item needs to be a string,
we use the <em>createString</em> method in the item factory.

As a last step, we create a item sequence and return it. You can implement your own item sequences
in case you want to do lazy evaluation. But since we only want to return one item, we can just use
the SingeltonItemSequence which is provided by Zorbas API.

The print implementation is not much more complicated:

\code
    ItemSequence_t PrintFunction::evaluate(const ExternalFunction::Arguments_t &args) const
    {
      Iterator_t lIter = args[0]->getIterator();
      lIter->open();
      Item lItem;
      lIter->next(lItem);
      lIter->close();
      std::cout << lItem.getStringValue();
      return ItemSequence_t(new EmptySequence());
    }
\endcode

In XQuery every argument can be a sequence. In the API this means that we have an array of
iterators, where every iterator is one argument. We only have one argument and our declaration
makes sure, that this argument will have exactly one item. So we are safe to just get the first
iterator, open it, get one item (which will be a string item, since the function only takes a
string as an argument) and then close it again.

We than just print the string we got to the standard output. We still need to return a sequence,
but our function returns an empty sequence. So we just use EmptySequence provided by the Zorba API.

That's it! No, not quite - we still need to compile the C++ code and install everything into Zorbas
module directory...

\subsection twitter_command_line_module_cmake Using cmake to build an external module

Now that we have implemented our module we need to build them. Luckily this is not a hard task, if
we use CMake. What you need to build the module is:

<ul>
  <li><a href="http://www.cmake.org/">CMake</a></li>
  <li>On Windows Visual Studio (you can download Visual Studio 2010 Express
      <a href="http://www.microsoft.com/visualstudio/en-us/products/2010-editions/express"></a>)</li>
  <li>On Linux and Mac OS X gcc or clang</li>
</ul>

In our base directory (here called commandline) we create a new file called CMakeLists.txt with the following
content:

\code
  CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
  
  PROJECT (commandline)
  ENABLE_TESTING ()
  INCLUDE (CTest)
  
  LIST (APPEND CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake_modules")
  
  FIND_PACKAGE (Zorba REQUIRED HINTS "${ZORBA_BUILD_DIR}")
  INCLUDE ("${Zorba_USE_FILE}")
  
  ADD_SUBDIRECTORY("src")
  SETUP_EXTERNAL_MODULE()
  DONE_DECLARING_ZORBA_URIS()
\endcode

In the "src" directory we include another CMakeLists.txt file with the following content:

\code
  # all external module libraries are generated in the directory
  # of the corresponding .xq file
  DECLARE_ZORBA_MODULE (URI "http://www.zorba-xquery.com/examples/commandline" VERSION 1.0 FILE "commandline.xq")
  
  # QQQ This should probably be part of ZorbaModule.cmake
  INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
          DESTINATION include/zorba
          FILES_MATCHING
          PATTERN "*.svn" EXCLUDE
          PATTERN "*.xq.src" EXCLUDE
          PATTERN "*.xsd"
          PATTERN "*.xq")
  
  MESSAGE(STATUS "End modules")
\endcode

That's already it for configuring the build. If you write another module, you will just need to change the URI to
the namespace URI of your module and the filename "commandline.xq" to whatever name you give to your file.

To build the module we just need to create a directory (we call it "build") and then compile it. Under Linux/Mac OS X
you would now compile and install the module with the following commands (make sure to change your working directory
to the base directory if the module):

\code
  mkdir build
  cd build
  cmake -DCMAKE_BUILD_TYPE=Release ..
  make
  make install
\endcode

If you need to debug your module just set the build type to "Debug" instead.

On Windows the following commands will do the job (make sure to enter them in the Visual Studio Command Prompt, which
you will find in the start menu in the Visual Studio folder):

\code
  mkdir build
  cmake -G "NMake Makefiles" -DCMAKE_BUILD_TYPE=Release ..
  nmake
  nmake install
\endcode

If you want to develop your module with Visual Studio you also can create a Visual Studio solution with the following
commands:

\code
  mkdir build
  cmake -G "Visual Studio 10" ..
\endcode

CMake will then generate a Visual Studio solution for you (note that a lot of IDEs - like Xcode - are supported by CMake - just type cmake
without any arguments to get a list of all supported build systems).

Now that we wrote our external module we can start hacking XQuery.

\section twitter_xquery Writing the XQuery code

\subsection twitter_xquery_main Our main query

Since we are writing a command line application, it would be handy to just execute the program without having to call zorba explicitly - like
you would do with a bash script. Under Windows you would do that by writing a batch file (we assume that zorba.exe is in your PATH here):

\code
  zorba -f -q twitter-plain.xq
\endcode

Under Linux we can put the XQuery code inside the bash script. To make our life easier, we will create a main function in a module and in the
main query we will just call this function. So twitter.xq will look like the following:

\code
  import module namespace main = 'http://www.zorba-xquery.com/examples/twitter/main';
  
  main:main()
\endcode

Under Windows you will just write this twitter.xq file - under Linux and Mac OS X we will call the file just "twitter" (so that it looks like
an executable) and fill it with this bash script:

\code
  #!/bin/sh 
  exec /Users/mpilman/work/zorba/build/bin/zorba -r -q "`tail +4 "$0"`"
  #!
  import module namespace main = 'http://www.zorba-xquery.com/examples/twitter/main';
  main:main()
\endcode

After that we just give it executable rights:

\code
  chmod +x twitter
\endcode

and we have our main query.

\subsection twitter_xquery_modules_general Writing the modules

So now we want to create our first module (the twitter application will have three of them). We already have the
import to it but we still need to write the module. First we briefly need to understand how Zorba will look for this
module. Zorba will first transform the namespace URI to a relative path with the following algorithm:

<ol>
  <li>The domain (authority) component of the URI is reversed, and then transformed into a path notation separated by forward slashes: www.example.com =&gt; com/example/www</li>
  <li>The path component of the URI is appended: /modules/utils</li>
  <li>If the path component ends with a trailing slash, the word "index" will be appended</li>
  <li>Finally, an appropriate filename extension will be added if it is not already present. For modules, the suffix is .xq, and for schemas, the suffix is .xsd.</li>
</ol>

Our module namespaces will all have the form "http://www.zorba-xquery.com/examples/twitter/&lt;something&gt;". So we need to create a directory structure (for simplicity in the same
directory where our twitter.xq file is) "com/zorba-xquery/www.examples/twitter/". If the "com" directory is a direct subdirectory of your current working directory,
Zorba should find the modules, since "." is by default in the module uri. Otherwise you need to tell Zorba where to look for it by either setting the enivronment variable
ZORBA_MODULE_PATH or by passing it with the "--module_path" command line argument.

We assume that the user will always have the working directory where the main XQuery file is for simplicity (but you already can see, where you could improve the application).

\subsection twitter_xquery_main_module Writing the main module

So now we can create a file "main.xq" in our subdirectory we just created. We simply start (as alwasy when we write a module) by defining
the module namespace URI:

\code
  module namespace main = 'http://www.zorba-xquery.com/examples/twitter/main';  
\endcode

The function we want to call is named main. So we need to create this function. The function runs a loop where it waits for user
input and then executes the command. We can only do this with scripting, so we need to mark the function as scripting. Since some
function we will call are also nondeterministic (side-effect free but can return another result for every call - for example http GET
has this kind of behavior), we also need to mark it as nondeterministic. In XQuery this is done with an annotation, so our function
declaration will look like follows:

\code
  declare %ann:sequential %ann:nondeterministic function main:main()
  {
  };
\endcode

But "ann" is a namespace prefix and we did not define what it should mean. So we need to define this by adding the following line right
before the function:

\code
  declare namespace ann = "http://www.zorba-xquery.com/annotations";
\endcode

Now we have our function, but it does not do anything so far. What we want the function to do is:

<ul>
  <li>Authenticate the user at Twitter</li>
  <li>Since we want persistency we must initialize our collections we use</li>
  <li>Then we want a while loop, which waits till a command tells us to quit and inside the loop it does:</li>
  <ul>
    <li>Print a prompt</li>
    <li>Wait for a user input and tokenize it to command and arguments</li>
    <li>Look for an XQuery function which should be called</li>
    <li>Print an error if no such function could be found</li>
  </ul>
  <li>After the loop we must make sure, to write the collections back to files (otherwise the data will be lost since Zorba ships only with a in-memory store)</li>
</ul>

Instead of having some kind of hard coded mapping between command strings and XQuery functions we want
to use introspection to look for an XQuery function. We want all commands to be in an own "command"
module and we want the whole REST functionality to be in an own module called "client".

So in our main module we need to import the following modules:

<ul>
  <li>Our C++ commandline module (to read and write from and to the standard input and standard output)</li>
  <li>Our "commands" module, where we have implemented all commands (this needs to be imported, even though
      we won't call everything directly - but Zorba needs the import to find the functions via intrspection)</li>
  <li>Our "client" module to authenticate the user and authorize the application</li>
  <li>Zorbas introspection module look find functions in the commands module</li>
  <li>Zorbas reflection module to actually call a found function</li>
</ul>

So this are our module import statements:

\code
  import module namespace cli = 'http://www.zorba-xquery.com/examples/commandline';
  import module namespace cmd = 'http://www.zorba-xquery.com/examples/twitter/commands';
  import module namespace client = 'http://www.zorba-xquery.com/examples/twitter/client';
  import module namespace sctx = 'http://www.zorba-xquery.com/modules/introspection/sctx';
  import module namespace reflection = "http://www.zorba-xquery.com/modules/reflection";
\endcode

The code of the whole module looks like this:

\code
  module namespace main = 'http://www.zorba-xquery.com/examples/twitter/main';
  
  import module namespace cli = 'http://www.zorba-xquery.com/examples/commandline';
  import module namespace cmd = 'http://www.zorba-xquery.com/examples/twitter/commands';
  import module namespace client = 'http://www.zorba-xquery.com/examples/twitter/client';
  import module namespace sctx = 'http://www.zorba-xquery.com/modules/introspection/sctx';
  import module namespace reflection = "http://www.zorba-xquery.com/modules/reflection";
  
  declare namespace ann = "http://www.zorba-xquery.com/annotations";
  
  declare %ann:sequential %ann:nondeterministic function main:main()
  {
    variable $command as xs:string*;
    variable $funname as xs:QName;
    variable $continue as xs:boolean := fn:true();
    client:authenticate();
    cmd:init-collection();
    while ($continue) {
      cli:print("twitter> ");
      $command := tokenize(cli:get-line(), '\s');
      $funname := fn:QName('http://www.zorba-xquery.com/examples/twitter/commands',
                           concat('cmd:', ($command, "nop")[1]));
      if (sctx:function-arguments-count($funname) = 1) then
        $continue := reflection:invoke-sequential($funname, $command);
      else
        cli:print-line(concat("command not found: ", $command[1]));
    }
    cmd:shutdown();
  };
\endcode

So the first observation is, that scripting is somehow different from pure XQuery. Unlike in XQuery, all
statements are terminated with a semicolon. This has the semantics "execute and apply" - which means that
it will also apply all updates (or variable assignments - also something that does not exist in pure XQuery).
Also unlike in pure XQuery, Zorba will make sure that the statements get executed in the same order than
you write them down.

To understand this function better, let's look at the code line by line

\code
  variable $command as xs:string*;
\endcode
We will parse a line by simply tokenize it by spaces. This will result in a sequence of strings where
the first string is the name of the command and the next strings are the arguments.

\code
  variable $funname as xs:QName;
\endcode
From a command name, we will construct a function name and then check if such a function is there in the
commands module. A function name is always a QName and we will save the function name in the vairable $funname.

\code
  variable $continue as xs:boolean := fn:true();
\endcode
Our while loop will just loop until this variable is set to false.

\code
  client:authenticate();
\endcode
We will have to implement an authenticate function in the client module to authenticate a user and here we
call this function, to make sure that the application always has access to a users data on Twitter.

\code
  cmd:init-collection();
\endcode
Since Zorba only ships with an in-memory store, we need to set up the collections by reading the content
of an XML file (if it already exists).

\code
  while ($continue) {
\endcode
XQuery scripting provides a while loop - it looks like in Java or C++ - the argument is initially set
to true - so we will in first place enter this loop.

\code
    cli:print("twitter> ");
\endcode
Here we see the first usage of our commandline module. We just print the prompt and present it to the user.

\code
    $command := tokenize(cli:get-line(), '\s');
\endcode
This is trivial: we get a line from standard in and tokenize it by white space.

\code
    $funname := fn:QName('http://www.zorba-xquery.com/examples/twitter/commands',
                         concat('cmd:', ($command, "nop")[1]));
\endcode
Then we construct the function name. It will be in the commands namespace. If the user
just presses enter he would see a "command not found" error. We solve this problem with
a simple trick: if $command is an empty-sequence, the first item in the sequence ($command, "nop")
will be "nop". We will make sure that cmd:nop is just a function that does not do anything
and just returns true (to tell our while loop to continue looping).

\code
    if (sctx:function-arguments-count($funname) = 1) then
\endcode
A command implementation has to be (by convention) a function taking a seuqnce of strings and returns
a boolean. So we only look for a function with one argument. If there are several functions with the
same name, the "=" operator will make sure to return true if one of them takes one argument
(note: the "eq" operator would result in an error in that case, since it cannot compare sequences
with other sequences or atomics). The function-arguments-count function is a function in Zorbas
introspection module which will just return a sequence of integers with the arity of all functions
with the given name (or the empty sequence if no function with the given name exists).

\code
      $continue := reflection:invoke-sequential($funname, $command);
\endcode
If the function exists, it gets called...

\code
    else
\endcode
... otherwise ...

\code
      cli:print-line(concat("command not found: ", $command[1]));
\endcode
The user will get an error.

\code
  cmd:shutdown();
\endcode
After the loop we have to make sure that we write back all contents of our collections into an
XML file to persist the collections to the disk. We will do this in the shutdown function in the
commands module.

\subsection twitter_client_module Writing the client module

So let's do the fun stuff: implementing the client module. As always we start be defining the module namespace:

\code
  module namespace client = 'http://www.zorba-xquery.com/examples/twitter/client';
\endcode

We also will need some other modules:

<ul>
  <li>Our command line module</li>
  <li>The file module</li>
  <li>The oauth client</li>
</ul>

So after the module definition we import these modules:

\code
  import module namespace cmd = 'http://www.zorba-xquery.com/examples/commandline';
  import module namespace file = 'http://expath.org/ns/file';
  import module namespace oauth = "http://www.zorba-xquery.com/modules/oauth/client";
\endcode

We will also need some namespace declarations:

<ul>
  <li>Since we need scripting and nondeterministic, we again need Zorbas annotation namespace</li>
  <li>The file module uses the same serialization options than fn:serialize in XQuery 3.0. These parameters are in the http://www.w3.org/2010/xslt-xquery-serialization
      namespace - we need to declare this namespace too.</li>
</ul>

This leeds us to the following namespace declarations:

\code
  declare namespace ann = "http://www.zorba-xquery.com/annotations";
  declare namespace output = 'http://www.w3.org/2010/xslt-xquery-serialization';
\endcode

And finally we need some private variables to hold some information:

<ul>
  <li>The oauth token (which we get after the user grants access to our application)</li>
  <li>The oauth token secret (which we also get after the user grants access to our application)</li>
  <li>The user name (called screen name in Twitter language)</li>
  <li>The name of the file where we want to store this information (since we don't want the user to have to authenticate and grant access
      for every launch of the application)</li>
  <li>Our consumer key</li>
  <li>Our consumer secret</li>
</ul>

So we can declare these variables:

\code
  declare %private variable $client:oauth-token as xs:string := "";
  declare %private variable $client:oauth-token-secret as xs:string := "";
  declare %private variable $client:screen-name as xs:string := "";
  declare %private variable $client:token-file as xs:string := "token.txt";
  declare %private variable $client:consumer-key as xs:string := "YOUR_CONSUMER_KEY";
  declare %private variable $client:consumer-secret as xs:string := "YOUR_CONSUMER_SECRET";
\endcode

Make sure to replace YOUR_CONSUMER_KEY and YOUR_CONSUMER_SECRET with the consumer key and secret
you've got from Twitter after registering your application.

\subsubsection twitter_client_module_auth Authentication

Our main module calls a function called "authenticate" - so we first want to implement this method:

\code
  declare %ann:sequential %ann:nondeterministic function client:authenticate()
  {
    variable $file-content as xs:string+;
    if (file:is-file($client:token-file)) then {
      $file-content := tokenize(file:read-text($client:token-file), " ");
      $client:oauth-token := $file-content[1];
      $client:oauth-token-secret := $file-content[2];
      $client:screen-name := $file-content[3];
    }
    else {
      client:oauth();
      file:write($client:token-file, string-join(($client:oauth-token, $client:oauth-token-secret, $client:screen-name), " "),
        <output:serialization-parameters>
          <output:method value="text"/>
        </output:serialization-parameters>);
    }
    cmd:print-line(concat("Authenticated as User ", $client:screen-name));
  };
\endcode

This function is quite simple: it first checks if the token file already exists. If so, it reads all needed information from the
file and we are done. Otherwise it starts the oauth authentication process by calling the private function "oauth" and then writes
the oauth token and the oauth secret plus the screen name to the token file. After that it just greets the user.

So the interesting stuff happens in the private oauth function:

\code
  declare %private %ann:sequential %ann:nondeterministic function client:oauth() {
    variable $pin as xs:string;
    variable $access-token;
    variable $req-answer := 
      oauth:request-token($client:consumer-key,
                          $client:consumer-secret,
                          "HMAC-SHA1",
                          "POST",
                          "twitter.com",
                          "http://api.twitter.com/oauth/request_token",
                          "oob", ());
    cmd:print(string-join(("Please type in the folloing URL into your browser to authorize the application:",
                           concat("http://api.twitter.com/oauth/authorize?oauth_token=", data($req-answer/param[@key = "oauth_token"]/@value)),
                           "Then copy the showed up PIN into this window",
                           "PIN> ")
                     , $cmd:endl));
    $pin := cmd:get-line();
    $access-token :=
      oauth:access-token($client:consumer-key,
                         $client:consumer-secret,
                         "HMAC-SHA1",
                         "twitter.com",
                         data($req-answer/param[@key = "oauth_token"]/@value),
                         data($req-answer/param[@key = "oauth_token_secret"]/@value),
                         $pin,
                         "POST",
                         "https://api.twitter.com/oauth/access_token",
                         ());
    $client:oauth-token := xs:string(data($access-token/param[@key = "oauth_token"]/@value));
    $client:oauth-token-secret := xs:string(data($access-token/param[@key = "oauth_token_secret"]/@value));
    $client:screen-name := xs:string(data($access-token/param[@key = "screen_name"]/@value));
  };
\endcode

To understand this function, we first need to understand how oauth works. For a detailed description, look up the oauth
documents you can find on the web. For writing this code, all you need to know are the basic steps:

<ul>
  <li>
    First the client gets a request token from Twitter. It will recieve a temporary valid oauth token and oauth token secret.
    This is what this line does:
\code
    variable $req-answer := 
      oauth:request-token($client:consumer-key,
                          $client:consumer-secret,
                          "HMAC-SHA1",
                          "POST",
                          "twitter.com",
                          "http://api.twitter.com/oauth/request_token",
                          "oob", ());
\endcode
  </li>
  <li>
    In a web app, the application would redirect the user to a twitter login page where the user can authorize the application
    and twitter will redirect the user back to a URL provided in the request token request. Since we are not running a web server,
    we can not do that. Instead we pass "oob" instal of a URL. oob stands for out-of-band. After authorizing the application,
    the user gets presented a PIN code which he has to enter to the application.

    So we need to direct the user to Twitter with the oauth token as a parameter and ask her for the PIN:
\code
    cmd:print(string-join(("Please type in the folloing URL into your browser to authorize the application:",
                           concat("http://api.twitter.com/oauth/authorize?oauth_token=", data($req-answer/param[@key = "oauth_token"]/@value)),
                           "Then copy the showed up PIN into this window",
                           "PIN> ")
                     , $cmd:endl));
\endcode
  </li>
  <li>
    With the oauth token, the oauth secret and the PIN, we can request the access tokens by calling the corresponding REST service,
    which is done by calling the access-token function in the oauth module:

\code
    $access-token :=
      oauth:access-token($client:consumer-key,
                         $client:consumer-secret,
                         "HMAC-SHA1",
                         "twitter.com",
                         data($req-answer/param[@key = "oauth_token"]/@value),
                         data($req-answer/param[@key = "oauth_token_secret"]/@value),
                         $pin,
                         "POST",
                         "https://api.twitter.com/oauth/access_token",
                         ());
\endcode
  </li>
  <li>
    Finally we are only interested in the access token. We parse the oauth token, the oauth token secret and the screen name and save them in
    our private variables:

\code
    $client:oauth-token := xs:string(data($access-token/param[@key = "oauth_token"]/@value));
    $client:oauth-token-secret := xs:string(data($access-token/param[@key = "oauth_token_secret"]/@value));
    $client:screen-name := xs:string(data($access-token/param[@key = "screen_name"]/@value));
\endcode
  </li>
</ul>

That's it! The user is now authenticated and we can access her information on Twitter. This is all we need and the user never had to
give a username or password to us.

\subsubsection twitter_client_module_tweets Getting tweets

So we authenticated, now we want to do something with Twitter! In our client module we will need two additional functions:

<ul>
  <li>
    A function tweet, which will get a tweet id as a parameter and get the corresponding tweet. It will return the tweet in
    Twitters own XML format (which means it will return an element node).
  </li>
  <li>
    A function named tweets, which will just get the last twenty tweets which will the user see on the homescreen when loading
    the Twitter homepage in the browser. This function will format the tweets to a human readable way and print it to standard
    out.
  </li>
</ul>

First let's have a look into the tweet function:

\code
  declare %ann:sequential %ann:nondeterministic function client:get-tweet($id as xs:string) as element(status)
  {
    variable $answer :=
      oauth:protected-resource($client:consumer-key,
                           $client:consumer-secret,
                           "HMAC-SHA1",
                           $client:oauth-token,
                           $client:oauth-token-secret,
                           "twitter.com",
                           "GET",
                           concat("http://api.twitter.com/statuses/show/", $id, ":id.xml"),
                           ());
    exit returning $answer/status;
  };
\endcode

Whenever you want to make a call to a protected REST service, you want to call the protected-resource function in the oauth module.
So here we simply make a call to Twitters "statuses/show/:id" function and return the status element node. Pretty easy, isn't it?

The tweets function works exactly the same way, but instead of just returning the results it formats a string (with string-join) and
then prints it to the standard out (with print-line in our commandline module):

\code
  declare %ann:sequential %ann:nondeterministic function client:tweets()
  {
    variable $answer :=
      oauth:protected-resource($client:consumer-key,
                           $client:consumer-secret,
                           "HMAC-SHA1",
                           $client:oauth-token,
                           $client:oauth-token-secret,
                           "twitter.com",
                           "GET",
                           "http://api.twitter.com/statuses/home_timeline.xml",
                           ());
    cmd:print-line(string-join(
        for $status in $answer//status
        return string-join((
                                concat("Id: ", $status/id/text()),
                                concat("From User: ", $status/user/name/text()),
                                "",
                                $status/text/text()
                              ), $cmd:endl)
      , concat($cmd:endl, "=====================================================================", $cmd:endl))
    );
  };
\endcode

That's it, we now can access tweets. After doing this, implementing other functions which access some Twitter functionallity
should be quite straight forward. Let's now look into the commands module.

Here is our twitter client module:

\code
module namespace client = 'http://www.zorba-xquery.com/examples/twitter/client';

import module namespace cmd = 'http://www.zorba-xquery.com/examples/commandline';
import module namespace file = 'http://expath.org/ns/file';
import module namespace oauth = "http://www.zorba-xquery.com/modules/oauth/client";

declare namespace ann = "http://www.zorba-xquery.com/annotations";
declare namespace output = 'http://www.w3.org/2010/xslt-xquery-serialization';

declare %private variable $client:oauth-token as xs:string := "";
declare %private variable $client:oauth-token-secret as xs:string := "";
declare %private variable $client:screen-name as xs:string := "";
declare %private variable $client:token-file as xs:string := "token.txt";
declare %private variable $client:consumer-key as xs:string := "YOUR_CONSUMER_KEY";
declare %private variable $client:consumer-secret as xs:string := "YOUR_CONSUMER_SECRET";

declare %ann:sequential %ann:nondeterministic function client:tweets()
{
  variable $answer :=
    oauth:protected-resource($client:consumer-key,
                         $client:consumer-secret,
                         "HMAC-SHA1",
                         $client:oauth-token,
                         $client:oauth-token-secret,
                         "twitter.com",
                         "GET",
                         "http://api.twitter.com/statuses/home_timeline.xml",
                         ());
  cmd:print-line(string-join(
      for $status in $answer//status
      return string-join((
                              concat("Id: ", $status/id/text()),
                              concat("From User: ", $status/user/name/text()),
                              "",
                              $status/text/text()
                            ), $cmd:endl)
    , concat($cmd:endl, "=====================================================================", $cmd:endl))
  );
};

declare %ann:sequential %ann:nondeterministic function client:get-tweet($id as xs:string) as element(status)
{
  variable $answer :=
    oauth:protected-resource($client:consumer-key,
                         $client:consumer-secret,
                         "HMAC-SHA1",
                         $client:oauth-token,
                         $client:oauth-token-secret,
                         "twitter.com",
                         "GET",
                         concat("http://api.twitter.com/statuses/show/", $id, ":id.xml"),
                         ());
  exit returning $answer/status;
};

declare %private %ann:sequential %ann:nondeterministic function client:oauth() {
  variable $pin as xs:string;
  variable $access-token;
  variable $req-answer := 
    oauth:request-token($client:consumer-key,
                        $client:consumer-secret,
                        "HMAC-SHA1",
                        "POST",
                        "twitter.com",
                        "http://api.twitter.com/oauth/request_token",
                        "oob", ());
  cmd:print(string-join(("Please type in the folloing URL into your browser to authorize the application:",
                         concat("http://api.twitter.com/oauth/authorize?oauth_token=", data($req-answer/param[@key = "oauth_token"]/@value)),
                         "Then copy the showed up PIN into this window",
                         "PIN> ")
                   , $cmd:endl));
  $pin := cmd:get-line();
  $access-token :=
    oauth:access-token($client:consumer-key,
                       $client:consumer-secret,
                       "HMAC-SHA1",
                       "twitter.com",
                       data($req-answer/param[@key = "oauth_token"]/@value),
                       data($req-answer/param[@key = "oauth_token_secret"]/@value),
                       $pin,
                       "POST",
                       "https://api.twitter.com/oauth/access_token",
                       ());
  $client:oauth-token := xs:string(data($access-token/param[@key = "oauth_token"]/@value));
  $client:oauth-token-secret := xs:string(data($access-token/param[@key = "oauth_token_secret"]/@value));
  $client:screen-name := xs:string(data($access-token/param[@key = "screen_name"]/@value));
};

declare %ann:sequential %ann:nondeterministic function client:authenticate()
{
  variable $file-content as xs:string+;
  if (file:is-file($client:token-file)) then {
    $file-content := tokenize(file:read-text($client:token-file), " ");
    $client:oauth-token := $file-content[1];
    $client:oauth-token-secret := $file-content[2];
    $client:screen-name := $file-content[3];
  }
  else {
    client:oauth();
    file:write($client:token-file, string-join(($client:oauth-token, $client:oauth-token-secret, $client:screen-name), " "),
      <output:serialization-parameters>
        <output:method value="text"/>
      </output:serialization-parameters>);
  }
  cmd:print-line(concat("Authenticated as User ", $client:screen-name));
};
\endcode

\subsection twitter_commands_module The commands module

As always we start by declaring the module namespace:

\code
module namespace cmd = 'http://www.zorba-xquery.com/examples/twitter/commands';
\endcode

As said before, a command is just a function (with the same name than the command) that takes a string with the arguments
and returns a boolean which is set to false if and only if the twitter client has to quit. We used a trick with the nop
function, so that the user does not get a "command not found" error when she does only hit the enter key without giving a
command. Implementing this nop function is trivial:

\code
declare function cmd:nop($args as xs:string*) as xs:boolean {
  true()
};
\endcode

Now we can start implement whatever function we want. Note that thanks to our mechanism with using introspection, we do not
have to register our functions as commands - we just need to provide them (with exactly one parameter - everything else is
not a command). Of course we also want the user to be able to quit the twitter client. So we implement the trivial quit
function:

\code
declare function cmd:quit($args as xs:string*) as xs:boolean {
  false()
};
\endcode

This function just returns false which tells the main routine to stop looping and the application will quit - as easy as we can
get.

The function for printing the last twenty tweets is already implemented in the client module. So we just need to wrap it
into a command (note that this needs to be a sequential nondeterministic function, since the client:tweets function is
also sequential nondeterministic):

\code
declare %ann:sequential %ann:nondeterministic function cmd:tweets($args as xs:string*) as xs:boolean {
  client:tweets();
  exit returning true();
};
\endcode

To make this woring, we need an import for the client module

\code
  import module namespace client = 'http://www.zorba-xquery.com/examples/twitter/client';
\endcode

and we need to declare Zorbas annotation namespace:

\code
  declare namespace ann = "http://www.zorba-xquery.com/annotations";
\endcode

So the user can now log in and look at the twenty newest tweets.

\subsubsection twitter_commands_module_collections Working with collections

As defined in our requirements, we want a user to be able to save tweets and search them later. To
implement this functionality we need collections. To be more precise, we just need one collection.
The easiest way to define a collection is good enough for us:

\code
  declare collection cmd:saved-tweets as node()*;
\endcode

Furthermore we need some functions to create collections, query collections and add nodes to collections.
This functionality is in two modules which we need to import:

\code
  import module namespace ddl = "http://www.zorba-xquery.com/modules/store/static/collections/ddl";
  import module namespace dml = "http://www.zorba-xquery.com/modules/store/static/collections/dml";
\endcode

The ddl module gives us functions to create collections, delete them etc. The dml module provides us some
functionality to access collections, insert nodes into collections etc.

In our main function we already call init-collection - so let's implement this:

\code
declare %ann:sequential %ann:nondeterministic function cmd:init-collection()
{
  ddl:create-collection(xs:QName("cmd:saved-tweets"));
  if (file:is-file($cmd:collectionfile)) then
    dml:insert-nodes(xs:QName("cmd:saved-tweets"), doc($cmd:collectionfile)//status);
  else ();
};
\endcode

First we call create-collection to create the collection in Zorbas store. Then we look for
a file which filename is saved in the $cmd:collectionfile variable. If it exists, we load all
nodes with the element name status into the collection.

So we need to import again the file module,

\code
  import module namespace file = 'http://expath.org/ns/file';
\endcode

declare the annotation namespace

\code
  declare namespace ann = "http://www.zorba-xquery.com/annotations";
\endcode

and declare the local variable

\code
  declare variable $cmd:collectionfile as xs:string := "likes.xml";
\endcode

When the user quits, the data in the collection needs to written to the file. For that
purpose we call the shutdown function in our main function:

\code
  declare %ann:sequential function cmd:shutdown()
  {
    variable $doc := <tweets>{dml:collection(xs:QName("cmd:saved-tweets"))}</tweets>;
    file:write($cmd:collectionfile, $doc,
       <output:serialization-parameters>
         <output:method value="xml"/>
       </output:serialization-parameters>);
  };
\endcode

Since a xml file needs one root element we just create one called tweets (the name of this
node does not matter here) and put the whole collection as children of this node. Then
we use the file module, to serialize the this node to the xml file.

For this to work we need again to declare the output namespace:

\code
  declare namespace output = 'http://www.w3.org/2010/xslt-xquery-serialization';
\endcode

We now can use our collection. But the collection will be quite useless, if we do not
insert any data to it. So we implement a new command named "like" which stores a tweet
in our collection:

\code
declare %ann:sequential %ann:nondeterministic function cmd:like($args as xs:string*) as xs:boolean {
  variable $status := client:get-tweet($args[2]);
  dml:insert-nodes(xs:QName("cmd:saved-tweets"), $status);
  exit returning true();
};
\endcode

This function uses our before implemented tweet function to get a tweet the user gave as argument to the
command (note: the first argument is the second string in the sequence, the first one is just the name of
the command). In the dml module we have a function insert-nodes which takes as first argument the QName of the
collection and as the second a sequence of nodes. That way we insert the node into the collection.

Listing the saved tweets is done by the "likes" command:

\code
declare %ann:sequential %ann:nondeterministic function cmd:likes($args as xs:string*) as xs:boolean
{
  cli:print-line(string-join(
      for $status in dml:collection(xs:QName("cmd:saved-tweets"))
      return string-join((
                              concat("Id: ", $status/id/text()),
                              concat("From User: ", $status/user/name/text()),
                              "",
                              $status/text/text()
                            ), $cli:endl)
    , concat($cli:endl, "=====================================================================", $cli:endl))
  );
  exit returning true();
};
\endcode

We get all status nodes by simply calling collection in the dml module (again with passing the QName of the collection)
and we format the tweets the same way we already did in the tweets function of the client module.

Of course we need to import our commandline module to make this working:

\code
  import module namespace cli = 'http://www.zorba-xquery.com/examples/commandline';
\endcode

\subsubsection twitter_commands_module_fulltext Using fulltext to search the collection

But what if the user wants to search the tweets she saved? Zorba fully supports XQuery Full Text and we can use
this to search the tweets. So we implement another command called "search":

\code
  declare %ann:sequential %ann:nondeterministic function cmd:search($args as xs:string*) as xs:boolean
  {
    cli:print-line(string-join(
      for $status in dml:collection(xs:QName("cmd:saved-tweets"))
      where $status contains text { subsequence($args, 2) } using stemming
      return string-join((
                                concat("Id: ", $status/id/text()),
                                concat("From User: ", $status/user/name/text()),
                                "",
                                $status/text/text()
                              ), $cli:endl)
      , concat($cli:endl, "=====================================================================", $cli:endl)));
    exit returning true();
  };
\endcode

As you might see, this is nearly the same function than the likes function, with one difference:

\code
      where $status contains text { subsequence($args, 2) } using stemming
\endcode

This where clause looks if the $status containts the text of all arguments given to the query and uses stemming to do so.
Feel free to look into Zorbas full text examples or into the specification and play around with this line to see how it
behaves if you change something.

\subsubsection twitter_commands_module_translate Translate Tweets

We are nearly done now - the only requirement that is not met yet is the translate feature. We use Google Translate to
translate the message of a tweet into another language. The user than can enter "translate <LANGCODE> <TWEETID>" and
she sees a translation to the language of desire.

Google Translate is just a simple REST interface without any oauth. So we won't need the oauth module here. We need the
http module and, since Google will answer with a JSON string, we also need the JSON module (so that we don't have to
parse JSON manually);

\code
import module namespace http = "http://www.zorba-xquery.com/modules/http-client";
import module namespace json = "http://www.zorba-xquery.com/modules/converters/json";
\endcode

Our implementation for transalte is now very straight forward:

\code
  declare %ann:sequential %ann:nondeterministic function cmd:translate($args as xs:string*) as xs:boolean
  {
    variable $language := $args[2];
    variable $tweet := client:get-tweet($args[3]);
    variable $json := http:get-text(concat('https://ajax.googleapis.com/ajax/services/language/translate?v=1.0&amp;q=',
                                           encode-for-uri($tweet/text/text()),
                                           '&amp;langpair=%7C', $language));
    variable $resp := json:parse($json[2]);
    cli:print-line($resp//pair[@name = "translatedText"]/text());
    exit returning true();
  };
\endcode

We just get the tweet, endoe the text for uri and build the URI for the call to Google. We then use the get-text function
from Zorbas http-client module to get the JSON object as a string. After that we parse that string with json:parse and we
print the translated text to the standard out.

The whole commands module will afterwards look like the this:

\code
module namespace cmd = 'http://www.zorba-xquery.com/examples/twitter/commands';

import module namespace client = 'http://www.zorba-xquery.com/examples/twitter/client';
import module namespace ddl = "http://www.zorba-xquery.com/modules/store/static/collections/ddl";
import module namespace dml = "http://www.zorba-xquery.com/modules/store/static/collections/dml";
import module namespace cli = 'http://www.zorba-xquery.com/examples/commandline';
import module namespace file = 'http://expath.org/ns/file';
import module namespace http = "http://www.zorba-xquery.com/modules/http-client";
import module namespace json = "http://www.zorba-xquery.com/modules/converters/json";

declare namespace ann = "http://www.zorba-xquery.com/annotations";
declare namespace output = 'http://www.w3.org/2010/xslt-xquery-serialization';

declare collection cmd:saved-tweets as node()*;

declare variable $cmd:collectionfile as xs:string := "likes.xml";

declare function cmd:nop($args as xs:string*) as xs:boolean {
  true()
};

declare function cmd:quit($args as xs:string*) as xs:boolean {
  false()
};

declare %ann:sequential %ann:nondeterministic function cmd:tweets($args as xs:string*) as xs:boolean {
  client:tweets();
  exit returning true();
};

declare %ann:sequential %ann:nondeterministic function cmd:like($args as xs:string*) as xs:boolean {
  variable $status := client:get-tweet($args[2]);
  dml:insert-nodes(xs:QName("cmd:saved-tweets"), $status);
  exit returning true();
};

declare %ann:sequential %ann:nondeterministic function cmd:likes($args as xs:string*) as xs:boolean
{
  cli:print-line(string-join(
      for $status in dml:collection(xs:QName("cmd:saved-tweets"))
      return string-join((
                              concat("Id: ", $status/id/text()),
                              concat("From User: ", $status/user/name/text()),
                              "",
                              $status/text/text()
                            ), $cli:endl)
    , concat($cli:endl, "=====================================================================", $cli:endl))
  );
  exit returning true();
};

declare %ann:sequential %ann:nondeterministic function cmd:search($args as xs:string*) as xs:boolean
{
  cli:print-line(string-join(
    for $status in dml:collection(xs:QName("cmd:saved-tweets"))
    where $status contains text { subsequence($args, 2) } using stemming
    return string-join((
                              concat("Id: ", $status/id/text()),
                              concat("From User: ", $status/user/name/text()),
                              "",
                              $status/text/text()
                            ), $cli:endl)
    , concat($cli:endl, "=====================================================================", $cli:endl)));
  exit returning true();
};

declare %ann:sequential %ann:nondeterministic function cmd:init-collection()
{
  ddl:create-collection(xs:QName("cmd:saved-tweets"));
  if (file:is-file($cmd:collectionfile)) then
    dml:insert-nodes(xs:QName("cmd:saved-tweets"), doc($cmd:collectionfile)//status);
  else ();
};

declare %ann:sequential function cmd:shutdown()
{
  variable $doc := <tweets>{dml:collection(xs:QName("cmd:saved-tweets"))}</tweets>;
  file:write($cmd:collectionfile, $doc,
     <output:serialization-parameters>
       <output:method value="xml"/>
     </output:serialization-parameters>);
};

declare %ann:sequential %ann:nondeterministic function cmd:translate($args as xs:string*) as xs:boolean
{
  variable $language := $args[2];
  variable $tweet := client:get-tweet($args[3]);
  variable $json := http:get-text(concat('https://ajax.googleapis.com/ajax/services/language/translate?v=1.0&amp;q=',
                                         encode-for-uri($tweet/text/text()),
                                         '&amp;langpair=%7C', $language));
  variable $resp := json:parse($json[2]);
  cli:print-line($resp//pair[@name = "translatedText"]/text());
  exit returning true();
};
\endcode

\section twitter_done Done!

With about 200 lines of XQuery and some simple C++ we implement our own small Twitter client. Now you can play around
with it and try to implement new features. If you understood everything (or let's say most) in this tutorial, you know
enough to code your own powerful XQuery applications. If you built something cool, let us know!

If you run into any problems or still have open questions, feel free to drop us an <a href="mailto:zorba-users@lists.sourceforge.net">email</a>.

*/
