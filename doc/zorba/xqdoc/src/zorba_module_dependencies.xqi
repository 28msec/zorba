(:
 : author Sorin Nasoi
 :)

module namespace z = "http://www.zorba-xquery.com/module-dependencies";

declare namespace ann = "http://www.zorba-xquery.com/annotations";

import module namespace file = "http://expath.org/ns/file";
import module namespace dot = "http://www.zorba-xquery.com/modules/image/graphviz";
import module namespace xqdoc2html = "http://www.zorba-xquery.com/modules/xqdoc2xhtml/";
import module namespace functx = "http://www.functx.com/";

import module namespace dml = "http://www.zorba-xquery.com/modules/store/static/collections/dml";
import module namespace ddl = "http://www.zorba-xquery.com/modules/store/static/collections/ddl";

import schema namespace xqdoc = "http://www.xqdoc.org/1.0";
  
declare variable $z:nodesCollector := <modules/>;

declare variable $z:edgesCollector := <edges/>;

declare variable $z:typeModule          := 'module';
declare variable $z:typeExternalLibrary := 'library';
declare variable $z:typeSchema          := 'schema';

declare variable $z:colors      as xs:string* := ('red'       , 'green');
declare variable $z:moduleTypes as xs:string* := ('Zorba-core', 'External module');

(:=========================================================================================================:)
declare variable $z:level1Weight as xs:string* := 
("www.w3.org", "XDM", "store", "introspection", "reflection",
 "external", "xqdoc","data processing", "programming languages", "excel", 
 "cryptography", "geo", "image", "OAuth", "expath.org",
 "www.functx.com", "communication");
 
declare variable $z:level1Colors as xs:string* := 
("mediumvioletred", "lightsteelblue", "sienna", "dimgray", "slategray",
 "Gold", "moccasin","tan", "RosyBrown", "wheat", 
 "LightGreen", "forestgreen", "olivedrab", "darkkhaki", "cornflowerblue",
 "yellow", "Chartreuse");
 

declare variable $z:collectionConfig as xs:QName := xs:QName("z:collectionConfig");
declare collection z:collectionConfig as node()*;

declare variable $z:collection as xs:QName := xs:QName("z:collection");
declare collection z:collection as node()*;

declare %ann:nondeterministic %ann:sequential function z:create-collection-categories (
$collectionName as xs:QName,
$xqdocXmlPath as xs:string)
{
  ddl:create-collection($collectionName);
  
  (: gather all the XQDoc XML's :)
  for $xqdocRelPath in file:list($xqdocXmlPath, fn:false(), "*.xml")
  let $path := fn:concat($xqdocXmlPath, file:directory-separator(), $xqdocRelPath )
  let $xqdoc := fn:parse-xml(file:read-text($path))
  return dml:apply-insert-nodes($collectionName, $xqdoc);
};

declare %ann:nondeterministic %ann:sequential function z:create-collections($xqdocXMLPath as xs:string) 
{ 
  variable $xqdocBuildPath as xs:string := 
  fn:substring-before($xqdocXMLPath, fn:concat(file:directory-separator(),"xml"));
  
  variable $xqdocXmlConfigPath as xs:string := 
  fn:concat($xqdocBuildPath, file:directory-separator(), "config");
  
  z:create-collection-categories (xs:QName("z:collectionConfig"), $xqdocXmlConfigPath);
  
  z:create-collection-categories (xs:QName("z:collection"), $xqdocXMLPath);
  
  z:fill-nodesCollector();
  
  z:fill_edgesCollector();
};

declare %ann:sequential function z:delete-collections()
{
  dml:delete-nodes(dml:collection(xs:QName("z:collectionConfig")));                           
  ddl:delete-collection(xs:QName("z:collectionConfig"));
  
  dml:delete-nodes(dml:collection(xs:QName("z:collection")));                           
  ddl:delete-collection(xs:QName("z:collection"));
};
 
(:~
 : Fill the $z:nodesCollector with all the available modules.
 :)
declare %ann:sequential function z:fill-nodesCollector() as xs:string*
{

  for $category in $z:level1Weight
  return
    for $docNode in dml:collection(xs:QName("z:collection"))
    let $xqdoc := $docNode/xqdoc:xqdoc
    let $lModuleUri := data($xqdoc/xqdoc:module/xqdoc:uri)
    let $lModuleProject := if(exists($xqdoc/xqdoc:module/xqdoc:custom[@tag="project"])) 
                                then $xqdoc/xqdoc:module/xqdoc:custom[@tag="project"]/text() 
                                else data($xqdoc/xqdoc:module/xqdoc:uri)
    let $tok := tokenize($lModuleProject,"/")[1]
    let $subProject as xs:string? := replace(replace(substring-after($lModuleProject,concat($tok,"/")),"/","_")," ","_")
    let $subProjectFinal := if(not(contains($subProject,"2005")) 
                               and ($subProject ne "") 
                               and not($lModuleProject = $lModuleUri)) 
                            then concat($subProject,"_") 
                            else ()
    let $lName := concat($subProjectFinal,fn:replace(substring-before(data($xqdoc/xqdoc:module/xqdoc:name),"."),"-","_"))
    where (fn:starts-with($lModuleProject, $category) or
           fn:contains($lModuleProject, $category))
    return
    if(exists($lName)) then
      z:collect-node ($lModuleUri, 
                      $lName, 
                      $category, 
                      fn:string(index-of($z:level1Weight,$category))
                      )
    else () 
};

declare %private %ann:sequential function z:collect-node (
  $moduleURI as xs:string, 
  $name as xs:string,
  $lModuleProject as xs:string,
  $catUi as xs:string) 
{
  insert node <module uri="{$moduleURI}" 
                      name="{$name}" 
                      moduleProject="{$lModuleProject}" 
                      catUi="{$catUi}" /> 
  as last into $z:nodesCollector;
};

(:~
 : Fill $z:edgesCollector with all the edges (the links between the nodes) for both modules and eternal library dependencies.
 :)
declare %ann:nondeterministic %ann:sequential function z:fill_edgesCollector()
{  
  for $docNode in dml:collection(xs:QName("z:collection"))
  let $xqdoc := $docNode/xqdoc:xqdoc
  return
    (
    (: add imported modules :)
    if (fn:count($xqdoc/xqdoc:imports//xqdoc:import[@type = "library"]) > 0) then
      for $import in $xqdoc/xqdoc:imports//xqdoc:import[@type = "library"]
      let $from := $z:nodesCollector//module[@uri=data($xqdoc/xqdoc:module/xqdoc:uri)]
      let $to := $z:nodesCollector//module[@uri=string($import/xqdoc:uri/text())]
      return
        z:collect-edge(data($z:nodesCollector//module[@uri = data($xqdoc/xqdoc:module/xqdoc:uri)]/@catUri),
                       concat(data($from/@name),'_',data($from/@catUi)),
                       data($xqdoc/xqdoc:module/xqdoc:uri),
                       concat(data($to/@name),'_',data($to/@catUi)),
                       string($import/xqdoc:uri/text()),
                       $z:typeModule)                      
    else
      (),
    (: add externall c++ libraries dependencies :)                   
    if (fn:count($xqdoc/xqdoc:module/xqdoc:comment//xqdoc:library) > 0) then
      for $libraryDependency in $xqdoc/xqdoc:module/xqdoc:comment//xqdoc:library
      let $from := $z:nodesCollector//module[@uri=data($xqdoc/xqdoc:module/xqdoc:uri)]
      let $to := $libraryDependency/*:a
      return
        z:collect-edge(data($z:nodesCollector//module[@uri eq data($xqdoc/xqdoc:module/xqdoc:uri)]/@catUri),
                       concat(data($from/@name),'_',data($from/@catUi)),
                       data($xqdoc/xqdoc:module/xqdoc:uri),
                       concat(data($to/text()),'|',data($to/@href) ),
                       "",
                       $z:typeExternalLibrary)
    else
      ())
};

declare %private %ann:sequential function z:collect-edge (
  $catUri as xs:string?,
  $nameFrom as xs:string?,
  $uriFrom as xs:string?,  
  $nameTo as xs:string?,
  $uriTo as xs:string?,
  $type as xs:string?) 
{
  insert node <edge catUri  ="{$catUri}" 
                    nameFrom="{$nameFrom}"
                    uriFrom ="{$uriFrom}"
                    nameTo  ="{$nameTo}"
                    uriTo   ="{$uriTo}"
                    type    ="{$type}" /> 
  as last into $z:edgesCollector;
};

declare function z:test()
{
(:
  string-join(
  for $edge in $z:edgesCollector//edge
  return fn:concat($edge/@catUri,"|", $edge/@nameFrom, "|",  $edge/@uriFrom, "|", $edge/@nameTo),"
")
 
  string-join(
  for $module in $z:nodesCollector//module
  return fn:concat($module/@uri,"|", $module/@name, "|",  $module/@moduleProject, "|", $module/@catUi),"
")
:)
};

(:~
 : This function returns the module type (see $z:moduleType)
 : based on the existance of the externals functions withing the module and also
 : it takes into account the imported modules.
 :)
declare function z:get_module_type($moduleUri as xs:string) as xs:integer
{
  if(dml:collection(xs:QName("z:collectionConfig"))/module[@moduleURI = $moduleUri]/@isCore = "true") 
  then xs:integer(1)
  else xs:integer(2)
};

(:~
 : Format the properties of a module dot shape (link to a file, tooltip, color of the text showing the module name).
 :)
declare function z:get_shape_properties( 
  $ModuleUri as xs:string,
  $lLabel as xs:string) as xs:string
{
  let $file as xs:string := concat(xqdoc2html:get-filename($ModuleUri),".html")
  let $type := z:get_module_type($ModuleUri)
  return
    fn:concat('[URL="../',$file,'" tooltip="(',$z:moduleTypes[$type],') module uri=', $ModuleUri,'" label="',$lLabel,'" fontcolor="', $z:colors[$type] ,'"]')
};

(:~
 : Get the nodes that represent modules based on a provided category URI.
 :)
declare function z:nodes_modules(
  $category as xs:string) as xs:string 
{             
  let $nodes :=
  string-join(
  for $node in $z:nodesCollector//module
    let $lModuleUri := data($node/@uri)
    let $lLabel := data($node/@name)
    let $lName := concat($lLabel,'_', data($node/@catUi),z:get_shape_properties($lModuleUri, $lLabel))
    where $node[@moduleProject = $category]
    order by $lModuleUri
    return
      $lName,";
    ")
  return
    if($nodes eq '') then ''
    else concat($nodes,';')
    
};

(:~
 : Get the nodes that represent external library dependencies.
 :)
declare function z:nodes_external_libraries() as xs:string 
{
  let $nodes :=
  string-join(
  for $edge in $z:edgesCollector//edge
  let $tok := tokenize(data($edge/@nameTo),'\|')
  let $nodeLabel := replace(tokenize($tok[1],' ')[1],'\+','')
  let $link := $tok[2]
  let $node := data($edge/@nameTo)
  let $lName := concat($nodeLabel,'[URL="',$link,'" tooltip="', $tok[1],'" label="',$nodeLabel,'"]')
  where data($edge/@type) eq $z:typeExternalLibrary
  group by $nodeLabel
    return
      $lName,";
    ")
  return
    if($nodes eq '') then ''
    else concat($nodes,';')
};

(:~
 : Get all the edges (the links between the nodes) for both modules and eternal library dependencies.
 :)
declare function z:edges($category) as xs:string
{
let $lcatUri := data($category/@uri)
let $edges :=
  string-join(
    for $edge in $z:edgesCollector//edge    
    where $lcatUri eq $edge/@catUri
    return concat($edge/@nameFrom,'->',$edge/@nameTo),
  ';
')
return
  if($edges eq '') then ''
  else concat($edges,';')
};

(:~
 : Get all the edges (the links between the nodes) between modules.
 :)
declare function z:edges_modules() as xs:string
{
let $edges :=
  string-join(
    for $edge in $z:edgesCollector//edge
    where data($edge/@type) eq $z:typeModule
    return concat('    ',$edge/@nameFrom,'->',$edge/@nameTo),
  ';
')
return
  if($edges eq '') then ''
  else concat($edges,';')
};

(:~
 : Get all the edges (the links between the nodes) between modules and externall c++ libraries.
 :)
declare function z:edges_libraries() as xs:string
{
let $edges :=
  string-join(
    for $edge in $z:edgesCollector//edge
    let $tok := tokenize(data($edge/@nameTo),'\|')
    let $nodeLabel := replace(tokenize($tok[1],' ')[1],'\+','')
    where data($edge/@type) eq $z:typeExternalLibrary
    return concat('    ',$edge/@nameFrom,'->',$nodeLabel,'[color="red"]'),
  ';
')
return
  if($edges eq '') then ''
  else concat($edges,';')
};

(:~
 : Generate the cluster for the external c++ libraries.
 :)
declare function z:create_subgraph_libraries() as xs:string
{
  concat('
  
    subgraph clusterExternalCPPLibs  { style=filled; color=darksalmon; node [shape=box3d, color=red];
    ',
    z:nodes_external_libraries(),'

',
    z:edges_libraries(),'
    label="External C++ Library dependencies"; }')
};

(:~
 : Generate the cluster for a specific category.
 :)
declare function z:create_subgraph(
  $category as xs:string) as xs:string
{
concat('
    subgraph cluster',
        index-of($z:level1Weight,$category),
        (:   '{ node [style=filled];  color=',data($category/@color),';   :)
        ' { style=filled; color=',$z:level1Colors[index-of($z:level1Weight,$category)],'; node [style=filled, color=white];
    ',
z:nodes_modules($category),'
',
'    label="',$category,'";','}')
};

(:~
 : Generate the BIG cluster.
 :)
declare function z:create_graph() as xs:string
{
    concat("digraph G { ",
            string-join(
              for $cat1 in  $z:level1Weight
              return z:create_subgraph($cat1)
              ,('
  ')), z:create_subgraph_libraries()
    ,"
  
",
  z:edges_modules(),"
  }"
  )
};
