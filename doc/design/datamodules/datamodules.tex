\documentclass[]{article}

% Use utf-8 encoding for foreign characters
% \usepackage[utf8]{inputenc}

% Setup for fullpage use
\usepackage{fullpage}

% Surround parts of graphics with box
\usepackage{boxedminipage}

% Package for including code in the document
\usepackage{listings}

% If you want to generate a toc for each chapter (use with book)
\usepackage{minitoc}

% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}

\ifpdf
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi
\title{Data Modules: Design and Implementation}
\author{  }

\date{\today}

\begin{document}

\ifpdf
\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
\else
\DeclareGraphicsExtensions{.eps, .jpg}
\fi

\maketitle


%%\begin{abstract}
%%TODO
%%\end{abstract}

\section{Introduction}
TODO 


\section{Extensions to XQuery 1.1}
Data access is wrapped into special \textit{Library Modules}. These are declared as \textit{Data Modules}:

\vspace{0.25cm}
\begin{tabular}{l c p{12cm}}
{\tt LibraryModule}  & ::= & {\tt ( ModuleDecl | DataModuleDecl ) Prolog} \\
{\tt DataModuleDecl} & ::= & {\tt "datamodule" "namespace" NCName "=" URILiteral\ Separator}
\end{tabular}

\vspace{0.5cm}
\noindent
Withing a \textit{Data Module}, the \textit{Prolog} can be extended by the \textit{Data Module} components \textit{Collection Declaration}, \textit{Index Declaration} and \textit{Integrity Constraint Declaration}:
\par
\vspace{0.25cm}
\begin{tabular}{l c p{12cm}}
{\tt Prolog}           & ::= & {\tt ((DefaultNamespaceDecl | Setter | NamespaceDecl | Import) Separator)* DataModuleProlog ((VarDecl | ContextItemDecl | FunctionDecl | OptionDecl) Separator)*} \\
{\tt DataModuleProlog} & ::= & {\tt ((CollectionDecl|IndexDecl|ICDecl) Separator)*} 
\end{tabular}

\subsection{Collection Declaration}
\begin{tabular}{l c p{12cm}}
{\tt CollectionDecl}  & ::= & {\tt "declare" CollDeclOptions "collection" URILiteral ("item-type" KindTest)? ((":=" ExprSingle) | "external")?} \\
{\tt CollDeclOptions} & ::= & {\tt ("read-only")? | (("append-only")? ("persistent")? ("versioned")? ) ... <TO BE COMPLETED> }
\end{tabular}

\paragraph{Question}
Does it really make sense to have the possibility to define initial values for persistent collections?

\vspace{0.5cm}
\noindent
[Definition: A collection declaration adds a pair $\left\langle  URILiteral, SequenceType \right\rangle$ to the set of statically known collections. The SequenceType is a sequence of items with the defined KindTest. If no KindTest is defined, the default is node().]

\paragraph{Errors}
\begin{itemize}
  \item \textbf{err:TBD}: It is a static error if multiple collection declarations specify the same URI.
  \item \textbf{err:TBD}: It is a static error if the collection declaration URI is a zero-length string.
  \item \textbf{err:TBD}: It is a static error if a collection declaration is in a module other than DataModule.
\end{itemize}

\paragraph{Remarks}
\begin{itemize}
  \item As in XQuery 1.1, collection must not be registered in the static context as long as they are not typed. Collections are registered in the dynamic context.
\end{itemize}

\paragraph{Examples}
\begin{verbatim}
import schema namespace sc="http://www.zorba-xquery.com/schemas/collection";

declare persistent collection "http://www.coll1.com" 
  item-type element() 
  := (<el id="1">a</el>,<el id="2">b</el>,<el id="3">c</el>);
\end{verbatim}
\begin{verbatim}
declare read-only collection "http://www.coll2.com" 
  item-type schema-element(sc:element) external;
\end{verbatim}
\begin{verbatim}
declare append-only collection "http://www.coll3.com";
\end{verbatim}

\paragraph{Alternatives}
It is very cumbersome (and error-prone) to use URIs to identify collections. Thus, it would be nice to bind the URI to a variable in the collection declaration:
\begin{verbatim}
declare datamodule namespace ns="http://www.namespace.com";
import schema namespace sc="http://www.zorba-xquery.com/schemas/collection";

declare persistent collection ns:coll1 at "http://www.coll1.com" 
  item-type element() 
  := (<el id="1">a</el>,<el id="2">b</el>,<el id="3">c</el>);
declare read-only collection ns:coll2 at "http://www.zorba-xquery.com/collection" 
  item-type schema-element(sc:element) external;

(: no cumbersome URIs have to be used in the code :)
fn:collection(ns:coll1),fn:collection(ns:coll2)
\end{verbatim}

\subsection{Index}
\subsubsection{Index Declaration}
\begin{tabular}{l c p{12cm}}
{\tt IndexDecl}   & ::= & {\tt "declare" ("unique")? ("ordered" | "unordered")? "index" URILiteral "on" ExprSingle "by" "(" ( IndexColumn ( "," IndexColumn )* ) ")"} \\
{\tt IndexColumn} & ::= & {\tt ExprSingle (TypeDeclaration) ("collation" URILiteral)?}
\end{tabular}

\paragraph{Errors}
\begin{itemize}
  \item \textbf{err:TBD}: It is a static error if an index declaration is in a module other than DataModule.
  \item \textbf{err:TBD}: It is a static error if any expression used in an index declaration has dependencies to the dynamic context.
  \item \textbf{err:TBD}: It is a static error if an index is dependent on non-existing collections (forward references are not allowed).
  \item \textbf{err:TBD}: It is a static error if an index is declared on a collection declared in a different module.
\end{itemize}

\paragraph{Examples}
\begin{verbatim}
declare ordered index "http://www.zorba-xquery.com/collection/index" 
  on fn:collection("http://www.coll1.com") by data(./@id) as xs:string;
()
\end{verbatim}

\begin{verbatim}
declare ordered index "http://www.zorba-xquery.com/collection/index" 
  on fn:collection(ns:coll1) by data(./@id) as xs:string;
()
\end{verbatim}


\subsubsection{Index Point Probe}
\begin{verbatim}
declare function op-extensions:probe-index-point(
                   $uri as xs:anyURI, 
                   $col1 as xs:anyAtomicType?, ...) as node()*
\end{verbatim}

\noindent
The function takes as many arguments as key columns in the index being probed, after the URI. The result is the sequence of nodes that were inserted into the index with the given key values.

\paragraph{Example}
\begin{verbatim}
op-extensions:probe-index-point("http://www.zorba-xquery.com/collection/index", 2)
\end{verbatim}

\subsubsection{Index Range Probe}
\begin{verbatim}
declare function op-extensions:probe-index-range(
                   $uri as xs:anyURI,
                   $col1_left as xs:anyAtomicType?,
                   $col1_right as xs:anyAtomicType?,
                   $col1_have_left as xs:boolean,
                   $col1_have_right as xs:boolean,
                   $col1_incl_left as xs:boolean,
                   $col1_incl_right as xs:boolean, ...) as node()*
\end{verbatim}

\noindent
The function takes six times as many arguments as key columns in the index being probed, after the URI. The result is the sequence of nodes that were inserted into the index with keys that fall in the given range. The col\_have arguments indicate if the corresponding bounds of the range are bounded or unbounded. The col\_incl arguments indicate if the corresponding bounds of the range are included. If a particular col\_have is false, the corresponding col\_incl must be false.

\paragraph{Example}
\begin{verbatim}
op-extensions:probe-index-range(
                "http://www.zorba-xquery.com/collection/index",
                2,
                (),
                true(),
                false(),
                true(),
                false())
\end{verbatim}

\paragraph{Simplification}
The two parameters \textit{have\_left} and \textit{have\_right} are unnecessary. Unbounded can be defined by giving an empty sequence as boundary.

\begin{verbatim}
op-extensions:probe-index-range(
                "http://www.zorba-xquery.com/collection/index",
                2,
                (),
                true(),
                false())
\end{verbatim}

\subsection{Integrity Constraint}
\subsubsection{Integrity Constraint Declaration}
\begin{tabular}{l c p{12cm}}
{\tt ICDecl}               & ::= & {\tt "declare" ("unchecked")? "integrity" "constraint" URILiteral (ICCollection | ICNode | ICForeignKey)} \\
{\tt ICCollection}         & ::= & {\tt "on" "collection" URILiteral (ICCollSequence|ICCollNode)} \\
{\tt ICCollSequence}       & ::= & {\tt "\$" QName "check" (ICCollSequenceEBV|ICCollSequenceUnique)} \\
{\tt ICCollSequenceEBV}    & ::= & {\tt  ExprSingle} \\
{\tt ICCollSequenceUnique} & ::= & {\tt "unique" "keys" "(" Expr ")"} \\
{\tt ICCollNode}           & ::= & {\tt "foreach" "node" "\$" QName "check" ExprSingle} \\
{\tt ICCollNode}           & ::= & {\tt "on" "node" "\$" QName "of" "type" KindTest "check" ExprSingle} \\
{\tt ICForeignKey}         & ::= & {\tt "foreign" "key" ICForeignKeySource ICForeignKeyTarget} \\
{\tt ICForeignKeySource}   & ::= & {\tt "from" ICForeignKeyValues} \\
{\tt ICForeignKeyTarget}   & ::= & {\tt "to" ICForeignKeyValues} \\
{\tt ICForeignKeyValues}   & ::= & {\tt "collection" URILiteral "node" "\$" QName "keys" "(" Expr ")"} 
\end{tabular}

\paragraph{Errors}
\begin{itemize}
  \item \textbf{err:TBD}: It is a static error if an integrity constraint declaration is in a module other than DataModule.
  \item \textbf{err:TBD}: It is a static error if any expression used in an integrity constraint declaration has dependencies to the dynamic context.
  \item \textbf{err:TBD}: It is a static error if an integrity contraint is dependent on non-existing collections (forward references are not allowed).
  \item \textbf{err:TBD}: It is a static error if the source collection is declared in a different module.
  \item \textbf{err:TBD}: It is a static error if any expression used in an integrity constraint declaration has dependencies to the dynamic context.
\end{itemize}

\paragraph{Examples}
\begin{verbatim}
declare integrity constraint "http://www.ic1.com" 
  on collection "http://www.coll1" $x check sum($x/size) le 1000;
\end{verbatim}

\begin{verbatim}
declare integrity constraint "http://www.ic2.com" 
  on collection "http://www.coll1" $x check unique keys $x/@id;
\end{verbatim}

\begin{verbatim}
declare integrity constraint "http://www.ic3.com" 
  on collection "http://www.coll1" foreach node $x check $x/size gt 0; 
\end{verbatim}

\begin{verbatim}
declare integrity constraint "http://www.ic4.com" 
  on node $x of type schmema-type(body) check $x/size gt 0; 
\end{verbatim}

\begin{verbatim}
declare integrity constraint "http://www.ic5.com" 
  foreign key 
    from collection "http://www.people.com" node $x keys ( $x/name) 
    to collection "http://www.houses.com" node &y keys ( $y/owner);
\end{verbatim}

\paragraph{Alternatives}
\begin{verbatim}
declare integrity constraint "http://www.ic5.com" 
  foreign key 
    from fn:collection("http://www.people.com")/name 
    to fn:collection("http://www.houses.com")/owner;
\end{verbatim}

\subsection{Data Module Declaration}
\begin{tabular}{l c p{12cm}}
{\tt ModuleImport} & ::= & {\tt "import" ("module" | "datamodule") ("namespace" NCName "=")? URILiteral ("at" URILiteral ("," URILiteral)*)? }
\end{tabular}

\vspace{0.5cm}
\noindent
[Definition: A data module import imports all collections, indexes and integrity contraints defined into the dynamic context.]

\section{Implementation in Zorba}
TODO
%%\paragraph{Stuff to delete}
%%\begin{itemize}
%%  \item delete collection and create collection
%%\end{itemize}
%%
%%\subsection{Parser}
%%\begin{itemize}
%%  \item extending parser/scanner to parse library module and declare collection
%%\end{itemize}
%%
%%\subsection{Translator}
%%\begin{itemize}
%%  \item collection declaration and functions to update collections are only usable in data modules => must be checked
%%  \item 
%%\end{itemize}
%%
%%\subsection{Context}
%%\begin{itemize}
%%  \item implementation of collection access similar to variable access (maybe)
%%  \item lazy creation of collection before they are accessed the first time
%%\end{itemize}
%%
%%\subsection{Runtime}
%%\begin{itemize}
%%  \item adopt functions to update collections (maybe) 
%%\end{itemize}

\end{document}
