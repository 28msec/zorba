\documentclass[]{article}

% Use utf-8 encoding for foreign characters
% \usepackage[utf8]{inputenc}

% Setup for fullpage use
\usepackage{fullpage}

% Surround parts of graphics with box
\usepackage{boxedminipage}

% Package for including code in the document
\usepackage{listings}

% If you want to generate a toc for each chapter (use with book)
\usepackage{minitoc}

% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}

\ifpdf
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi
\title{Data Modules: Design and Implementation}
\author{  }

\date{\today}

\begin{document}

\ifpdf
\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
\else
\DeclareGraphicsExtensions{.eps, .jpg}
\fi

\maketitle


%%\begin{abstract}
%%TODO
%%\end{abstract}

\section{Introduction}
TODO 


\section{Extensions to XQuery 1.1}
Data access is wrapped into special \textit{Library Modules}. These are declared as \textit{Data Modules}:

\vspace{0.25cm}
\begin{tabular}{l c p{12cm}}
{\tt LibraryModule}  & ::= & {\tt ( ModuleDecl | DataModuleDecl ) Prolog} \\
{\tt DataModuleDecl} & ::= & {\tt "datamodule" "namespace" NCName "=" URILiteral\ Separator}
\end{tabular}

\vspace{0.5cm}
\noindent
Withing a \textit{Data Module}, the \textit{Prolog} can be extended by the \textit{Data Module} components \textit{Collection Declaration}, \textit{Index Declaration} and \textit{Integrity Constraint Declaration}:
\par
\vspace{0.25cm}
\begin{tabular}{l c p{12cm}}
{\tt Prolog}           & ::= & {\tt "((DefaultNamespaceDecl | Setter | NamespaceDecl | Import) Separator)* DataModuleProlog ((VarDecl | ContextItemDecl | FunctionDecl | OptionDecl) Separator)*} \\
{\tt DataModuleProlog} & ::= & {\tt "((CollectionDecl|IndexDecl|ICDecl) Separator)*} 
\end{tabular}

\subsection{Collection Declaration}
\begin{tabular}{l c p{12cm}}
{\tt CollectionDecl} & ::= & {\tt "declare" ("append-only")? ("read-only")? ("persistent")? ("versioned")? "collection" URILiteral ("item-type" KindTest)? ((":=" ExprSingle) | "external")?}
\end{tabular}

\vspace{0.5cm}
\noindent
[Definition: A collection declaration adds a pair $\left\langle  URILiteral, SequenceType \right\rangle$ to the set of statically known collections. The SequenceType is a sequence of items with the defined KindTest\footnote{Is "as" missleading? It is used for SequenceType in the rest of the spec}. If no KindTest is defined, the default is node().]

\paragraph{Errors}
\begin{itemize}
  \item \textbf{err:TBD}: It is a static error if multiple collection declarations specify the same URI.
  \item \textbf{err:TBD}: It is a static error if the collection declaration URI is a zero-length string.
  \item \textbf{err:TBD}: It is a static error if a collection declaration is in a module other than DataModule.
\end{itemize}

\paragraph{Remarks}
\begin{itemize}
  \item As in XQuery 1.1, collection must not be registered in the static context as long as they are not typed. Collections are registered in the dynamic context.
\end{itemize}

\paragraph{Examples}
TODO

\subsection{Index}
\subsubsection{Index Declaration}
\begin{tabular}{l c p{12cm}}
{\tt IndexDecl}   & ::= & {\tt "declare" ("unique")? ("ordered" | "unordered")? "index" URILiteral "on" ExprSingle "by" "(" ( IndexColumn ( "," IndexColumn )* ) ")"} \\
{\tt IndexColumn} & ::= & {\tt ExprSingle (TypeDeclaration) ("collation" URILiteral)}
\end{tabular}

\paragraph{Errors}
\begin{itemize}
  \item \textbf{err:TBD}: It is a static error if any expression used in an index declaration has dependencies to the dynamic context.
  \item \textbf{err:TBD}: It is a static error if an index is dependent on non-existing collections (forward references are not allowed).
\end{itemize}

\paragraph{Examples}
TODO

\subsubsection{Index Access}
TODO

\subsection{Integrity Constraint}
\subsubsection{Integrity Constraint Declaration}
\begin{tabular}{l c p{12cm}}
{\tt ICDecl}               & ::= & {\tt "declare" ("unchecked")? "integrity" "constraint" URILiteral (ICCollection | ICNode | ICForeignKey)} \\
{\tt ICCollection}         & ::= & {\tt "on" "collection" URILiteral (ICCollSequence|ICCollNode)} \\
{\tt ICCollSequence}       & ::= & {\tt "\$" QName "check" (ICCollSequenceEBV|ICCollSequenceUnique)} \\
{\tt ICCollSequenceEBV}    & ::= & {\tt  ExprSingle} \\
{\tt ICCollSequenceUnique} & ::= & {\tt "unique" "keys" "(" Expr ")"} \\
{\tt ICCollNode}           & ::= & {\tt "on" "node" "\$" QName "of" "type" KindTest "check" ExprSingle} \\
{\tt ICForeignKey}         & ::= & {\tt "foreign" "key" ICForeignKeySource ICForeignKeyTarget} \\
{\tt ICForeignKeySource}   & ::= & {\tt "from" ICForeignKeyValues} \\
{\tt ICForeignKeyTarget}   & ::= & {\tt "to" ICForeignKeyValues} \\
{\tt ICForeignKeyValues}   & ::= & {\tt "collection" URILiteral "node" "\$" QName "keys" "(" Expr ")"} 
\end{tabular}

\paragraph{Errors}
\begin{itemize}
  \item \textbf{err:TBD}: It is a static error if any expression used in an integrity constraint declaration has dependencies to the dynamic context.
  \item \textbf{err:TBD}: It is a static error if an integrity contraint is dependent on non-existing collections (forward references are not allowed).
\end{itemize}

\paragraph{Examples}
TODO

\subsection{Data Module Declaration}
\begin{tabular}{l c p{12cm}}
{\tt ModuleImport} & ::= & {\tt "import" ("module" | "datamodule") ("namespace" NCName "=")? URILiteral ("at" URILiteral ("," URILiteral)*)? }
\end{tabular}

\vspace{0.5cm}
\noindent
[Definition: A data module import imports all collections, indexes and integrity contraints defined into the dynamic context.]

\paragraph{Errors}
\begin{itemize}
  \item \textbf{err:TBD}: It is a static error if a non-data module has side-effects on collections.
\end{itemize}

\section{Implementation in Zorba}
TODO
%%\paragraph{Stuff to delete}
%%\begin{itemize}
%%  \item delete collection and create collection
%%\end{itemize}
%%
%%\subsection{Parser}
%%\begin{itemize}
%%  \item extending parser/scanner to parse library module and declare collection
%%\end{itemize}
%%
%%\subsection{Translator}
%%\begin{itemize}
%%  \item collection declaration and functions to update collections are only usable in data modules => must be checked
%%  \item 
%%\end{itemize}
%%
%%\subsection{Context}
%%\begin{itemize}
%%  \item implementation of collection access similar to variable access (maybe)
%%  \item lazy creation of collection before they are accessed the first time
%%\end{itemize}
%%
%%\subsection{Runtime}
%%\begin{itemize}
%%  \item adopt functions to update collections (maybe) 
%%\end{itemize}

\end{document}
