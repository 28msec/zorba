<?php
$file = file_get_contents('@phpAPIPath@/zorba_api.php');
$file = str_replace('class Iterator {', 'class IteratorImpl {', $file);
$file = str_replace('extends Iterator {', 'extends IteratorImpl {', $file);
$file = str_replace('new Iterator(', 'new IteratorImpl(', $file);
$file = str_replace('!dl(', '!noop(', $file);
file_put_contents('@phpAPIPath@/zorba_api.php', $file);
$tokens = token_get_all($file);

require_once '@phpAPIPath@/zorba_api.php';

$wrapper = <<<PHP
<?php
//Try to load the extension if it's not already loaded.
if(!extension_loaded('zorba_api')) {
  if(strtolower(substr(PHP_OS, 0, 3)) === 'win') {
    if(!dl('php_zorba_api.dll')) return;
  } else {
    if(PHP_SHLIB_SUFFIX === 'PHP_SHLIB_SUFFIX' || PHP_SHLIB_SUFFIX === 'dylib') {
      if(!dl('zorba_api.so')) return;
    } else {
      if(!dl('zorba_api.' . PHP_SHLIB_SUFFIX)) return;
    }
  }
}
PHP;

$classes = get_declared_classes();

function noop($string){ return true; }

class ReturnType {
	
	private $class;
	private $method;
	private $type;
	
	public function __construct($class, $method, $type) {
		$this->class = $class;
		$this->method = $method;
		$this->type = $type;
	}
	
	public function getClass() { return $this->class; }
	public function getMethod(){ return $this->method; }
	public function getType(){ return $this->type; }
}

class Indexer {
	
	private $returnTypes = array();
	
	const CLAZZ = 1;
	const METHOD = 2;
	const TYPE = 3;
	
	public function __construct(array $tokens) {
		$state = null;
		$class = null;
		$method = null;
		foreach($tokens as $token) {
			if(is_string($token)) continue;
			list($name, $value) = array(token_name($token[0]), $token[1]);
			if($name == 'T_CLASS') {
				$state = self::CLAZZ;
			} else if($name == 'T_FUNCTION'){// && $class != null) {
				$state = self::METHOD;
			} else if($name == 'T_NEW'){// && $class != null && $method != null) {
				$state = self::TYPE;
			}
			if($name == "T_STRING") {
				switch($state) {
					case self::CLAZZ:
						$class = $value;
						break;
					case self::METHOD:
						$method = $value;
						break;
					case self::TYPE:
						$this->returnTypes[] = new ReturnType($class, $method, $value);
				}
				$state = null;
			}
		}
	}
	
	public function getType($class, $method) {
		foreach($this->returnTypes as $r) {
			if($r->getClass() == $class && $r->getMethod() == $method) {
				return $r->getType();
			} 
		}	
		return null;
	}
}

$indexer = new Indexer($tokens);

foreach($classes as $className) {
	$class = new ReflectionClass($className);
	if($class->isUserDefined() && $class->getName() != "Indexer" && $class->getName() != "ReturnType") {
		$wrapper .= "\nclass $className";
		$parent = $class->getParentClass();
		if($parent != null) {
			$wrapper .= " extends ".$parent->getName(); 
		}
		$wrapper .= "{\n";
		$contants = $class->getConstants();
		foreach($contants as $constant => $value) {
			$value = is_string($value)?"\"$value\"":$value;
			$wrapper .= "  const $constant = $value;\n";
		}
		$methods = $class->getMethods();
		if(count($methods)) {
			$wrapper .= "  public \$_cPtr=null;\n\n";
		}
		foreach($methods as $method){
                        if(isInHerited($class, $method)) continue;
			if($method->isConstructor()) {
				$wrapper .= <<<PHP
  public function __construct(\$ptr) {
  	\$this->_cPtr = \$ptr;
  }\n\n
PHP;
			} else {
				$name = $method->getName();
				$params = $method->getParameters();
				if($method->isStatic()) {
				  $wrapper .= "  static";
				}
				$wrapper .= "  public function $name(".getParameters($params).") {\n";
			       $funcName = $className=='IteratorImpl'?'Iterator':$className;	
                               if(hasOverloading($params)) {
                                  $wrapper .= "    switch(func_num_args()) {\n";
                                  $i = 1;
                                  foreach($params as $key=>$param) {
                                    if($param->isOptional()) {
                                      $i++;
				      if($i==2) {
                                        $first = false;
                                        $wrapper .= "    case 1: \$r =  {$className}_$name(".getRefParameters($method, array_slice($params, 0, $key)).");break;\n";
                                      }
                                      $wrapper .= "    case $i: \$r =  {$className}_$name(".getRefParameters($method, array_slice($params, 0, $key+1)).");break;\n";
                                      
                                    }
                                  } 
                                  $wrapper .= "    default: \$r =  {$className}_$name(".getRefParameters($method, $params).");\n";
				  $wrapper .= "    }\n";                     
				} else {
                                  $wrapper .= "    \$r =  {$funcName}_$name(".getRefParameters($method, $params).");\n";
				}
				$returnType = $indexer->getType($className, $method->getName());
				if($returnType) {
					$wrapper .= "    return is_resource(\$r) ? new ".$returnType."(\$r) : \$r;\n";
				} else {
					$wrapper .= "    return \$r;\n";
				}
				$wrapper .= "\n  }\n\n";
			}
		}
		$wrapper .= "}\n";
		$methods = $class->getConstants();
	}
}

file_put_contents('zorba_api_wrapper.php', $wrapper);

function getRefParameters(ReflectionMethod $method, array $params) {
	$result = "";
	if(!$method->isStatic()) {
		$result .= "\$this->_cPtr";
		if(count($params)) $result .= ", ";
	}
	foreach($params as $key=>$param) {
		if($key!=0) $result .= ', ';
		$result .= '$'.$param->getName();
	}
        return $result;
}

function getParameters(array $params) {
	$result = "";
	foreach($params as $key=>$param) {
		if($key!=0) $result .= ', ';
		$result .= '$'.$param->getName();
                if($param->isOptional()) {
                  $result .= '=null';
                }
	}
	return $result;
}

function hasOverloading(array $params) {
  foreach($params as $param) {
    if($param->isOptional()) {
      return true;
    }
  }
  return false;
}

function isInHerited(ReflectionClass $class, ReflectionMethod $method) {
  $parent = $class->getParentClass();
  if($parent) {
    if($parent->hasMethod($method->getName())) { return true; }
  }
  return false;
}
?>
