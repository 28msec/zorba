#!/usr/bin/env perl

# Copyright 2006-2008 The FLWOR Foundation.                                                             
#  
# Licensed under the Apache License, Version 2.0 (the "License");                                       
# you may not use this file except in compliance with the License.                                      
# You may obtain a copy of the License at
#  
# http://www.apache.org/licenses/LICENSE-2.0                                                            
#  
# Unless required by applicable law or agreed to in writing, software                                   
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.                              
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use warnings;

my @options;

sub long_to_getter {
    my $result = $1;
    $result =~ s/-(.)/\u$1/g;
    return $result;
}

sub load_options {
    while (<>) {
        if (m@ *\( *"([^,"]+)((,([^"]+))?)", *([a-zA-Z_]+::value< *(.*)> *\(&? *[a-zA-Z_]* *\)(->default_value *\( *(.*) *\))?, *)?"([^"]+)" *\)@) {
            my $short = $2 ? $4 : "";
            my $getter = long_to_getter ($1);
            my $member = "the" . (uc substr ($getter, 0, 1)) . substr ($getter, 1);
            my $type = "bool";
            my $has_val = 0;
            my $default;
            if ($5) {
                $has_val = 1;
                $type = $6;
                if ($7) { $default = $8; }
            } else {
                $default = "false";
            }
            push @options, { long => $1, short => $short, descr => $9, member => $member, getter => $getter, type => $type, has_val => $has_val, default => $default };
            # print "long $1 short $short mem $member\n";
        }
    }
}

sub print_long_opts {
    print "  const char **get_all_options () const {\n";
    print "    static const char *result [] = { ";
    for my $opt (@options) {
        print "\"--$opt->{long}\", ";
    }
    print "NULL };\n";
    print ("    return result;\n");
    print ("  }\n");
}

sub print_members {
    for my $opt (@options) {
        print <<"EOF";
  $opt->{type} $opt->{member};
EOF
    }
    print <<"EOF";

EOF
}

sub print_getters {
    for my $opt (@options) {
        print <<"EOF";
  $opt->{type} $opt->{getter} () const { return $opt->{member}; }
EOF
    }
    print <<"EOF";

EOF
}

sub print_help {
    print <<"EOF";
  const char *get_help_msg () {
    return
EOF

    for my $opt (@options) {
        my $short = $opt->{short};
        my $shorthlp = $short ? ", -$short" : "";
        print "\"--$opt->{long}$shorthlp\\n  $opt->{descr}\\n\\n\"\n";
    }
    
    print <<"EOF";
;
  }
EOF
}

sub print_load_argv {
    print <<"EOF";
  std::string load_argv (int argc, const char **argv) {
    if (argv == NULL) return "";

    std::string result;
    for (++argv; *argv != NULL; ++argv) {
      if (strcmp (*argv, "--help") == 0 || strcmp (*argv, "-h") == 0)
        return "!HELP";
      else if (strcmp (*argv, "--version") == 0)
        return "!VER";
EOF

    for my $opt (@options) {
        my $short = $opt->{short};
        my $shortcmp = ($short eq "") ? "" : " || strncmp (*argv, \"-$short\", 2) == 0";
        print <<"EOF";
      else if (strcmp (*argv, "--$opt->{long}") == 0$shortcmp) {
EOF
        if (! $opt->{has_val}) { print "        $opt->{member} = true;\n"; }
        else {
            print "        int d = 2;\n";
            print "        if ((*argv) [1] == '-' || (*argv) [2] == '\\0') { d = 0; ++argv; }\n";
            print "        init_val (*argv, $opt->{member}, d);\n";
        }
        print <<"EOF";
      }
EOF

    }

    print <<"EOF";
      else if (strcmp (*argv, "--") == 0) {
        copy_args (++argv);
        break;
      } else if ((*argv) [0] == '-') {
        result = "unknown command line option "; result += *argv; break; 
      } else {
        copy_args (argv);
        break;
      }
    }

    return result;
  }

EOF
}

sub print_init () {
    print <<"EOF";
  void initialize () {
EOF
    for my $opt (@options) {
        if (defined $opt->{default}) {
            print "    $opt->{member} = $opt->{default};\n";
        }
    }
    print <<"EOF";
  }
EOF
}

#
# Main
#

my $namespace = shift;
my @namespaces = split (/::/, $namespace);
my $classname = shift;
my $ifdef = $namespace;
$ifdef =~ s/::/_/g;
$ifdef = uc ($ifdef) . "_" . uc ($classname);

load_options;

print <<"EOF";
#include <string>
#include <sstream>
#include "util/properties_base.h"

#ifndef $ifdef
#define $ifdef
EOF

foreach my $ns (@namespaces) { print "namespace $ns { "; }
print "\n";

print <<"EOF";
class $classname : public PropertiesBase {
protected:
EOF

print_long_opts;

print_members;

print_init;

print "public:\n";

print_getters;

print_load_argv;

print_help;

print <<"EOF";

  static const $classname *instance () {
    static $classname result;
    return &result;
  }

  $classname () : PropertiesBase ()
  { initialize (); }

  
};

EOF

foreach my $ns (@namespaces) { print "} "; }
print "  // namespaces\n";

print <<"EOF";

#endif // $ifdef
EOF
