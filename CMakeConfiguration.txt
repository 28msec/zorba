# specify the standard configuration here
# 1. set the variable you want to use and assign it a default value
#    make sure you specify the datatype and the keyword CACHE to
#    tell cmake that it needs to store the value in its cache
# 2. print out a message showing the status of your variable
# 3. add your configuration parameter to include/zorba/config.h.cmake
#    for example for string variables use
#    #define ZORBA_BATCHING_TYPE    ${ZORBA_BATCHING_TYPE}
#    ${VARIABLE} is replaced by cmake using the value
#    that is set for this variable
#    for booleans (e.g. SET (ZORBA_VARIABLE OFF CACHE BOOL "zorba variable")), use
#    #cmakedefine VARIABLE
# 4. if you want to change your variable value, execute
#    cmake -DVARIABLE=new_value
#    the variable will keep this value (i.e. store it in the cache file CMakeCache.txt)
#    until you set a new one or edit the CMakeCache.txt file

# how should batching in the runtime system be done
SET(ZORBA_BATCHING_TYPE 0 CACHE STRING 
    "0 = NO_BATCHING, 1 = SIMPLE_BATCHING, 2 = SUPER_BATCHING") 
MESSAGE( STATUS "ZORBA_BATCHING_TYPE:      " ${ZORBA_BATCHING_TYPE} )

# number of items to batch if ZORBA_BATCHING_TYPE is SIMPLE_BATCHING or SUPER_BATCHING
IF (ZORBA_BATCHING_TYPE GREATER 0)
    SET(ZORBA_BATCHING_BATCHSIZE 100 CACHE STRING 
        "the batchsize used if batching is used")
    MESSAGE( STATUS "ZORBA_BATCHING_BATCHSIZE: " ${ZORBA_BATCHING_BATCHSIZE} )
ENDIF (ZORBA_BATCHING_TYPE GREATER 0)

# float point precision
SET(ZORBA_FLOAT_POINT_PRECISION 18 CACHE STRING
   "number of decimal places in floating point serialization")
MESSAGE( STATUS "ZORBA_FLOAT_POINT_PRECISION: " ${ZORBA_FLOAT_POINT_PRECISION} )


#specify the threading mechanism used
#for WIN32 you don't have to specify it
# one valid thread options must be present for any non win32 platform
IF (DEFINED UNIX)
  SET(ZORBA_THREAD "pthread" CACHE STRING "thread mechanism")
  MESSAGE(STATUS "ZORBA_THREAD [pthread/boost/singlethread]: " ${ZORBA_THREAD})

  IF(${ZORBA_THREAD} STREQUAL "pthread")
  	SET(ZORBA_USE_PTHREAD_LIBRARY	ON )
  ENDIF(${ZORBA_THREAD} STREQUAL "pthread")
  MESSAGE( STATUS "ZORBA_USE_PTHREAD_LIBRARY:      " ${ZORBA_USE_PTHREAD_LIBRARY} )

  IF(${ZORBA_THREAD} STREQUAL "boost")
  	SET(ZORBA_USE_BOOST_THREAD_LIBRARY	 ON )
  ENDIF(${ZORBA_THREAD} STREQUAL "boost")
  MESSAGE( STATUS "ZORBA_USE_BOOST_THREAD_LIBRARY: " ${ZORBA_USE_BOOST_THREAD_LIBRARY} )

	IF(${ZORBA_THREAD} STREQUAL "singlethread")
	SET(ZORBA_FOR_ONE_THREAD_ONLY	 ON )
	ENDIF(${ZORBA_THREAD} STREQUAL "singlethread")
	MESSAGE( STATUS "ZORBA_FOR_ONE_THREAD_ONLY:      " ${ZORBA_FOR_ONE_THREAD_ONLY} )

	IF (NOT DEFINED ZORBA_USE_PTHREAD_LIBRARY AND NOT DEFINED ZORBA_FOR_ONE_THREAD_ONLY AND NOT DEFINED ZORBA_USE_BOOST_THREAD_LIBRARY)
	MESSAGE( FATAL_ERROR "Unsupported thread system. For non WIN32 systems set ZORBA_THREAD=pthread, boost, or singlethread using the cmake -D ZORBA_THREAD=... option")
	ENDIF (NOT DEFINED ZORBA_USE_PTHREAD_LIBRARY AND NOT DEFINED ZORBA_FOR_ONE_THREAD_ONLY AND NOT DEFINED ZORBA_USE_BOOST_THREAD_LIBRARY)

ELSE (DEFINED UNIX)
  SET(ZORBA_THREAD "win32" CACHE STRING "thread mechanism")
  MESSAGE(STATUS "ZORBA_THREAD [win32/singlethread]: " ${ZORBA_THREAD})

	IF(${ZORBA_THREAD} STREQUAL "singlethread")
	SET(ZORBA_FOR_ONE_THREAD_ONLY	 ON )
	ENDIF(${ZORBA_THREAD} STREQUAL "singlethread")
	MESSAGE( STATUS "ZORBA_FOR_ONE_THREAD_ONLY:      " ${ZORBA_FOR_ONE_THREAD_ONLY} )

ENDIF (DEFINED UNIX) 



SET(ZORBA_BUILD_STATIC_LIBRARY OFF CACHE BOOL "build a static library, e.g. when creating a release")
MESSAGE(STATUS "ZORBA_BUILD_STATIC_LIBRARY:     " ${ZORBA_BUILD_STATIC_LIBRARY})

# flags for debugging the scanner
SET(ZORBA_DEBUG_SCANNER OFF CACHE BOOL "debug the scanner")
MESSAGE(STATUS "ZORBA_DEBUG_SCANNER:             " ${ZORBA_DEBUG_SCANNER})     

# flags for debugging the parser
SET(ZORBA_DEBUG_PARSER OFF CACHE BOOL "debug the parser")
MESSAGE(STATUS "ZORBA_DEBUG_PARSER:             " ${ZORBA_DEBUG_PARSER})     

# below we print some variables you might be interested in, when compiling

# if you are building in-source, this is the same as CMAKE_SOURCE_DIR, otherwise 
# this is the top level directory of your build tree 
MESSAGE( STATUS "CMAKE_BINARY_DIR:         " ${CMAKE_BINARY_DIR} )

# this is the directory, from which cmake was started, i.e. the top level source directory 
MESSAGE( STATUS "CMAKE_SOURCE_DIR:         " ${CMAKE_SOURCE_DIR} )

# the complete system name, e.g. "Linux-2.4.22", "FreeBSD-5.4-RELEASE" or "Windows 5.1" 
MESSAGE( STATUS "CMAKE_SYSTEM:             " ${CMAKE_SYSTEM} )

# the short system name, e.g. "Linux", "FreeBSD" or "Windows"
MESSAGE( STATUS "CMAKE_SYSTEM_NAME:        " ${CMAKE_SYSTEM_NAME} )

# only the version part of CMAKE_SYSTEM 
MESSAGE( STATUS "CMAKE_SYSTEM_VERSION:     " ${CMAKE_SYSTEM_VERSION} )

# the processor name (e.g. "Intel(R) Pentium(R) M processor 2.00GHz") 
MESSAGE( STATUS "CMAKE_SYSTEM_PROCESSOR:   " ${CMAKE_SYSTEM_PROCESSOR} )

# is TRUE on all UNIX-like OS's, including Apple OS X and CygWin
MESSAGE( STATUS "UNIX:                     " ${UNIX} )

# is TRUE on Windows, including CygWin 
MESSAGE( STATUS "WIN32:                    " ${WIN32} )

# is TRUE on Apple OS X
MESSAGE( STATUS "APPLE:                    " ${APPLE} )

# is TRUE when using the MinGW compiler in Windows
MESSAGE( STATUS "MINGW:                    " ${MINGW} )

# is TRUE on Windows when using the CygWin version of cmake
MESSAGE( STATUS "CYGWIN:                   " ${CYGWIN} )

# is TRUE on Windows when using a Borland compiler 
MESSAGE( STATUS "BORLAND:                  " ${BORLAND} )

# Microsoft compiler 
MESSAGE( STATUS "MSVC:                     " ${MSVC} )
MESSAGE( STATUS "MSVC_IDE:                 " ${MSVC_IDE} )
MESSAGE( STATUS "MSVC60:                   " ${MSVC60} )
MESSAGE( STATUS "MSVC70:                   " ${MSVC70} )
MESSAGE( STATUS "MSVC71:                   " ${MSVC71} )
MESSAGE( STATUS "MSVC80:                   " ${MSVC80} )
MESSAGE( STATUS "CMAKE_COMPILER_2005:      " ${CMAKE_COMPILER_2005} )

# A simple way to get switches to the compiler is to use ADD_DEFINITIONS(). 
# But there are also two variables exactly for this purpose: 

# the compiler flags for compiling C sources 
MESSAGE( STATUS "CMAKE_C_FLAGS:            " ${CMAKE_C_FLAGS} )

# the compiler flags for compiling C++ sources 
MESSAGE( STATUS "CMAKE_CXX_FLAGS:          " ${CMAKE_CXX_FLAGS} )

# Choose the type of build.  Example: SET(CMAKE_BUILD_TYPE Debug) 
MESSAGE( STATUS "CMAKE_BUILD_TYPE:         " ${CMAKE_BUILD_TYPE} )

# if this is set to ON, then all libraries are built as shared libraries by default.
MESSAGE( STATUS "BUILD_SHARED_LIBS:        " ${BUILD_SHARED_LIBS} )

# the compiler used for C files 
MESSAGE( STATUS "CMAKE_C_COMPILER:         " ${CMAKE_C_COMPILER} )

# the compiler used for C++ files 
MESSAGE( STATUS "CMAKE_CXX_COMPILER:       " ${CMAKE_CXX_COMPILER} )

# if the compiler is a variant of gcc, this should be set to 1 
MESSAGE( STATUS "CMAKE_COMPILER_IS_GNUCC:  " ${CMAKE_COMPILER_IS_GNUCC} )

# if the compiler is a variant of g++, this should be set to 1 
MESSAGE( STATUS "CMAKE_COMPILER_IS_GNUCXX: " ${CMAKE_COMPILER_IS_GNUCXX} )

# the tools for creating libraries 
MESSAGE( STATUS "CMAKE_AR:                 " ${CMAKE_AR} )
MESSAGE( STATUS "CMAKE_RANLIB:             " ${CMAKE_RANLIB} )

