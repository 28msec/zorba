# Copyright 2006-2008 The FLWOR Foundation.
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
# http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# specify the standard configuration here
# 1. set the variable you want to use and assign it a default value
#    make sure you specify the datatype and the keyword CACHE to
#    tell cmake that it needs to store the value in its cache
# 2. print out a message showing the status of your variable
# 3. add your configuration parameter to include/zorba/config.h.cmake
#    for example for string variables use
#    #define ZORBA_BATCHING_TYPE    ${ZORBA_BATCHING_TYPE}
#    ${VARIABLE} is replaced by cmake using the value
#    that is set for this variable
#    for booleans (e.g. SET (ZORBA_VARIABLE OFF CACHE BOOL "zorba variable")), use
#    #cmakedefine VARIABLE
# 4. if you want to change your variable value, execute
#    cmake -DVARIABLE=new_value
#    the variable will keep this value (i.e. store it in the cache file CMakeCache.txt)
#    until you set a new one or edit the CMakeCache.txt file
#
SET(ZORBA_MINIMAL_STORE  OFF CACHE BOOL "Choose zorba minimal store for better performance")
MESSAGE(STATUS "ZORBA_MINIMAL_STORE:               " ${ZORBA_MINIMAL_STORE})

SET(ZORBA_NATIVE_STORE  ON CACHE BOOL "Choose zorba native store")
MESSAGE(STATUS "ZORBA_NATIVE_STORE:               " ${ZORBA_NATIVE_STORE})

# Adding store srcs
IF (ZORBA_MINIMAL_STORE)
  SET(ZORBA_STORE_DIRS "${CMAKE_SOURCE_DIR}/src/store/minimal" CACHE PATHS
    "Path to the store directories. Must contain CMakeLists.txt defining the variables ZORBA_STORE_IMPL_SRCS and ZORBA_STORE_LIB_EXTENSION." FORCE)
ELSE (ZORBA_MINIMAL_STORE)
  IF(ZORBA_NATIVE_STORE)
    SET(ZORBA_STORE_DIRS "${CMAKE_SOURCE_DIR}/src/store/naive" CACHE PATH "Path to the store directories. Must contain CMakeLists.txt defining the variable ZORBA_STORE_IMPL_SRCS.") 
    SET(ZORBA_STORE_NAMES "simplestore" CACHE STRING "Names of the stores. Must have be in sync with ZORBA_STORE_DIRS")
  ENDIF (ZORBA_NATIVE_STORE)
ENDIF (ZORBA_MINIMAL_STORE)

MESSAGE(STATUS "ZORBA_STORE_DIRS " ${ZORBA_STORE_DIRS})
MESSAGE(STATUS "ZORBA_STORE_NAMES " ${ZORBA_STORE_NAMES})

# how should batching in the runtime system be done
SET(ZORBA_BATCHING_TYPE 0 CACHE STRING 
    "0 = NO_BATCHING, 1 = SIMPLE_BATCHING, 2 = SUPER_BATCHING") 
MESSAGE( STATUS "ZORBA_BATCHING_TYPE:      " ${ZORBA_BATCHING_TYPE} )

# number of items to batch if ZORBA_BATCHING_TYPE is SIMPLE_BATCHING or SUPER_BATCHING
IF (ZORBA_BATCHING_TYPE GREATER 0)
    SET(ZORBA_BATCHING_BATCHSIZE 100 CACHE STRING 
        "the batchsize used if batching is used")
    MESSAGE( STATUS "ZORBA_BATCHING_BATCHSIZE: " ${ZORBA_BATCHING_BATCHSIZE} )
ENDIF (ZORBA_BATCHING_TYPE GREATER 0)

# float point precision
SET(ZORBA_FLOAT_POINT_PRECISION 18 CACHE STRING
   "number of decimal places in floating point serialization")
MESSAGE( STATUS "ZORBA_FLOAT_POINT_PRECISION: " ${ZORBA_FLOAT_POINT_PRECISION} )

# code coverage information
SET(ZORBA_WITH_CODE_COVERAGE OFF CACHE BOOL "compile the code with information for a code coverage analysis")
MESSAGE( STATUS "ZORBA_WITH_CODE_COVERAGE: " ${ZORBA_WITH_CODE_COVERAGE})

# code profile information
SET(ZORBA_WITH_CODE_PROFILE OFF CACHE BOOL "compile the code with information for a code profiling analysis")
MESSAGE( STATUS "ZORBA_WITH_CODE_PROFILE: " ${ZORBA_WITH_CODE_PROFILE})

SET(ZORBA_FOR_ONE_THREAD_ONLY OFF CACHE BOOL "compile zorba for single threaded use")
MESSAGE( STATUS "ZORBA_FOR_ONE_THREAD_ONLY: " ${ZORBA_FOR_ONE_THREAD_ONLY})

IF (DEFINED UNIX)

	IF (NOT DEFINED ZORBA_HAVE_PTHREAD_H AND NOT DEFINED ZORBA_FOR_ONE_THREAD_ONLY) 
	MESSAGE( FATAL_ERROR "pthread is not available")
	ENDIF (NOT DEFINED ZORBA_HAVE_PTHREAD_H AND NOT DEFINED ZORBA_FOR_ONE_THREAD_ONLY) 

ELSE (DEFINED UNIX)

  SET(ZORBA_WIN_PLATFORM "win32" CACHE STRING "win platform")
  MESSAGE(STATUS "ZORBA_WIN_PLATFORM [win32/pocketpc/smartphone]: " ${ZORBA_WIN_PLATFORM})
  
  IF("${ZORBA_WIN_PLATFORM}" STREQUAL "pocketpc" OR "${ZORBA_WIN_PLATFORM}" STREQUAL "smartphone")
    SET(WINCE ON)
    SET(WIN32 OFF)
  ENDIF("${ZORBA_WIN_PLATFORM}" STREQUAL "pocketpc" OR "${ZORBA_WIN_PLATFORM}" STREQUAL "smartphone")

ENDIF (DEFINED UNIX) 

SET(ZORBA_WITH_FILE_ACCESS ON CACHE BOOL "compile zorba and allow loading documents from the filesystem")
MESSAGE(STATUS "ZORBA_WITH_FILE_ACCESS [ON/OFF]:" ${ZORBA_WITH_FILE_ACCESS})

SET(ZORBA_TEST_TIMEOUT_VALUE 60 CACHE INTEGER "default test timeout value")
MESSAGE(STATUS "ZORBA_TEST_TIMEOUT_VALUE ${ZORBA_TEST_TIMEOUT_VALUE}")

# curl headers don't seem to work on darwin
#IF (APPLE )
#  SET(ZORBA_WITH_REST OFF CACHE BOOL "No REST for the Mac")
#ENDIF (APPLE)

# make 10.4 the default sysroot on apple, i.e. always build for 10.4 minimum
IF (APPLE)
  SET(CMAKE_OSX_SYSROOT CACHE STRING "/Developer/SDKs/MacOSX10.4u.sdk")
  SET ( CMAKE_SHARED_LINKER_FLAGS "-Wl-syslibroot,${CMAKE_OSX_SYSROOT} -mmacosx-version-min=10.4 ${CMAKE_SHARED_LINKER_FLAGS}" )
  SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}  -I/usr/local/include -mmacosx-version-min=10.4" )
  SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS}  -I/usr/local/include -mmacosx-version-min=10.4" )
ENDIF (APPLE)

IF ( CURL_FOUND )
  SET(ZORBA_WITH_REST ON CACHE BOOL "Compile Zorba with REST support")
  SET(ZORBA_VERIFY_PEER_SSL_CERTIFICATE OFF CACHE BOOL "Disable root certificate validation")
  MESSAGE(STATUS "ZORBA_VERIFY_PEER_SSL_CERTIFICATE     " ${ZORBA_VERIFY_PEER_SSL_CERTIFICATE})
  SET(ZORBA_WITH_SSL ON CACHE BOOL "Compile zorba to be able to do https calls")
  MESSAGE ( STATUS "ZORBA_WITH_SSL: " ${ZORBA_WITH_SSL})
ELSE (CURL_FOUND )
  MESSAGE ( STATUS "Can't build Zorba with REST support because Curl is not found.")
  SET(ZORBA_WITH_REST OFF CACHE BOOL "No REST support" FORCE )
  MESSAGE ( STATUS "Setting REST off" )
  SET(ZORBA_WITH_SSL OFF CACHE BOOL "No SSL support" FORCE )
  MESSAGE ( STATUS "ZORBA_WITH_SSL: " ${ZORBA_WITH_SSL})
ENDIF (CURL_FOUND )

#IF ( JNI_FOUND )
#  SET(ZORBA_WITH_FOP ON CACHE BOOL "Compile Zorba with XSL-FO support" FORCE)
#ELSE ( JNI_FOUND )
  SET(ZORBA_WITH_FOP "OFF" CACHE BOOL "FOP-Support" FORCE)
#  MESSAGE(STATUS "Compile Zorba without XSL-FO support")
#ENDIF ( JNI_FOUND )

MESSAGE ( STATUS "ZORBA_WITH_REST: " ${ZORBA_WITH_REST} )

IF ( LIBTIDY_FOUND )
  SET(ZORBA_WITH_TIDY ON CACHE BOOL "Compile Zorba with TIDY support")
ELSE ( LIBTIDY_FOUND )
  MESSAGE ( STATUS "Can't build Zorba with TIDY support because TIDY is not found.")
  SET(ZORBA_WITH_TIDY OFF CACHE BOOL "No TIDY support" FORCE )
  MESSAGE ( STATUS "Setting TIDY off" )
ENDIF ( LIBTIDY_FOUND )
MESSAGE ( STATUS "ZORBA_WITH_TIDY: " ${ZORBA_WITH_TIDY} )

IF ( ${ZORBA_WITH_CODE_PROFILE} )
SET(ZORBA_BUILD_STATIC_LIBRARY ON CACHE BOOL "build a static library, e.g. when creating a profile")
ELSE (${ZORBA_WITH_CODE_PROFILE} )
SET(ZORBA_BUILD_STATIC_LIBRARY OFF CACHE BOOL "build a static library, e.g. when creating a release")
ENDIF ( ${ZORBA_WITH_CODE_PROFILE} )

MESSAGE(STATUS "ZORBA_BUILD_STATIC_LIBRARY:     " ${ZORBA_BUILD_STATIC_LIBRARY})

IF (MSVC AND NOT ZORBA_BUILD_STATIC_LIBRARY)
  SET(ZORBA_WIN_DLL   ON)
  MESSAGE(STATUS "ZORBA_WIN_DLL         ON")
ELSE (MSVC AND NOT ZORBA_BUILD_STATIC_LIBRARY)
  SET(ZORBA_WIN_DLL   OFF)
ENDIF (MSVC AND NOT ZORBA_BUILD_STATIC_LIBRARY)
   
# We need the path to the zorba executable because it will be used during the
# build to generate source code and documentation.
IF (WIN32)
  FILE(TO_NATIVE_PATH ${CMAKE_BINARY_DIR} WIN_CMAKE_BINARY_DIR)
  IF (MSVC_IDE)
    SET(ZORBA_EXE_PATH_TMP "${WIN_CMAKE_BINARY_DIR}\\bin\\${CMAKE_BUILD_TYPE}\\zorba.exe")
  ELSE (MSVC_IDE)
    SET(ZORBA_EXE_PATH_TMP "${WIN_CMAKE_BINARY_DIR}\\bin\\zorba.exe")
  ENDIF (MSVC_IDE)
ELSE (WIN32)
  SET(ZORBA_EXE_PATH_TMP "${CMAKE_BINARY_DIR}/bin/zorba")
ENDIF (WIN32)
SET(ZORBA_EXE_PATH ${ZORBA_EXE_PATH_TMP} CACHE STRING "executable used for generating the runtime")
MESSAGE(STATUS "ZORBA_EXE_PATH:        " ${ZORBA_EXE_PATH})

IF (WIN32)
  SET(ZORBA_EXE_SCRIPT_TMP "${WIN_CMAKE_BINARY_DIR}\\scripts\\zorba_cmake.bat")
ELSE (WIN32)
  SET(ZORBA_EXE_SCRIPT_TMP "${ZORBA_EXE_PATH}")
ENDIF (WIN32)
SET(ZORBA_EXE_SCRIPT ${ZORBA_EXE_SCRIPT_TMP} CACHE STRING "executable used for generating the runtime")
MESSAGE(STATUS "ZORBA_EXE_SCRIPT:        " ${ZORBA_EXE_SCRIPT})

# flags for debugging the parser
SET(ZORBA_DEBUG_PARSER OFF CACHE BOOL "debug the parser")
MESSAGE(STATUS "ZORBA_DEBUG_PARSER:             " ${ZORBA_DEBUG_PARSER})     

SET(ZORBA_NO_UNICODE OFF CACHE BOOL "disable ICU")
MESSAGE(STATUS "ZORBA_NO_UNICODE:                 " ${ZORBA_NO_UNICODE})

SET(ZORBA_NO_XMLSCHEMA OFF CACHE BOOL "disable XMLSchema support")
MESSAGE(STATUS "ZORBA_NO_XMLSCHEMA:               " ${ZORBA_NO_XMLSCHEMA})

SET(ZORBA_NO_BIGNUMBERS OFF CACHE BOOL "disable MAPM")
MESSAGE(STATUS "ZORBA_NO_BIGNUMBERS:               " ${ZORBA_NO_BIGNUMBERS})

SET(ZORBA_NUMERIC_OPTIMIZATION OFF CACHE BOOL "enable special numeric optimizations")
MESSAGE(STATUS "ZORBA_NUMERIC_OPTIMIZATION:               " ${ZORBA_NUMERIC_OPTIMIZATION})

SET(ZORBA_USE_SWIG ON CACHE BOOL "use Swig to generate api for Python, Php and Ruby")
MESSAGE(STATUS "ZORBA_USE_SWIG:               " ${ZORBA_USE_SWIG})

SET(ZORBA_USE_SEPARATE_WINCE_SVN OFF CACHE BOOL "Daniel's flag")

SET(ZORBA_XQUERYX OFF CACHE BOOL "Activate capability to compile XQueryX code (on/off)")
MESSAGE(STATUS "ZORBA_XQUERYX:                " ${ZORBA_XQUERYX})

SET(ZORBA_TEST_XQUERYX OFF CACHE BOOL "Test only xqueryx (.xqx) tests")
MESSAGE(STATUS "ZORBA_TEST_XQUERYX:                " ${ZORBA_TEST_XQUERYX})

# below we print some variables you might be interested in, when compiling

# if you are building in-source, this is the same as CMAKE_SOURCE_DIR, otherwise 
# this is the top level directory of your build tree 
MESSAGE( STATUS "CMAKE_BINARY_DIR:         " ${CMAKE_BINARY_DIR} )

# this is the directory, from which cmake was started, i.e. the top level source directory 
MESSAGE( STATUS "CMAKE_SOURCE_DIR:         " ${CMAKE_SOURCE_DIR} )

# the complete system name, e.g. "Linux-2.4.22", "FreeBSD-5.4-RELEASE" or "Windows 5.1" 
MESSAGE( STATUS "CMAKE_SYSTEM:             " ${CMAKE_SYSTEM} )

# the short system name, e.g. "Linux", "FreeBSD" or "Windows"
MESSAGE( STATUS "CMAKE_SYSTEM_NAME:        " ${CMAKE_SYSTEM_NAME} )

# only the version part of CMAKE_SYSTEM 
MESSAGE( STATUS "CMAKE_SYSTEM_VERSION:     " ${CMAKE_SYSTEM_VERSION} )

# the processor name (e.g. "Intel(R) Pentium(R) M processor 2.00GHz") 
MESSAGE( STATUS "CMAKE_SYSTEM_PROCESSOR:   " ${CMAKE_SYSTEM_PROCESSOR} )

# is TRUE on all UNIX-like OS's, including Apple OS X and CygWin
MESSAGE( STATUS "UNIX:                     " ${UNIX} )

# is TRUE on Windows, including CygWin 
MESSAGE( STATUS "WIN32:                    " ${WIN32} )

# is TRUE on Apple OS X
MESSAGE( STATUS "APPLE:                    " ${APPLE} )

# is TRUE when using the MinGW compiler in Windows
MESSAGE( STATUS "MINGW:                    " ${MINGW} )

# is TRUE on Windows when using the CygWin version of cmake
MESSAGE( STATUS "CYGWIN:                   " ${CYGWIN} )

# is TRUE on Windows when using a Borland compiler 
MESSAGE( STATUS "BORLAND:                  " ${BORLAND} )

# Microsoft compiler 
MESSAGE( STATUS "MSVC:                     " ${MSVC} )
MESSAGE( STATUS "MSVC_IDE:                 " ${MSVC_IDE} )
MESSAGE( STATUS "MSVC60:                   " ${MSVC60} )
MESSAGE( STATUS "MSVC70:                   " ${MSVC70} )
MESSAGE( STATUS "MSVC71:                   " ${MSVC71} )
MESSAGE( STATUS "MSVC80:                   " ${MSVC80} )
MESSAGE( STATUS "CMAKE_COMPILER_2005:      " ${CMAKE_COMPILER_2005} )

# A simple way to get switches to the compiler is to use ADD_DEFINITIONS(). 
# But there are also two variables exactly for this purpose: 

IF ( ${ZORBA_WITH_CODE_PROFILE} )
  IF ( APPLE )
    SET ( CMAKE_C_FLAGS "-finstrument-functions -Wl,-lSaturn ${CMAKE_C_FLAGS}" )
    SET ( CMAKE_CXX_FLAGS "-finstrument-functions  -Wl,-lSaturn ${CMAKE_CXX_FLAGS}" )
  ELSE (APPLE)
    SET ( CMAKE_C_FLAGS "-pg ${CMAKE_C_FLAGS}" )
    SET ( CMAKE_CXX_FLAGS "-pg ${CMAKE_CXX_FLAGS}" )
  ENDIF (APPLE)
ENDIF ( ${ZORBA_WITH_CODE_PROFILE} )

# the compiler flags for compiling C sources 
MESSAGE( STATUS "CMAKE_C_FLAGS:            " ${CMAKE_C_FLAGS} )

# the compiler flags for compiling C++ sources 
MESSAGE( STATUS "CMAKE_CXX_FLAGS:          " ${CMAKE_CXX_FLAGS} )

# Choose the type of build.  Example: SET(CMAKE_BUILD_TYPE Debug) 
MESSAGE( STATUS "CMAKE_BUILD_TYPE:         " ${CMAKE_BUILD_TYPE} )

# if this is set to ON, then all libraries are built as shared libraries by default.
MESSAGE( STATUS "BUILD_SHARED_LIBS:        " ${BUILD_SHARED_LIBS} )

# the compiler used for C files 
MESSAGE( STATUS "CMAKE_C_COMPILER:         " ${CMAKE_C_COMPILER} )

# the compiler used for C++ files 
MESSAGE( STATUS "CMAKE_CXX_COMPILER:       " ${CMAKE_CXX_COMPILER} )

# if the compiler is a variant of gcc, this should be set to 1 
MESSAGE( STATUS "CMAKE_COMPILER_IS_GNUCC:  " ${CMAKE_COMPILER_IS_GNUCC} )

# if the compiler is a variant of g++, this should be set to 1 
MESSAGE( STATUS "CMAKE_COMPILER_IS_GNUCXX: " ${CMAKE_COMPILER_IS_GNUCXX} )

# the tools for creating libraries 
MESSAGE( STATUS "CMAKE_AR:                 " ${CMAKE_AR} )
MESSAGE( STATUS "CMAKE_RANLIB:             " ${CMAKE_RANLIB} )

IF (LIBXML2_FOUND)
     SET(ZORBA_WITH_LIBXML2_SAX ON CACHE BOOL "compile with a sax parser for libxml2")
ELSE (LIBXML2_FOUND)
     SET(ZORBA_WITH_LIBXML2_SAX ON CACHE BOOL "compile with a sax parser for libxml2")
ENDIF (LIBXML2_FOUND)

