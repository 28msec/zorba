/* The following code was generated by JFlex 1.3.5 on 7/11/04 2:35 PM */

package com.bluecast.xml;

import org.xml.sax.*;
import org.xml.sax.helpers.*;
import com.bluecast.util.*;
import com.bluecast.io.*;
import java.util.*;
import java.io.*;

/*
 * $Id: PiccoloLexer.flex,v 1.7 2004/07/11 09:38:00 yuvalo Exp $
 *
 * 2003-06-10 - MODIFIED to provide access to <?xml?> definition
 *              and better track line numbers.
 *
 * (C) Copyright 2002-2004 by Yuval Oren. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */



/**
 * This class is a scanner generated by 
 * <a href="http://www.jflex.de/">JFlex</a> 1.3.5
 * on 7/11/04 2:35 PM from the specification file
 * <tt>file:/C:/Library/Projects/piccolo/src/com/bluecast/xml/PiccoloLexer.flex</tt>
 */
final class PiccoloLexer {
  /* This jflex-skeleton MODIFIED 2003-06-10 to fix several piccolo bugs. */

  /** This character denotes the end of file */
  final public static int YYEOF = -1;

  /** initial size of the lookahead buffer */
  final private static int YY_BUFFERSIZE = 16384;

  /** lexical states */
  final public static int DTD_TAG_START = 31;
  final public static int CLOSE_TAG_NS = 20;
  final public static int DTD_IGNORE = 28;
  final public static int PI = 4;
  final public static int DTD_TAG_SQSTRING_BUFFERED = 35;
  final public static int TAG_VALUE_ENTITY = 11;
  final public static int ENTITYREF = 3;
  final public static int DTD_ATT_NAME = 23;
  final public static int DTD_TAG = 30;
  final public static int DTD_TAG_VALUE_EXTERNAL_ENTITY = 33;
  final public static int TAG = 6;
  final public static int TAG_VALUE_ENTITYREF = 12;
  final public static int YYINITIAL = 0;
  final public static int DTD_TAG_VALUE_PARAM_ENTITYREF = 37;
  final public static int TAG_NS = 8;
  final public static int DTD_NMTOKENS = 26;
  final public static int TAG_SQSTRING_NORMALIZE = 16;
  final public static int DTD_PUBLIC_ID = 29;
  final public static int XML_TAG = 1;
  final public static int TAG_QSTRING_NORMALIZE = 15;
  final public static int TAG_START = 7;
  final public static int DTD_COMMENT = 27;
  final public static int DTD_TAG_VALUE_ENTITY = 32;
  final public static int TAG_QSTRING_CDATA_BUFFERED = 13;
  final public static int TAG_SQSTRING_CDATA_BUFFERED = 14;
  final public static int DTD_TAG_VALUE_STD_ENTITYREF = 36;
  final public static int PI_WS = 5;
  final public static int DTD_TAG_QSTRING_BUFFERED = 34;
  final public static int TAG_START_NS = 9;
  final public static int DTD_ATTLIST_ELEMENT = 22;
  final public static int DTD_ATT_TYPE = 24;
  final public static int DTD_ENTITY_DECL = 25;
  final public static int TAG_QSTRING_NORMALIZE_BUFFERED = 17;
  final public static int TAG_SQSTRING_NORMALIZE_BUFFERED = 18;
  final public static int TAG_VALUE = 10;
  final public static int CLOSE_TAG = 19;
  final public static int YYINITIAL_DIRECT = 2;
  final public static int DTD = 21;

  /** 
   * Translates characters to character classes
   */
  final private static String yycmap_packed = 
    "\11\0\1\1\1\72\2\0\1\6\22\0\1\20\1\30\1\64\1\54"+
    "\1\5\1\25\1\13\1\65\1\50\1\57\1\60\1\61\1\62\1\41"+
    "\1\2\1\66\12\11\1\3\1\26\1\12\1\71\1\24\1\14\1\5"+
    "\1\36\1\53\1\43\1\44\1\31\1\46\1\56\1\4\1\34\1\4"+
    "\1\47\1\23\1\22\1\32\1\40\1\51\1\55\1\45\1\37\1\33"+
    "\1\52\2\4\1\21\1\35\1\4\1\42\1\0\1\27\1\0\1\4"+
    "\1\0\1\73\5\102\1\101\4\4\1\17\1\16\1\67\1\77\1\74"+
    "\1\75\1\4\1\70\1\100\1\76\2\4\1\15\2\4\1\0\1\63"+
    "\72\0\1\10\10\0\27\7\1\0\37\7\1\0\72\7\2\0\13\7"+
    "\2\0\10\7\1\0\65\7\1\0\104\7\11\0\44\7\3\0\2\7"+
    "\4\0\36\7\70\0\131\7\22\0\7\7\16\0\2\10\56\0\106\10"+
    "\32\0\2\10\44\0\1\7\1\10\3\7\1\0\1\7\1\0\24\7"+
    "\1\0\54\7\1\0\7\7\3\0\1\7\1\0\1\7\1\0\1\7"+
    "\1\0\1\7\1\0\22\7\15\0\14\7\1\0\102\7\1\0\14\7"+
    "\1\0\44\7\1\0\4\10\11\0\65\7\2\0\2\7\2\0\2\7"+
    "\3\0\34\7\2\0\10\7\2\0\2\7\67\0\46\7\2\0\1\7"+
    "\7\0\46\7\12\0\21\10\1\0\27\10\1\0\3\10\1\0\1\10"+
    "\1\0\2\10\1\0\1\10\13\0\33\7\5\0\3\7\56\0\32\7"+
    "\5\0\1\10\12\7\10\10\15\0\12\10\6\0\1\10\107\7\2\0"+
    "\5\7\1\0\17\7\1\0\4\7\1\0\1\7\17\10\2\7\2\10"+
    "\1\0\4\10\2\0\12\10\u0207\0\3\10\1\0\65\7\2\0\1\10"+
    "\1\7\20\10\3\0\4\10\3\0\12\7\2\10\2\0\12\10\21\0"+
    "\3\10\1\0\10\7\2\0\2\7\2\0\26\7\1\0\7\7\1\0"+
    "\1\7\3\0\4\7\2\0\1\10\1\0\7\10\2\0\2\10\2\0"+
    "\3\10\11\0\1\10\4\0\2\7\1\0\3\7\2\10\2\0\12\10"+
    "\2\7\20\0\1\10\2\0\6\7\4\0\2\7\2\0\26\7\1\0"+
    "\7\7\1\0\2\7\1\0\2\7\1\0\2\7\2\0\1\10\1\0"+
    "\5\10\4\0\2\10\2\0\3\10\13\0\4\7\1\0\1\7\7\0"+
    "\12\10\2\10\3\7\14\0\3\10\1\0\7\7\1\0\1\7\1\0"+
    "\3\7\1\0\26\7\1\0\7\7\1\0\2\7\1\0\5\7\2\0"+
    "\1\10\1\7\10\10\1\0\3\10\1\0\3\10\22\0\1\7\5\0"+
    "\12\10\21\0\3\10\1\0\10\7\2\0\2\7\2\0\26\7\1\0"+
    "\7\7\1\0\2\7\2\0\4\7\2\0\1\10\1\7\6\10\3\0"+
    "\2\10\2\0\3\10\10\0\2\10\4\0\2\7\1\0\3\7\4\0"+
    "\12\10\22\0\2\10\1\0\6\7\3\0\3\7\1\0\4\7\3\0"+
    "\2\7\1\0\1\7\1\0\2\7\3\0\2\7\3\0\3\7\3\0"+
    "\10\7\1\0\3\7\4\0\5\10\3\0\3\10\1\0\4\10\11\0"+
    "\1\10\17\0\11\10\21\0\3\10\1\0\10\7\1\0\3\7\1\0"+
    "\27\7\1\0\12\7\1\0\5\7\4\0\7\10\1\0\3\10\1\0"+
    "\4\10\7\0\2\10\11\0\2\7\4\0\12\10\22\0\2\10\1\0"+
    "\10\7\1\0\3\7\1\0\27\7\1\0\12\7\1\0\5\7\4\0"+
    "\7\10\1\0\3\10\1\0\4\10\7\0\2\10\7\0\1\7\1\0"+
    "\2\7\4\0\12\10\22\0\2\10\1\0\10\7\1\0\3\7\1\0"+
    "\27\7\1\0\20\7\4\0\6\10\2\0\3\10\1\0\4\10\11\0"+
    "\1\10\10\0\2\7\4\0\12\10\221\0\56\7\1\0\1\7\1\10"+
    "\2\7\7\10\5\0\6\7\1\10\10\10\1\0\12\10\47\0\2\7"+
    "\1\0\1\7\2\0\2\7\1\0\1\7\2\0\1\7\6\0\4\7"+
    "\1\0\7\7\1\0\3\7\1\0\1\7\1\0\1\7\2\0\2\7"+
    "\1\0\2\7\1\0\1\7\1\10\2\7\6\10\1\0\2\10\1\7"+
    "\2\0\5\7\1\0\1\10\1\0\6\10\2\0\12\10\76\0\2\10"+
    "\6\0\12\10\13\0\1\10\1\0\1\10\1\0\1\10\4\0\2\10"+
    "\10\7\1\0\41\7\7\0\24\10\1\0\6\10\4\0\6\10\1\0"+
    "\1\10\1\0\25\10\3\0\7\10\1\0\1\10\346\0\46\7\12\0"+
    "\47\7\11\0\1\7\1\0\2\7\1\0\3\7\1\0\1\7\1\0"+
    "\2\7\1\0\5\7\51\0\1\7\1\0\1\7\1\0\1\7\13\0"+
    "\1\7\1\0\1\7\1\0\1\7\3\0\2\7\3\0\1\7\5\0"+
    "\3\7\1\0\1\7\1\0\1\7\1\0\1\7\1\0\1\7\3\0"+
    "\2\7\3\0\2\7\1\0\1\7\50\0\1\7\11\0\1\7\2\0"+
    "\1\7\2\0\2\7\7\0\2\7\1\0\1\7\1\0\7\7\50\0"+
    "\1\7\4\0\1\7\10\0\1\7\u0c06\0\234\7\4\0\132\7\6\0"+
    "\26\7\2\0\6\7\2\0\46\7\2\0\6\7\2\0\10\7\1\0"+
    "\1\7\1\0\1\7\1\0\1\7\1\0\37\7\2\0\65\7\1\0"+
    "\7\7\1\0\1\7\3\0\3\7\1\0\7\7\3\0\4\7\2\0"+
    "\6\7\4\0\15\7\5\0\3\7\1\0\7\7\323\0\15\10\4\0"+
    "\1\10\104\0\1\7\3\0\2\7\2\0\1\7\121\0\3\7\u0e82\0"+
    "\1\10\1\0\1\7\31\0\11\7\6\10\1\0\5\10\13\0\124\7"+
    "\4\0\2\10\2\0\2\10\2\0\132\7\1\0\3\10\6\0\50\7"+
    "\u1cd3\0\u51a6\7\u0c5a\0\u2ba4\7\u285c\0";

  /** 
   * Translates characters to character classes
   */
  final private static char [] yycmap = yy_unpack_cmap(yycmap_packed);

  /** 
   * Translates a state to a row index in the transition table
   */
  final private static int yy_rowMap [] = { 
        0,    67,   134,   201,   268,   335,   402,   469,   536,   603, 
      670,   737,   804,   871,   938,  1005,  1072,  1139,  1206,  1273, 
     1340,  1407,  1474,  1541,  1608,  1675,  1742,  1809,  1876,  1943, 
     2010,  2077,  2144,  2211,  2278,  2345,  2412,  2479,  2546,  2546, 
     2546,  2546,  2613,  2680,  2546,  2546,  2747,  2814,  2881,  2948, 
     3015,  3082,  3149,  3216,  3283,  3350,  3417,  3484,  2546,  3551, 
     3618,  3685,  3752,  3819,  3886,  3953,  4020,  2546,  4087,  4154, 
     4221,  4288,  4355,  4422,  4489,  2546,  2546,  4556,  4623,  4690, 
     4757,  4824,  4891,  4958,  5025,  2546,  5092,  5159,  5226,  5293, 
     2546,  5360,  5427,  5494,  2546,  5561,  5628,  2546,  5695,  5762, 
     5829,  5896,  2546,  5963,  2546,  6030,  2546,  6097,  6164,  6231, 
     6298,  6365,  6432,  2546,  6499,  6566,  6633,  6700,  2546,  6767, 
     6834,  6901,  2546,  2546,  6968,  7035,  7102,  7169,  7236,  7303, 
     7370,  7437,  2546,  7504,  7571,  7638,  7705,  7772,  7839,  2546, 
     7906,  7973,  2546,  2546,  2546,  2546,  8040,  8107,  8174,  8241, 
     8308,  2546,  2546,  8375,  8442,  8509,  8576,  2546,  2546,  2546, 
     8643,  8710,  8777,  2613,  2680,  2546,  2747,  2546,  8844,  8911, 
     8978,  9045,  9112,  9179,  9246,  3149,  3216,  2546,  2546,  2546, 
     9313,  9380,  9447,  9514,  9581,  9648,  9715,  9782,  9849,  2546, 
     9916,  9983, 10050,  4355,  4422,  2546,  2546,  4556,  2546, 10117, 
    10184, 10251, 10318, 10385, 10452, 10519,  2546,  5360,  2546,  5695, 
     2546,  5896,  5963, 10586, 10653,  2546, 10720, 10787, 10854, 10921, 
    10988, 11055, 11122, 11189, 11256,  6968,  7035, 11323, 11390,  7303, 
     2546,  7370, 11457, 11524, 11591, 11658, 11725, 11792, 11859, 11926, 
    11993, 12060, 12127, 12194,  2546, 12261, 12328, 12395, 12462, 12529, 
    12596, 12663,  2546,  8710,  2546,  8777,  2546,  2546,  2546, 12730, 
    12797, 12864, 12931,  2546, 12998, 13065, 13132, 13199, 13266, 13333, 
    13400, 13467, 13534,  2546,  2546, 13601, 13668, 13735, 13802,  2546, 
     2546,  2546,  2546, 13869, 13936, 14003, 14070, 14137, 14204,  2546, 
     2546, 14271, 14338, 14405, 14472, 14539,  6901, 14606, 14673, 14740, 
    14807, 14874, 14941, 15008, 15075, 15142, 15209, 15276, 15343,  2546, 
     2546,  2546, 15410, 15477, 15544, 15611, 15678, 15745, 15812, 15879, 
    15946,  2546,  2546, 16013, 16080, 16147, 16214, 16281, 16348, 16415, 
    16482, 16549, 16616, 16683, 16750, 16817, 16884, 16951, 17018, 17085, 
    17152, 17219, 17286, 17353, 17420, 17487, 17554,  2546,  2546,  2546, 
     2546, 17621, 17688, 17755, 17822,  2546,  2546, 17889, 17956, 18023, 
    18090,  2546,  6901, 18157,  6901, 18224, 18291, 18358, 18425, 18492, 
    18559, 18626, 18693,  2546, 18760, 18827, 18894, 18961,  2546, 19028, 
    19095, 19162, 19229, 19296, 19363,  2546, 19430, 19497,  2546, 19564, 
    19631,  6901,  6901,  6901, 19698, 19765,  2546, 19832, 19899, 19966, 
    20033, 20100, 20167, 20234, 20301,  2546,  2546, 20368, 20435, 20502, 
    20569,  6901, 20636, 20703,  2546, 20770,  2546, 20837, 20904,  2546, 
    20971,  2546,  2546,  2546,  6901,  2546, 21038,  2546, 21105,  2546, 
    20971,  2546,  2546
  };

  /** 
   * The packed transition table of the DFA (part 0)
   */
  final private static String yy_packed0 = 
    "\1\47\1\50\4\47\1\50\3\47\1\51\1\52\4\47"+
    "\1\50\51\47\1\50\10\47\14\53\1\54\66\53\12\55"+
    "\1\51\1\52\67\55\3\56\2\57\2\56\1\57\5\56"+
    "\2\57\1\60\1\56\3\57\5\56\10\57\2\56\5\57"+
    "\1\56\3\57\1\61\2\57\10\56\2\57\2\56\1\62"+
    "\1\57\1\63\3\57\1\64\1\57\14\65\1\66\66\65"+
    "\1\56\1\67\4\56\1\67\5\56\1\70\3\56\1\67"+
    "\51\56\1\67\11\56\1\71\1\56\2\72\1\56\1\71"+
    "\1\72\5\56\3\72\1\71\3\72\1\73\4\56\10\72"+
    "\2\56\5\72\1\56\3\72\1\56\2\72\7\56\1\74"+
    "\2\72\1\56\1\71\10\72\3\56\2\75\2\56\1\75"+
    "\4\56\1\76\3\75\1\56\3\75\4\56\1\77\10\75"+
    "\2\56\5\75\1\56\3\75\1\56\2\75\7\56\1\100"+
    "\2\75\2\56\10\75\1\56\1\71\1\56\1\101\1\102"+
    "\1\56\1\71\1\102\5\56\1\103\2\102\1\71\3\102"+
    "\1\104\4\56\10\102\2\56\5\102\1\56\3\102\1\56"+
    "\2\102\7\56\1\105\2\102\1\56\1\71\10\102\3\56"+
    "\1\106\1\107\2\56\1\107\4\56\1\76\3\107\1\56"+
    "\3\107\4\56\1\77\10\107\2\56\5\107\1\56\3\107"+
    "\1\56\2\107\7\56\1\110\2\107\2\56\10\107\1\56"+
    "\1\111\4\56\1\111\11\56\1\111\50\56\1\112\1\111"+
    "\10\56\1\113\1\114\4\113\1\114\3\113\1\56\1\115"+
    "\56\113\1\114\10\113\3\56\2\116\2\56\1\116\5\56"+
    "\2\116\1\117\1\56\3\116\5\56\10\116\2\56\5\116"+
    "\1\56\3\116\1\120\2\116\10\56\2\116\2\56\1\121"+
    "\1\116\1\122\3\116\1\123\1\116\1\124\1\125\4\124"+
    "\1\125\3\124\1\56\1\126\50\124\1\127\5\124\1\125"+
    "\10\124\1\130\1\125\4\130\1\125\3\130\1\56\1\126"+
    "\51\130\1\127\4\130\1\125\10\130\1\131\1\132\4\131"+
    "\1\132\3\131\1\56\1\133\4\131\1\132\43\131\1\134"+
    "\5\131\1\132\10\131\1\135\1\136\4\135\1\136\3\135"+
    "\1\56\1\137\4\135\1\136\44\135\1\134\4\135\1\136"+
    "\10\135\1\140\1\141\4\140\1\141\3\140\1\56\1\142"+
    "\4\140\1\141\43\140\1\143\5\140\1\141\10\140\1\144"+
    "\1\145\4\144\1\145\3\144\1\56\1\142\4\144\1\145"+
    "\44\144\1\143\4\144\1\145\10\144\1\56\1\146\4\56"+
    "\1\146\11\56\1\146\3\56\1\147\45\56\1\146\11\56"+
    "\1\150\4\56\1\150\11\56\1\150\3\56\1\151\45\56"+
    "\1\150\11\56\1\152\4\56\1\152\3\56\1\153\5\56"+
    "\1\152\4\56\1\154\1\56\1\155\42\56\1\152\11\56"+
    "\1\152\1\56\2\156\1\56\1\152\1\156\5\56\3\156"+
    "\1\152\3\156\1\56\1\157\3\56\10\156\2\56\5\156"+
    "\1\56\3\156\1\56\2\156\10\56\2\156\1\56\1\152"+
    "\10\156\1\56\1\152\1\56\1\160\1\161\1\56\1\152"+
    "\1\161\5\56\3\161\1\152\3\161\1\162\1\157\3\56"+
    "\10\161\2\56\5\161\1\56\3\161\1\56\2\161\10\56"+
    "\2\161\1\56\1\152\10\161\1\56\1\152\4\56\1\152"+
    "\11\56\1\152\4\56\1\157\3\56\1\163\1\164\1\56"+
    "\1\165\6\56\1\166\4\56\1\167\21\56\1\152\11\56"+
    "\1\152\1\56\2\170\1\56\1\152\1\170\5\56\3\170"+
    "\1\152\3\170\1\56\1\171\3\56\10\170\2\56\5\170"+
    "\1\56\3\170\1\56\2\170\10\56\2\170\1\56\1\152"+
    "\10\170\1\56\1\152\3\172\1\56\1\152\3\172\3\56"+
    "\3\172\1\152\3\172\1\56\1\157\3\56\11\172\1\56"+
    "\5\172\1\56\3\172\1\56\2\172\1\173\3\56\1\174"+
    "\3\56\2\172\1\56\1\152\10\172\41\175\1\176\41\175"+
    "\12\177\1\200\14\177\1\201\53\177\1\56\1\152\4\56"+
    "\1\152\11\56\1\152\43\56\1\202\1\203\4\56\1\152"+
    "\11\56\1\204\1\56\2\172\1\56\1\204\1\172\4\56"+
    "\1\205\3\172\1\204\3\172\1\162\1\157\3\56\1\206"+
    "\1\207\1\172\1\210\1\172\1\211\1\212\1\172\1\56"+
    "\1\213\5\172\1\214\1\215\2\172\1\216\2\172\1\217"+
    "\1\220\1\221\1\222\1\174\1\223\1\224\1\56\2\172"+
    "\1\56\1\204\10\172\14\56\1\225\13\56\1\226\52\56"+
    "\13\227\1\230\11\227\1\231\55\227\1\232\1\233\4\232"+
    "\1\234\11\232\1\233\51\232\1\233\10\232\13\235\1\236"+
    "\11\235\1\237\36\235\1\240\16\235\13\241\1\236\11\241"+
    "\1\237\37\241\1\240\15\241\3\56\2\242\2\56\1\242"+
    "\5\56\3\242\1\56\3\242\5\56\10\242\2\56\5\242"+
    "\1\56\3\242\1\120\2\242\10\56\2\242\2\56\10\242"+
    "\3\56\2\243\2\56\1\243\5\56\3\243\1\56\3\243"+
    "\5\56\10\243\2\56\5\243\1\56\3\243\1\56\2\243"+
    "\10\56\2\243\2\56\10\243\103\0\14\244\1\245\102\244"+
    "\1\245\7\244\1\246\56\244\2\0\3\247\2\0\3\247"+
    "\3\0\3\247\1\0\3\247\2\0\1\250\2\0\11\247"+
    "\1\0\5\247\1\0\3\247\1\0\2\247\10\0\2\247"+
    "\2\0\10\247\2\0\3\247\2\0\3\247\3\0\3\247"+
    "\1\0\3\247\2\0\1\250\2\0\11\247\1\0\5\247"+
    "\1\0\3\247\1\0\2\247\10\0\2\247\2\0\5\247"+
    "\1\251\2\247\11\0\1\252\3\0\1\253\67\0\3\247"+
    "\2\0\3\247\3\0\1\247\1\254\1\247\1\0\3\247"+
    "\2\0\1\250\2\0\11\247\1\0\5\247\1\0\3\247"+
    "\1\0\2\247\10\0\2\247\2\0\1\247\1\255\6\247"+
    "\2\0\3\247\2\0\3\247\3\0\3\247\1\0\3\247"+
    "\2\0\1\250\2\0\11\247\1\0\5\247\1\0\3\247"+
    "\1\0\2\247\10\0\2\247\2\0\3\247\1\256\4\247"+
    "\2\0\3\247\2\0\3\247\3\0\3\247\1\0\3\247"+
    "\2\0\1\250\2\0\11\247\1\0\5\247\1\0\3\247"+
    "\1\0\2\247\10\0\2\247\2\0\5\247\1\257\2\247"+
    "\14\260\1\261\102\260\1\261\7\260\1\262\56\260\1\0"+
    "\1\67\4\0\1\67\11\0\1\67\51\0\1\67\34\0"+
    "\1\263\57\0\1\71\4\0\1\71\11\0\1\71\51\0"+
    "\1\71\12\0\3\72\2\0\3\72\3\0\3\72\1\0"+
    "\3\72\5\0\11\72\1\0\5\72\1\0\3\72\1\0"+
    "\2\72\10\0\2\72\2\0\10\72\24\0\1\264\60\0"+
    "\3\75\2\0\3\75\3\0\3\75\1\0\3\75\5\0"+
    "\11\75\1\0\5\75\1\0\3\75\1\0\2\75\10\0"+
    "\2\75\2\0\10\75\3\0\2\265\2\0\1\265\5\0"+
    "\1\266\2\265\1\0\1\267\2\265\5\0\10\265\2\0"+
    "\5\265\1\0\3\265\1\0\2\265\10\0\2\265\2\0"+
    "\10\265\41\0\1\270\1\271\1\0\1\272\41\0\2\273"+
    "\2\0\1\273\5\0\3\273\1\0\3\273\5\0\10\273"+
    "\2\0\5\273\1\0\3\273\1\0\2\273\10\0\2\273"+
    "\2\0\10\273\2\0\3\101\2\0\3\101\3\0\3\101"+
    "\1\0\3\101\5\0\11\101\1\0\5\101\1\0\3\101"+
    "\1\0\2\101\10\0\2\101\2\0\10\101\2\0\1\102"+
    "\1\274\1\102\2\0\3\102\3\0\3\102\1\0\3\102"+
    "\5\0\11\102\1\0\5\102\1\0\3\102\1\0\2\102"+
    "\10\0\2\102\2\0\10\102\2\0\1\102\1\274\1\102"+
    "\2\0\3\102\3\0\1\102\1\275\1\102\1\0\3\102"+
    "\5\0\11\102\1\0\5\102\1\0\3\102\1\0\2\102"+
    "\10\0\2\102\2\0\10\102\24\0\1\276\60\0\3\106"+
    "\2\0\3\106\3\0\3\106\1\0\3\106\5\0\11\106"+
    "\1\0\5\106\1\0\3\106\1\0\2\106\10\0\2\106"+
    "\2\0\10\106\2\0\1\107\1\277\1\107\2\0\3\107"+
    "\3\0\3\107\1\0\3\107\5\0\11\107\1\0\5\107"+
    "\1\0\3\107\1\0\2\107\10\0\2\107\2\0\10\107"+
    "\3\0\1\300\1\301\2\0\1\301\5\0\3\301\1\0"+
    "\3\301\5\0\10\301\2\0\5\301\1\0\3\301\1\0"+
    "\2\301\10\0\2\301\2\0\10\301\1\0\1\302\4\0"+
    "\1\302\11\0\1\302\50\0\1\303\1\302\11\0\1\303"+
    "\4\0\1\303\11\0\1\303\43\0\1\304\1\305\4\0"+
    "\1\303\10\0\1\113\1\0\4\113\1\0\3\113\2\0"+
    "\56\113\1\0\10\113\2\0\3\306\2\0\3\306\3\0"+
    "\3\306\1\0\3\306\2\0\1\307\2\0\11\306\1\0"+
    "\5\306\1\0\3\306\1\0\2\306\10\0\2\306\2\0"+
    "\10\306\2\0\3\306\2\0\3\306\3\0\3\306\1\0"+
    "\3\306\2\0\1\307\2\0\11\306\1\0\5\306\1\0"+
    "\3\306\1\0\2\306\10\0\2\306\2\0\5\306\1\310"+
    "\2\306\11\0\1\311\3\0\1\312\67\0\3\306\2\0"+
    "\3\306\3\0\1\306\1\313\1\306\1\0\3\306\2\0"+
    "\1\307\2\0\11\306\1\0\5\306\1\0\3\306\1\0"+
    "\2\306\10\0\2\306\2\0\1\306\1\314\6\306\2\0"+
    "\3\306\2\0\3\306\3\0\3\306\1\0\3\306\2\0"+
    "\1\307\2\0\11\306\1\0\5\306\1\0\3\306\1\0"+
    "\2\306\10\0\2\306\2\0\3\306\1\315\4\306\2\0"+
    "\3\306\2\0\3\306\3\0\3\306\1\0\3\306\2\0"+
    "\1\307\2\0\11\306\1\0\5\306\1\0\3\306\1\0"+
    "\2\306\10\0\2\306\2\0\5\306\1\316\2\306\1\124"+
    "\1\0\4\124\1\0\3\124\2\0\50\124\1\0\5\124"+
    "\1\0\10\124\1\0\1\125\4\0\1\125\63\0\1\125"+
    "\11\0\1\317\4\0\1\317\11\0\1\317\3\0\1\317"+
    "\41\0\1\317\3\0\1\317\10\0\1\130\1\0\4\130"+
    "\1\0\3\130\2\0\51\130\1\0\4\130\1\0\10\130"+
    "\1\131\1\0\4\131\1\0\3\131\2\0\4\131\1\0"+
    "\43\131\1\0\5\131\1\0\10\131\1\0\1\132\4\0"+
    "\1\132\11\0\1\132\43\0\1\320\5\0\1\132\11\0"+
    "\1\321\4\0\1\321\11\0\1\321\3\0\1\321\41\0"+
    "\1\321\3\0\1\321\10\0\1\135\1\0\4\135\1\0"+
    "\3\135\2\0\4\135\1\0\44\135\1\0\4\135\1\0"+
    "\10\135\1\0\1\136\4\0\1\136\11\0\1\136\44\0"+
    "\1\320\4\0\1\136\10\0\1\140\1\0\4\140\1\0"+
    "\3\140\2\0\4\140\1\0\43\140\1\0\5\140\1\0"+
    "\10\140\1\0\1\141\4\0\1\141\11\0\1\141\43\0"+
    "\1\322\5\0\1\141\11\0\1\323\4\0\1\323\11\0"+
    "\1\323\3\0\1\323\41\0\1\323\3\0\1\323\10\0"+
    "\1\144\1\0\4\144\1\0\3\144\2\0\4\144\1\0"+
    "\44\144\1\0\4\144\1\0\10\144\1\0\1\145\4\0"+
    "\1\145\11\0\1\145\44\0\1\322\4\0\1\145\11\0"+
    "\1\324\4\0\1\324\11\0\1\324\3\0\1\147\45\0"+
    "\1\324\11\0\1\325\4\0\1\325\11\0\1\325\3\0"+
    "\1\151\45\0\1\325\11\0\1\152\4\0\1\152\11\0"+
    "\1\152\51\0\1\152\13\0\2\326\2\0\1\326\5\0"+
    "\3\326\1\0\3\326\5\0\10\326\2\0\5\326\1\0"+
    "\3\326\1\0\2\326\10\0\2\326\2\0\10\326\1\0"+
    "\1\327\4\0\1\327\11\0\1\327\3\0\1\330\2\0"+
    "\1\331\42\0\1\327\12\0\3\156\2\0\3\156\3\0"+
    "\3\156\1\0\3\156\5\0\11\156\1\0\5\156\1\0"+
    "\3\156\1\0\2\156\10\0\2\156\2\0\10\156\3\0"+
    "\2\332\2\0\1\332\5\0\3\332\1\0\3\332\5\0"+
    "\10\332\2\0\5\332\1\0\3\332\1\0\2\332\10\0"+
    "\2\332\2\0\10\332\2\0\3\160\2\0\3\160\3\0"+
    "\3\160\1\0\3\160\5\0\11\160\1\0\5\160\1\0"+
    "\3\160\1\0\2\160\10\0\2\160\2\0\10\160\2\0"+
    "\1\161\1\333\1\161\2\0\3\161\3\0\3\161\1\0"+
    "\3\161\5\0\11\161\1\0\5\161\1\0\3\161\1\0"+
    "\2\161\10\0\2\161\2\0\10\161\32\0\1\334\72\0"+
    "\1\335\15\0\1\336\106\0\1\337\102\0\1\340\40\0"+
    "\3\170\2\0\3\170\3\0\3\170\1\0\3\170\5\0"+
    "\11\170\1\0\5\170\1\0\3\170\1\0\2\170\10\0"+
    "\2\170\2\0\10\170\1\0\1\341\1\0\2\332\2\0"+
    "\1\332\5\0\3\332\1\341\3\332\5\0\10\332\2\0"+
    "\5\332\1\0\3\332\1\0\2\332\10\0\2\332\1\0"+
    "\1\341\10\332\2\0\3\172\2\0\3\172\3\0\3\172"+
    "\1\0\3\172\5\0\11\172\1\0\5\172\1\0\3\172"+
    "\1\0\2\172\10\0\2\172\2\0\10\172\41\342\1\343"+
    "\102\342\1\344\41\342\12\177\1\0\14\177\1\0\53\177"+
    "\30\0\1\345\101\0\1\331\55\0\5\346\2\0\1\346"+
    "\2\0\10\346\1\0\2\346\1\0\12\346\1\0\20\346"+
    "\1\0\1\347\16\346\2\0\5\350\2\0\1\350\2\0"+
    "\10\350\1\0\2\350\1\0\12\350\1\0\20\350\2\0"+
    "\1\347\15\350\1\0\1\204\4\0\1\204\11\0\1\204"+
    "\21\0\1\213\27\0\1\204\12\0\3\172\2\0\3\172"+
    "\3\0\3\172\1\0\1\172\1\351\1\172\5\0\11\172"+
    "\1\0\5\172\1\0\3\172\1\0\2\172\10\0\2\172"+
    "\2\0\10\172\2\0\3\172\2\0\3\172\3\0\3\172"+
    "\1\0\3\172\5\0\7\172\1\352\1\172\1\0\1\172"+
    "\1\353\3\172\1\0\3\172\1\0\2\172\10\0\2\172"+
    "\2\0\10\172\2\0\3\172\2\0\3\172\3\0\3\172"+
    "\1\0\3\172\5\0\1\172\1\354\7\172\1\0\5\172"+
    "\1\0\3\172\1\0\1\172\1\355\10\0\2\172\2\0"+
    "\10\172\2\0\3\172\2\0\3\172\3\0\3\172\1\0"+
    "\3\172\5\0\1\172\1\356\7\172\1\0\5\172\1\0"+
    "\3\172\1\0\2\172\10\0\2\172\2\0\10\172\2\0"+
    "\3\172\2\0\3\172\3\0\3\172\1\0\3\172\5\0"+
    "\4\172\1\357\4\172\1\0\5\172\1\0\3\172\1\0"+
    "\2\172\10\0\2\172\2\0\10\172\1\0\1\213\4\0"+
    "\1\213\11\0\1\213\51\0\1\213\12\0\3\172\2\0"+
    "\3\172\3\0\3\172\1\0\3\172\5\0\11\172\1\0"+
    "\5\172\1\0\1\172\1\360\1\172\1\0\2\172\10\0"+
    "\2\172\2\0\10\172\34\0\1\361\10\0\1\362\1\363"+
    "\2\0\1\364\31\0\13\223\1\0\11\223\1\0\36\223"+
    "\1\365\16\223\13\224\1\0\11\224\1\0\37\224\1\365"+
    "\15\224\3\0\2\366\2\0\1\366\5\0\1\367\2\366"+
    "\1\0\1\370\2\366\5\0\10\366\2\0\5\366\1\0"+
    "\3\366\1\0\2\366\10\0\2\366\2\0\10\366\31\0"+
    "\1\371\1\372\3\0\1\373\2\0\1\374\1\375\40\0"+
    "\13\227\1\0\11\227\1\0\55\227\13\232\1\0\11\232"+
    "\1\0\55\232\1\0\1\233\4\0\1\233\11\0\1\233"+
    "\51\0\1\233\10\0\1\232\1\234\4\232\1\234\4\232"+
    "\1\0\4\232\1\234\4\232\1\0\44\232\1\234\10\232"+
    "\13\235\1\0\11\235\1\0\36\235\1\0\16\235\13\241"+
    "\1\0\11\241\1\0\37\241\1\0\15\241\2\0\3\376"+
    "\2\0\3\376\3\0\3\376\1\0\3\376\2\0\1\377"+
    "\2\0\11\376\1\0\5\376\1\0\3\376\1\0\2\376"+
    "\10\0\2\376\2\0\10\376\2\0\3\u0100\2\0\3\u0100"+
    "\3\0\3\u0100\1\0\3\u0100\2\0\1\u0101\2\0\11\u0100"+
    "\1\0\5\u0100\1\0\3\u0100\1\0\2\u0100\10\0\2\u0100"+
    "\2\0\10\u0100\2\0\3\247\2\0\3\247\3\0\3\247"+
    "\1\0\3\247\2\0\1\u0102\2\0\11\247\1\0\5\247"+
    "\1\0\3\247\1\0\2\247\10\0\2\247\2\0\10\247"+
    "\11\0\1\252\14\0\1\u0103\65\0\1\u0104\17\0\1\u0104"+
    "\4\0\1\u0104\4\0\2\u0104\1\0\1\u0104\4\0\1\u0104"+
    "\17\0\1\u0104\6\0\1\u0104\2\0\3\247\2\0\3\247"+
    "\3\0\3\247\1\0\3\247\2\0\1\250\2\0\11\247"+
    "\1\0\5\247\1\0\3\247\1\0\2\247\10\0\2\247"+
    "\2\0\1\247\1\u0105\6\247\2\0\3\247\2\0\3\247"+
    "\3\0\3\247\1\0\3\247\2\0\1\250\2\0\11\247"+
    "\1\0\5\247\1\0\3\247\1\0\2\247\10\0\2\247"+
    "\2\0\4\247\1\u0106\3\247\2\0\3\247\2\0\3\247"+
    "\3\0\3\247\1\0\3\247\2\0\1\250\2\0\11\247"+
    "\1\0\5\247\1\0\3\247\1\0\2\247\10\0\2\247"+
    "\2\0\4\247\1\u0107\3\247\2\0\3\247\2\0\3\247"+
    "\3\0\3\247\1\0\3\247\2\0\1\u0108\2\0\11\247"+
    "\1\0\5\247\1\0\3\247\1\0\2\247\10\0\2\247"+
    "\2\0\10\247\2\0\3\265\2\0\3\265\3\0\3\265"+
    "\1\0\3\265\5\0\11\265\1\0\5\265\1\0\3\265"+
    "\1\0\2\265\10\0\2\265\2\0\10\265\2\0\3\265"+
    "\2\0\3\265\3\0\1\265\1\u0109\1\265\1\0\1\265"+
    "\1\u010a\1\265\5\0\11\265\1\0\5\265\1\0\3\265"+
    "\1\0\2\265\10\0\2\265\2\0\10\265\2\0\3\265"+
    "\2\0\3\265\3\0\1\265\1\u010a\1\265\1\0\1\265"+
    "\1\u010a\1\265\5\0\11\265\1\0\5\265\1\0\3\265"+
    "\1\0\2\265\10\0\2\265\2\0\10\265\41\0\1\u010b"+
    "\104\0\1\u010c\77\0\1\u010d\44\0\3\273\2\0\3\273"+
    "\3\0\3\273\1\0\3\273\5\0\11\273\1\0\5\273"+
    "\1\0\3\273\1\0\2\273\10\0\2\273\2\0\10\273"+
    "\2\0\2\101\1\u010e\2\0\1\u010e\2\101\3\0\3\u010e"+
    "\1\0\3\u010e\5\0\10\u010e\1\101\1\0\5\u010e\1\0"+
    "\3\u010e\1\0\2\u010e\10\0\2\u010e\2\0\10\u010e\2\0"+
    "\1\102\1\274\1\102\2\0\3\102\3\0\2\102\1\u010f"+
    "\1\0\3\102\5\0\11\102\1\0\5\102\1\0\3\102"+
    "\1\0\2\102\10\0\2\102\2\0\10\102\2\0\2\106"+
    "\1\u0110\2\0\1\u0110\2\106\3\0\3\u0110\1\0\3\u0110"+
    "\5\0\10\u0110\1\106\1\0\5\u0110\1\0\3\u0110\1\0"+
    "\2\u0110\10\0\2\u0110\2\0\10\u0110\2\0\3\300\2\0"+
    "\3\300\3\0\3\300\1\0\3\300\5\0\11\300\1\0"+
    "\5\300\1\0\3\300\1\0\2\300\10\0\2\300\2\0"+
    "\10\300\2\0\1\301\1\u0111\1\301\2\0\3\301\3\0"+
    "\3\301\1\0\3\301\5\0\11\301\1\0\5\301\1\0"+
    "\3\301\1\0\2\301\10\0\2\301\2\0\10\301\2\0"+
    "\3\306\2\0\3\306\3\0\3\306\1\0\3\306\2\0"+
    "\1\u0112\2\0\11\306\1\0\5\306\1\0\3\306\1\0"+
    "\2\306\10\0\2\306\2\0\10\306\11\0\1\311\14\0"+
    "\1\u0113\65\0\1\u0114\17\0\1\u0114\4\0\1\u0114\4\0"+
    "\2\u0114\1\0\1\u0114\4\0\1\u0114\17\0\1\u0114\6\0"+
    "\1\u0114\2\0\3\306\2\0\3\306\3\0\3\306\1\0"+
    "\3\306\2\0\1\307\2\0\11\306\1\0\5\306\1\0"+
    "\3\306\1\0\2\306\10\0\2\306\2\0\1\306\1\u0115"+
    "\6\306\2\0\3\306\2\0\3\306\3\0\3\306\1\0"+
    "\3\306\2\0\1\307\2\0\11\306\1\0\5\306\1\0"+
    "\3\306\1\0\2\306\10\0\2\306\2\0\4\306\1\u0116"+
    "\3\306\2\0\3\306\2\0\3\306\3\0\3\306\1\0"+
    "\3\306\2\0\1\307\2\0\11\306\1\0\5\306\1\0"+
    "\3\306\1\0\2\306\10\0\2\306\2\0\4\306\1\u0117"+
    "\3\306\2\0\3\306\2\0\3\306\3\0\3\306\1\0"+
    "\3\306\2\0\1\u0118\2\0\11\306\1\0\5\306\1\0"+
    "\3\306\1\0\2\306\10\0\2\306\2\0\10\306\2\0"+
    "\3\326\2\0\3\326\3\0\3\326\1\0\3\326\2\0"+
    "\1\u0119\2\0\11\326\1\0\5\326\1\0\3\326\1\0"+
    "\2\326\10\0\2\326\2\0\10\326\1\0\1\327\4\0"+
    "\1\327\11\0\1\327\3\0\1\330\45\0\1\327\34\0"+
    "\1\u011a\60\0\3\332\2\0\3\332\3\0\3\332\1\0"+
    "\3\332\2\0\1\u011b\2\0\11\332\1\0\5\332\1\0"+
    "\3\332\1\0\2\332\10\0\2\332\2\0\10\332\2\0"+
    "\2\160\1\u011c\2\0\1\u011c\2\160\3\0\3\u011c\1\0"+
    "\3\u011c\5\0\10\u011c\1\160\1\0\5\u011c\1\0\3\u011c"+
    "\1\0\2\u011c\10\0\2\u011c\2\0\10\u011c\33\0\1\u011d"+
    "\102\0\1\u011e\102\0\1\u011f\114\0\1\u0120\73\0\1\u0121"+
    "\45\0\1\341\16\0\1\341\51\0\1\341\34\0\1\u0122"+
    "\120\0\1\u0123\42\0\3\172\2\0\3\172\3\0\3\172"+
    "\1\0\3\172\5\0\11\172\1\0\5\172\1\0\1\u0124"+
    "\2\172\1\0\2\172\10\0\2\172\2\0\10\172\2\0"+
    "\3\172\2\0\3\172\3\0\3\172\1\0\3\172\5\0"+
    "\2\172\1\u0125\6\172\1\0\5\172\1\0\3\172\1\0"+
    "\2\172\10\0\2\172\2\0\10\172\2\0\3\172\2\0"+
    "\3\172\3\0\3\172\1\0\3\172\5\0\5\172\1\u0126"+
    "\3\172\1\0\5\172\1\0\3\172\1\0\2\172\10\0"+
    "\2\172\2\0\10\172\2\0\3\172\2\0\3\172\3\0"+
    "\3\172\1\0\3\172\5\0\11\172\1\0\1\u0127\4\172"+
    "\1\0\3\172\1\0\2\172\10\0\2\172\2\0\10\172"+
    "\2\0\3\172\2\0\3\172\3\0\3\172\1\0\3\172"+
    "\5\0\1\172\1\u0128\7\172\1\0\5\172\1\0\3\172"+
    "\1\0\2\172\10\0\2\172\2\0\10\172\2\0\3\172"+
    "\2\0\3\172\3\0\3\172\1\0\3\172\5\0\4\172"+
    "\1\u0129\4\172\1\0\5\172\1\0\3\172\1\0\2\172"+
    "\10\0\2\172\2\0\10\172\2\0\3\172\2\0\3\172"+
    "\3\0\3\172\1\0\3\172\5\0\6\172\1\u012a\2\172"+
    "\1\0\5\172\1\0\3\172\1\0\2\172\10\0\2\172"+
    "\2\0\10\172\2\0\3\172\2\0\3\172\3\0\3\172"+
    "\1\0\3\172\5\0\11\172\1\0\5\172\1\0\2\172"+
    "\1\u012b\1\0\2\172\10\0\2\172\2\0\10\172\22\0"+
    "\1\u012c\111\0\1\u012d\105\0\1\u012e\111\0\1\u012f\41\0"+
    "\3\366\2\0\3\366\3\0\3\366\1\0\3\366\5\0"+
    "\11\366\1\0\5\366\1\0\3\366\1\0\2\366\10\0"+
    "\2\366\2\0\10\366\2\0\3\366\2\0\3\366\3\0"+
    "\1\366\1\u0130\1\366\1\0\1\366\1\u0131\1\366\5\0"+
    "\11\366\1\0\5\366\1\0\3\366\1\0\2\366\10\0"+
    "\2\366\2\0\10\366\2\0\3\366\2\0\3\366\3\0"+
    "\1\366\1\u0131\1\366\1\0\1\366\1\u0131\1\366\5\0"+
    "\11\366\1\0\5\366\1\0\3\366\1\0\2\366\10\0"+
    "\2\366\2\0\10\366\23\0\1\u0132\6\0\1\u0133\110\0"+
    "\1\u0134\75\0\1\u0135\110\0\1\u0136\52\0\1\u0104\14\0"+
    "\1\u0137\2\0\1\u0104\4\0\1\u0104\4\0\2\u0104\1\0"+
    "\1\u0104\4\0\1\u0104\17\0\1\u0104\6\0\1\u0104\2\0"+
    "\3\247\2\0\3\247\3\0\3\247\1\0\3\247\2\0"+
    "\1\u0138\2\0\11\247\1\0\5\247\1\0\3\247\1\0"+
    "\2\247\10\0\2\247\2\0\10\247\2\0\3\247\2\0"+
    "\3\247\3\0\3\247\1\0\3\247\2\0\1\250\2\0"+
    "\11\247\1\0\5\247\1\0\3\247\1\0\2\247\10\0"+
    "\1\247\1\u0139\2\0\10\247\2\0\3\247\2\0\3\247"+
    "\3\0\3\247\1\0\3\247\2\0\1\250\2\0\11\247"+
    "\1\0\5\247\1\0\3\247\1\0\2\247\10\0\2\247"+
    "\2\0\5\247\1\u013a\2\247\2\0\3\265\2\0\3\265"+
    "\3\0\2\265\1\u013b\1\0\2\265\1\u013c\5\0\11\265"+
    "\1\0\5\265\1\0\3\265\1\0\2\265\10\0\2\265"+
    "\2\0\10\265\2\0\3\265\2\0\3\265\3\0\2\265"+
    "\1\u013c\1\0\2\265\1\u013c\5\0\11\265\1\0\5\265"+
    "\1\0\3\265\1\0\2\265\10\0\2\265\2\0\10\265"+
    "\41\u010b\1\u013d\41\u010b\44\0\1\u013e\101\0\1\u013f\41\0"+
    "\1\u010e\1\101\1\u010e\2\0\3\u010e\3\0\3\u010e\1\0"+
    "\3\u010e\5\0\11\u010e\1\0\5\u010e\1\0\3\u010e\1\0"+
    "\2\u010e\10\0\2\u010e\2\0\10\u010e\2\0\1\102\1\274"+
    "\1\102\2\0\3\102\3\0\3\102\1\0\3\102\5\0"+
    "\11\102\1\0\5\102\1\0\3\102\1\0\2\102\10\0"+
    "\1\u0140\1\102\2\0\10\102\2\0\1\u0110\1\106\1\u0110"+
    "\2\0\3\u0110\3\0\3\u0110\1\0\3\u0110\5\0\11\u0110"+
    "\1\0\5\u0110\1\0\3\u0110\1\0\2\u0110\10\0\2\u0110"+
    "\2\0\10\u0110\2\0\2\300\1\u0141\2\0\1\u0141\2\300"+
    "\3\0\3\u0141\1\0\3\u0141\5\0\10\u0141\1\300\1\0"+
    "\5\u0141\1\0\3\u0141\1\0\2\u0141\10\0\2\u0141\2\0"+
    "\10\u0141\11\0\1\u0114\14\0\1\u0142\2\0\1\u0114\4\0"+
    "\1\u0114\4\0\2\u0114\1\0\1\u0114\4\0\1\u0114\17\0"+
    "\1\u0114\6\0\1\u0114\2\0\3\306\2\0\3\306\3\0"+
    "\3\306\1\0\3\306\2\0\1\u0143\2\0\11\306\1\0"+
    "\5\306\1\0\3\306\1\0\2\306\10\0\2\306\2\0"+
    "\10\306\2\0\3\306\2\0\3\306\3\0\3\306\1\0"+
    "\3\306\2\0\1\307\2\0\11\306\1\0\5\306\1\0"+
    "\3\306\1\0\2\306\10\0\1\306\1\u0144\2\0\10\306"+
    "\2\0\3\306\2\0\3\306\3\0\3\306\1\0\3\306"+
    "\2\0\1\307\2\0\11\306\1\0\5\306\1\0\3\306"+
    "\1\0\2\306\10\0\2\306\2\0\5\306\1\u0145\2\306"+
    "\2\0\1\u011c\1\160\1\u011c\2\0\3\u011c\3\0\3\u011c"+
    "\1\0\3\u011c\5\0\11\u011c\1\0\5\u011c\1\0\3\u011c"+
    "\1\0\2\u011c\10\0\2\u011c\2\0\10\u011c\34\0\1\u0146"+
    "\106\0\1\u0147\100\0\1\u0148\75\0\1\u0149\104\0\1\u014a"+
    "\51\0\3\172\2\0\3\172\3\0\3\172\1\0\3\172"+
    "\5\0\2\172\1\u014b\6\172\1\0\5\172\1\0\3\172"+
    "\1\0\2\172\10\0\2\172\2\0\10\172\2\0\3\172"+
    "\2\0\3\172\3\0\3\172\1\0\3\172\5\0\5\172"+
    "\1\u014c\3\172\1\0\5\172\1\0\3\172\1\0\2\172"+
    "\10\0\2\172\2\0\10\172\2\0\3\172\2\0\3\172"+
    "\3\0\3\172\1\0\3\172\5\0\2\172\1\u014d\6\172"+
    "\1\0\5\172\1\0\3\172\1\0\2\172\10\0\2\172"+
    "\2\0\10\172\2\0\3\172\2\0\3\172\3\0\3\172"+
    "\1\0\2\172\1\u014e\5\0\11\172\1\0\5\172\1\0"+
    "\3\172\1\0\2\172\10\0\2\172\2\0\10\172\2\0"+
    "\3\172\2\0\3\172\3\0\3\172\1\0\3\172\5\0"+
    "\7\172\1\u014f\1\172\1\0\5\172\1\0\3\172\1\0"+
    "\2\172\10\0\2\172\2\0\10\172\2\0\3\172\2\0"+
    "\3\172\3\0\3\172\1\0\3\172\5\0\2\172\1\u0150"+
    "\6\172\1\0\5\172\1\0\3\172\1\0\2\172\10\0"+
    "\2\172\2\0\10\172\2\0\3\172\2\0\3\172\3\0"+
    "\3\172\1\0\2\172\1\u0151\5\0\11\172\1\0\5\172"+
    "\1\0\3\172\1\0\2\172\10\0\2\172\2\0\10\172"+
    "\51\0\1\u0152\106\0\1\u0153\46\0\1\u0154\125\0\1\u0155"+
    "\40\0\3\366\2\0\3\366\3\0\2\366\1\u0156\1\0"+
    "\2\366\1\u0157\5\0\11\366\1\0\5\366\1\0\3\366"+
    "\1\0\2\366\10\0\2\366\2\0\10\366\2\0\3\366"+
    "\2\0\3\366\3\0\2\366\1\u0157\1\0\2\366\1\u0157"+
    "\5\0\11\366\1\0\5\366\1\0\3\366\1\0\2\366"+
    "\10\0\2\366\2\0\10\366\31\0\1\u0158\104\0\1\u0159"+
    "\102\0\1\u015a\102\0\1\u015b\51\0\3\247\2\0\3\247"+
    "\3\0\3\247\1\0\3\247\2\0\1\u015c\2\0\11\247"+
    "\1\0\5\247\1\0\3\247\1\0\2\247\10\0\2\247"+
    "\2\0\10\247\2\0\3\247\2\0\3\247\3\0\3\247"+
    "\1\0\3\247\2\0\1\u015d\2\0\11\247\1\0\5\247"+
    "\1\0\3\247\1\0\2\247\10\0\2\247\2\0\10\247"+
    "\1\0\1\u015e\3\265\1\0\1\u015f\3\265\2\0\1\u015e"+
    "\3\265\1\u015e\3\265\5\0\11\265\1\0\5\265\1\0"+
    "\3\265\1\0\2\265\10\0\2\265\1\0\1\u015e\10\265"+
    "\1\0\1\u015f\3\265\1\0\1\u015f\3\265\2\0\1\u015f"+
    "\3\265\1\u015f\3\265\5\0\11\265\1\0\5\265\1\0"+
    "\3\265\1\0\2\265\10\0\2\265\1\0\1\u015f\10\265"+
    "\41\u010b\1\u0160\41\u010b\36\0\1\u0161\77\0\1\u0162\51\0"+
    "\1\102\1\274\1\102\2\0\3\102\3\0\3\102\1\0"+
    "\3\102\5\0\11\102\1\0\5\102\1\0\3\102\1\0"+
    "\2\102\10\0\1\102\1\u0163\2\0\10\102\2\0\1\u0141"+
    "\1\300\1\u0141\2\0\3\u0141\3\0\3\u0141\1\0\3\u0141"+
    "\5\0\11\u0141\1\0\5\u0141\1\0\3\u0141\1\0\2\u0141"+
    "\10\0\2\u0141\2\0\10\u0141\2\0\3\306\2\0\3\306"+
    "\3\0\3\306\1\0\3\306\2\0\1\u0164\2\0\11\306"+
    "\1\0\5\306\1\0\3\306\1\0\2\306\10\0\2\306"+
    "\2\0\10\306\2\0\3\306\2\0\3\306\3\0\3\306"+
    "\1\0\3\306\2\0\1\u0165\2\0\11\306\1\0\5\306"+
    "\1\0\3\306\1\0\2\306\10\0\2\306\2\0\10\306"+
    "\33\0\1\u0166\116\0\1\u0167\66\0\1\u0168\115\0\1\u0169"+
    "\72\0\1\u016a\46\0\3\172\2\0\3\172\3\0\3\172"+
    "\1\0\3\172\5\0\4\172\1\u016b\4\172\1\0\5\172"+
    "\1\0\3\172\1\0\2\172\10\0\2\172\2\0\10\172"+
    "\2\0\3\172\2\0\3\172\3\0\3\172\1\0\3\172"+
    "\5\0\2\172\1\u016c\6\172\1\0\5\172\1\0\3\172"+
    "\1\0\2\172\10\0\2\172\2\0\10\172\2\0\3\172"+
    "\2\0\3\172\3\0\3\172\1\0\3\172\5\0\5\172"+
    "\1\u016d\3\172\1\0\5\172\1\0\3\172\1\0\2\172"+
    "\10\0\2\172\2\0\10\172\2\0\3\172\2\0\3\172"+
    "\3\0\3\172\1\0\3\172\5\0\11\172\1\0\5\172"+
    "\1\0\1\172\1\u016e\1\172\1\0\2\172\10\0\2\172"+
    "\2\0\10\172\2\0\3\172\2\0\3\172\3\0\3\172"+
    "\1\0\3\172\5\0\11\172\1\0\2\172\1\u016f\2\172"+
    "\1\0\3\172\1\0\2\172\10\0\2\172\2\0\10\172"+
    "\2\0\3\172\2\0\3\172\3\0\3\172\1\0\3\172"+
    "\5\0\1\u0170\10\172\1\0\5\172\1\0\3\172\1\0"+
    "\2\172\10\0\2\172\2\0\10\172\2\0\3\172\2\0"+
    "\3\172\3\0\3\172\1\0\3\172\5\0\3\172\1\u0171"+
    "\5\172\1\0\5\172\1\0\3\172\1\0\2\172\10\0"+
    "\2\172\2\0\10\172\23\0\1\u0172\131\0\1\u0173\61\0"+
    "\1\u0174\107\0\1\u0175\45\0\1\u0176\3\366\1\0\1\u015f"+
    "\3\366\2\0\1\u0176\3\366\1\u0176\3\366\5\0\11\366"+
    "\1\0\5\366\1\0\3\366\1\0\2\366\10\0\2\366"+
    "\1\0\1\u0176\10\366\1\0\1\u015f\3\366\1\0\1\u015f"+
    "\3\366\2\0\1\u015f\3\366\1\u015f\3\366\5\0\11\366"+
    "\1\0\5\366\1\0\3\366\1\0\2\366\10\0\2\366"+
    "\1\0\1\u015f\10\366\22\0\1\u0177\114\0\1\u0178\104\0"+
    "\1\u0179\67\0\1\u017a\103\0\1\u017b\111\0\1\u017c\104\0"+
    "\1\u017d\46\0\1\u017e\1\102\1\u017f\1\102\1\0\1\u017e"+
    "\3\102\3\0\3\102\1\u017e\3\102\5\0\11\102\1\0"+
    "\5\102\1\0\3\102\1\0\2\102\10\0\2\102\1\u0180"+
    "\1\u017e\10\102\34\0\1\u0181\1\u0182\76\0\1\u0183\105\0"+
    "\1\u0184\105\0\1\u0185\45\0\3\172\2\0\3\172\3\0"+
    "\3\172\1\0\3\172\5\0\3\172\1\u0186\5\172\1\0"+
    "\5\172\1\0\3\172\1\0\2\172\10\0\2\172\2\0"+
    "\10\172\2\0\3\172\2\0\3\172\3\0\3\172\1\0"+
    "\3\172\5\0\11\172\1\0\1\172\1\u0187\3\172\1\0"+
    "\3\172\1\0\2\172\10\0\2\172\2\0\10\172\2\0"+
    "\3\172\2\0\3\172\3\0\3\172\1\0\3\172\5\0"+
    "\1\u0188\10\172\1\0\5\172\1\0\3\172\1\0\2\172"+
    "\10\0\2\172\2\0\10\172\2\0\3\172\2\0\3\172"+
    "\3\0\3\172\1\0\1\172\1\u0189\1\172\5\0\11\172"+
    "\1\0\5\172\1\0\3\172\1\0\2\172\10\0\2\172"+
    "\2\0\10\172\2\0\3\172\2\0\3\172\3\0\3\172"+
    "\1\0\3\172\5\0\11\172\1\0\1\u018a\4\172\1\0"+
    "\3\172\1\0\2\172\10\0\2\172\2\0\10\172\34\0"+
    "\1\u018b\102\0\1\u018c\112\0\1\u018d\71\0\1\u018e\100\0"+
    "\1\u018f\104\0\1\u0190\102\0\1\u0191\103\0\1\u0192\104\0"+
    "\1\u0193\115\0\1\u0194\32\0\1\u017e\4\0\1\u017e\11\0"+
    "\1\u017e\50\0\1\u0180\1\u017e\12\0\2\101\1\u0195\2\0"+
    "\1\u0195\2\101\3\0\3\u0195\1\0\3\u0195\5\0\10\u0195"+
    "\1\101\1\0\5\u0195\1\0\3\u0195\1\0\2\u0195\10\0"+
    "\2\u0195\2\0\10\u0195\1\0\1\u0180\4\0\1\u0180\11\0"+
    "\1\u0180\43\0\1\u0196\1\u0197\4\0\1\u0180\41\0\1\u0198"+
    "\103\0\1\u0199\110\0\1\u019a\44\0\3\172\2\0\3\172"+
    "\3\0\3\172\1\0\3\172\5\0\7\172\1\u019b\1\172"+
    "\1\0\5\172\1\0\3\172\1\0\2\172\10\0\2\172"+
    "\2\0\10\172\2\0\3\172\2\0\3\172\3\0\3\172"+
    "\1\0\3\172\5\0\1\u019c\10\172\1\0\5\172\1\0"+
    "\3\172\1\0\2\172\10\0\2\172\2\0\10\172\31\0"+
    "\1\u019d\116\0\1\u019e\73\0\1\u019f\76\0\1\u01a0\105\0"+
    "\1\u01a1\101\0\1\u01a2\105\0\1\u01a3\105\0\1\u01a4\71\0"+
    "\1\u01a5\53\0\1\u0195\1\101\1\u0195\2\0\3\u0195\3\0"+
    "\3\u0195\1\0\3\u0195\5\0\11\u0195\1\0\5\u0195\1\0"+
    "\3\u0195\1\0\2\u0195\10\0\2\u0195\2\0\10\u0195\37\0"+
    "\1\u01a6\102\0\1\u01a7\75\0\1\u01a8\52\0\3\172\2\0"+
    "\3\172\3\0\3\172\1\0\3\172\5\0\1\172\1\u01a9"+
    "\7\172\1\0\5\172\1\0\3\172\1\0\2\172\10\0"+
    "\2\172\2\0\10\172\44\0\1\u01aa\67\0\1\u01ab\104\0"+
    "\1\u01ac\107\0\1\u01ad\75\0\1\u01ae\50\0\1\u01af\16\0"+
    "\1\u01af\51\0\1\u01af\54\0\1\u01b0\70\0\1\u01b1\50\0";

  /** 
   * The transition table of the DFA
   */
  final private static int yytrans [] = yy_unpack();


  /* error codes */
  final private static int YY_UNKNOWN_ERROR = 0;
  final private static int YY_ILLEGAL_STATE = 1;
  final private static int YY_NO_MATCH = 2;
  final private static int YY_PUSHBACK_2BIG = 3;
  final private static int YY_SKIP_2BIG = 4;

  /* error messages for the codes above */
  final private static String YY_ERROR_MSG[] = {
    "Unkown internal scanner error",
    "Internal error: unknown state",
    "Error: could not match input",
    "Error: pushback value was too large",
    "Error: skip value was too large"
  };

  /**
   * YY_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  private final static byte YY_ATTRIBUTE[] = {
     0,  0,  0,  0,  0,  1,  1,  0,  1,  0,  0,  1,  0,  1,  1,  1, 
     1,  1,  1,  0,  0,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  0, 
     1,  1,  1,  1,  0,  0,  9,  9,  9,  9,  1,  1,  9,  9,  1,  1, 
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  9,  1,  1,  1,  1,  1, 
     1,  1,  1,  9,  1,  1,  1,  1,  1,  1,  1,  9,  9,  1,  1,  1, 
     1,  1,  1,  1,  1,  9,  3,  1,  1,  1,  9,  3,  1,  1,  9,  1, 
     1,  9,  3,  1,  1,  1,  9,  1,  9,  1,  9,  1,  1,  1,  1,  1, 
     1,  9,  1,  1,  1,  1,  9,  1,  1,  1,  9,  9,  1,  1,  1,  1, 
     1,  1,  1,  1,  9,  1,  1,  1,  1,  1,  1,  9,  1,  1,  9,  9, 
     9,  9,  1,  1,  1,  1,  1,  9,  9,  1,  1,  1,  1,  9,  9,  9, 
     1,  1,  1,  0,  0,  9,  0,  9,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  9,  9,  9,  1,  1,  1,  0,  0,  0,  1,  1,  1,  9,  1,  1, 
     1,  0,  0,  9,  9,  0,  9,  0,  0,  0,  0,  0,  0,  0, 13,  2, 
    13,  2, 13,  0,  0,  0,  0,  9,  0,  0,  1,  0,  0,  0,  1,  0, 
     1,  0,  0,  0,  0,  0,  9,  0,  1,  1,  1,  1,  1,  1,  1,  1, 
     0,  0,  0,  0,  9,  1,  1,  1,  0,  0,  0,  0,  9,  0,  9,  0, 
     9,  9,  9,  0,  0,  0,  0,  9,  1,  1,  0,  0,  0,  1,  1,  1, 
     1,  9,  9,  0,  0,  0,  0,  9,  9,  9,  9,  1,  0,  0,  0,  0, 
     0,  9,  9,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  1, 
     1,  0,  0,  0,  0,  9,  9,  9,  0,  0,  3,  3,  0,  0,  0,  1, 
     1,  9,  9,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1, 
     1,  0,  0,  0,  0,  3,  3,  0,  0,  0,  0,  9,  9, 13, 13,  0, 
     0,  0,  1,  9,  9,  0,  0,  0,  1,  9,  1,  1,  1,  1,  1,  1, 
     1,  0,  0,  0,  0, 13,  0,  0,  0,  0,  9,  0,  0,  0,  1,  0, 
     0,  9,  0,  0,  9,  1,  1,  1,  1,  1,  0,  0,  9,  0,  0,  0, 
     0,  0,  0,  0,  1,  9,  9,  0,  1,  0,  1,  1,  0,  0,  9,  0, 
     9,  0,  0,  9,  0,  9,  9,  9,  1,  9,  0,  9,  0,  9,  1,  9,  9
  };

  /** the input device */
  private java.io.Reader yy_reader;

  /** the current state of the DFA */
  private int yy_state;

  /** the current lexical state */
  private int yy_lexical_state = YYINITIAL;

  /** this buffer contains the current text to be matched and is
      the source of the yytext() string */
  private char yy_buffer[] = new char[YY_BUFFERSIZE];

  /** a pointer to the internal buffer, used to restore it when yyreset() changes
      the buffer to an externally created one. */
  private char yy_saved_buffer[] = yy_buffer;

  /** the textposition at the last accepting state */
  private int yy_markedPos;

  /** the textposition to keep text */
  private int yy_savePos = -1;

  /** the textposition at the last state to be included in yytext */
  private int yy_pushbackPos;

  /** the current text position in the buffer */
  private int yy_currentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int yy_startRead;

  /** endRead marks the last character in the buffer, that has been read
      from input */
  private int yy_endRead;

  /** number of newlines encountered up to the start of the matched text */
  private int yyline;

  /** the number of characters up to the start of the matched text */
  private int yychar;

  /**
   * the number of characters from the last newline up to the start of the
   * matched text
   */
  private int yycolumn;

  /**
   * yy_atBOL == true <=> the scanner is currently at the beginning of a line
   */
  private boolean yy_atBOL = true;

  /** yy_atEOF == true <=> the scanner is at the EOF */
  private boolean yy_atEOF;


  /** the stack of open (nested) input streams to read from */
  private java.util.Stack yy_streams = new java.util.Stack();

  /**
   * inner class used to store info for nested
   * input streams
   */
  final static private class YY_StreamInfo {
    java.io.Reader yy_reader;
    int yy_endRead;
    int yy_startRead;
    int yy_savePos;
    int yy_currentPos;
    int yy_markedPos;
    int yy_pushbackPos;
    int yyline;
    int yycolumn;
    char [] yy_buffer;
    boolean yy_atEOF;

    /** sets all values stored in this class */
    YY_StreamInfo(java.io.Reader yy_reader, int yy_endRead, int yy_startRead, int yy_savePos,
                  int yy_currentPos, int yy_markedPos, int yy_pushbackPos,
                  char [] yy_buffer, boolean yy_atEOF, int yyline, int yycolumn) {
      this.yy_reader      = yy_reader;
      this.yy_endRead     = yy_endRead;
      this.yy_startRead   = yy_startRead;
      this.yy_savePos     = yy_savePos;
      this.yy_currentPos  = yy_currentPos;
      this.yy_markedPos   = yy_markedPos;
      this.yy_pushbackPos = yy_pushbackPos;
      this.yy_buffer      = yy_buffer;
      this.yy_atEOF       = yy_atEOF;
      this.yyline         = yyline;
      this.yycolumn       = yycolumn;
    }
  }


  /** denotes if the user-EOF-code has already been executed */
  private boolean yy_eof_done;

  /* user code: */

    // Variables accessible to parser class
    Piccolo parser = null;
    Entity currentEntity = null;
    CharStringConverter stringConverter = new CharStringConverter(200);
    EntityManager entityManager = new EntityManager();
    Stack entityStack = new Stack();
    AttributesHolder attribs = new AttributesHolder();

    // Generic character buffer, usually for attribute values
    char[] cbuf = new char[1024];
    int cbuflen;


    // Variables used to hold token values for the parser
    String stringValue;
    char[] oneCharBuffer = new char[1];
    char[] cdataBuffer;
    int cdataStart, cdataLength;

    // Variables used to maintain lexing and parsing states
    private LongStack entityStateStack = new LongStack(5);
    private StringStack entityNameStack = new StringStack(2);
    private String currentEntityName;
    private int prevEntityLexState;
    private boolean returnEntityEndToken;
    private boolean isParamEntity;
    private int entityBaseDepth;
    private boolean isEntityBeingParsed;
    private boolean inCdataSection;

    private int baseState; // Used for reporting CDATA directly from lexer
    private int prevState, piPrevState;
    private boolean isNamespaceDeclaration;
    private boolean entityWasSkipped;
    private int tagState;
    private int tagStartState;

    private boolean tokenizeInput;
    private StringStack tagStack = new StringStack(20);
    private boolean bypassPERefs;
    private boolean bypassGERefs;
    private boolean needsNormalization;
    private int tagType; // Piccolo.OPEN_TAG,EMPTY_TAG,CLOSE_TAG
    private boolean endOfTag;

    private HashMap elementMap = new HashMap();

    // Variables to hold element and attribute name components
    private ElementDefinition elementDefinition = null;
    private String elementURI;
    private String elementLocalName;
    private String elementQName;
    private String attributeURI;
    private String attributeLocalName;
    private String attributeQName;
    private String attributeValueType;

    // this is used for tracking the start line of the first character of a token
    // only works for start element for now
    //
    int tokenStartLine;

    // An array for marking whether we've seen an attribute as we parse the tag.
    // This is used to "fill in the holes" with default values specified in the DTD.
    private boolean[] defaultAttributeSpecified = new boolean[4];
    private int numAttributesDefined;

    private FastNamespaceSupport nsSupport = new FastNamespaceSupport();

    static private boolean[] asciiNameStartChars;
    static private boolean[] asciiNameStartCharsNS;
    static private boolean[] asciiNameChars;
    static private boolean[] asciiNameCharsNS;

    /************************************************************************
     * Initialization code
     ************************************************************************/

    static {
        calcAsciiTables();
    }

    public PiccoloLexer (Piccolo parser) {
        this.parser = parser;
        enableNamespaces(true);
    }

    /* Prepare the lexer to parse the given Entity. */
    public void reset(Entity entity) throws IOException, SAXException {
        try {
            setTokenize(true);
            tagStack.clear();

            // clear out any residual attributes from last parse
            attribs.clear();

            entityStack.clear();
            clearEntityState();
            elementMap.clear();
            currentEntity = entity;

            entityManager.clear();
            elementDefinition = null;
            if (!entity.isOpen())
                entity.open();

            if (parser.fNamespaces) {
                nsSupport.reset();
            }
            isNamespaceDeclaration=false;

            bypassPERefs=bypassGERefs=false;
            needsNormalization = false;
            entityWasSkipped = false;
            inCdataSection = false;
            cbuflen = cdataStart = cdataLength = 0;
            tagType = 0;
            prevState = piPrevState = 0;
            endOfTag = false;
            tokenStartLine=0;
            numAttributesDefined=0;

            yy_reader = null; // Don't close the reader as we reuse it.
            yyreset(entity.getReader());
        } catch (RecursionException e) {}
    }

    /************************************************************************
     * End Initialization code
     ************************************************************************/



    /************************************************************************
     * Methods providing service to Piccolo
     ************************************************************************/

    void enableNamespaces(boolean value) {
        if (value) {
            tagState = TAG_NS;
            tagStartState = TAG_START_NS;
        }
        else {
            tagState = TAG;
            tagStartState = TAG_START;
            elementURI = elementLocalName = "";
            attributeURI = attributeLocalName = "";
        }
    }

    /* Define an element as specified within a DTD */
    void defineElement (String name, ElementDefinition elem) {
        elementMap.put(name, elem);
    }

    ElementDefinition getElement (String name) {
        return  (ElementDefinition)elementMap.get(name);
    }

    public int getLineNumber () {
        return  yyline + 1;
    }

    public int getColumnNumber () {
        // return  yycolumn + 1;
        return -1;
    }

    /* Returns the public identified of the current entity */
    String getPublicID () {
        if (currentEntity != null)
            return  currentEntity.getPublicID();
        else
            return null;
    }

    /* Returns the system identifier of the current entity */
    String getSystemID () {
        if (currentEntity != null)
            return  currentEntity.getSystemID();
        else
            return null;
    }

    // give access to the info in the XML declaration
    String getVersion () {
        if (currentEntity != null)
            return  currentEntity.getXMLVersion();
        else
            return null;
    }

    String getEncoding () {
        if (currentEntity != null)
            return  currentEntity.getDeclaredEncoding();
        else
            return null;
    }

    /* Whether or not text and tags should be returned as tokens to
     * Piccolo or directly reported.
     * Note: when tokenization is on, tags are still reported to the
     * content handler, while text is left to the Piccolo class.
     */
    void setTokenize(boolean tokenize) {
        tokenizeInput = tokenize;
        baseState = (tokenize? YYINITIAL : YYINITIAL_DIRECT);
        int state = yystate();
        if (state == YYINITIAL || state == YYINITIAL_DIRECT)
            yybegin(baseState);
    }

    String normalizeValue(String s) {
        if (s == null || s.length() == 0)
            return s;

        char[] inbuf = s.toCharArray();
        int in_len = inbuf.length;
        int inpos = 0;

        char[] outbuf = new char[in_len];
        int outpos = 0;

        // Eliminate the leading whitespace
        while (inpos < in_len) {
            switch (inbuf[inpos]) {
                case ' ':
                case '\t':
                case '\n':
                case '\r':
                    inpos++;
                    continue;
                default:
                    break;
            }
            break;
        }

        while (inpos < in_len) {
            // Read a name token
            do {
                char c = inbuf[inpos++];
                switch (c) {
                    case ' ':
                    case '\t':
                    case '\n':
                    case '\r':
                        break;

                    default:
                        outbuf[outpos++] = c;
                        continue;
                }
                break;
            } while (inpos < in_len);

            // Condense the whitespace
            while (inpos < in_len) {
                char c = inbuf[inpos++];
                switch (c) {
                    case ' ':
                    case '\t':
                    case '\n':
                    case '\r':
                        continue;

                    default:
                        outbuf[outpos++] = ' ';
                        outbuf[outpos++] = c;
                        break;
                }
                break;
            }
        }

        return new String(outbuf,0,outpos);
    }

    void startCdata() throws SAXException {
        if (parser.lexHandler != null) {
            parser.lexHandler.startCDATA();
            inCdataSection = true;
        }
    }

    void endCdata() throws SAXException {
        if (parser.lexHandler != null) {
            parser.lexHandler.endCDATA();
            inCdataSection = false;
        }
    }


    /************************************************************************
     * End Methods providing service to Piccolo
     ************************************************************************/




    /************************************************************************
     * Methods used to return text and tokens to Piccolo
     ************************************************************************/

    // Append a character to our character buffer
    private void appendToCbuf (char c) {
        if (cbuf.length - cbuflen < 1) {
            char[] newcbuf = new char[2*(cbuf.length + 1)];
            System.arraycopy(cbuf, 0, newcbuf, 0, cbuflen);
            cbuf = newcbuf;
        }
        cbuf[cbuflen++] = c;
    }

    // Append a character array to our character buffer
    private void appendToCbuf (char[] ch, int start, int length) {
        if (length > 0) {
            if (cbuf.length - cbuflen < length) {
                char[] newcbuf = new char[2*(cbuf.length + length)];
                System.arraycopy(cbuf, 0, newcbuf, 0, cbuflen);
                cbuf = newcbuf;
            }
            System.arraycopy(ch, start, cbuf, cbuflen, length);
            cbuflen += length;
        }
    }

    // Clear the character buffer
    private void clearCbuf () {
        cbuflen = 0;
    }


    // Return a token with a String value to Piccolo
    private int stringToken (int token, String value) {
        stringValue = value;
        return  token;
    }

    // Return a token with a char[] value to Piccolo
    private int cdataToken (char[] buf, int start, int length) {
        return  cdataToken(Piccolo.CDATA, buf, start, length);
    }

    private int cdataToken (int token, char[] buf, int start, int length) {
        cdataBuffer = buf;
        cdataStart = start;
        cdataLength = length;
        return  token;
    }

    private int cdataToken (char c) {
        oneCharBuffer[0] = c;
        cdataBuffer = oneCharBuffer;
        cdataStart = 0;
        cdataLength = 1;
        return  Piccolo.CDATA;
    }

    /************************************************************************
     * End Methods used to return text and tokens to Piccolo
     ************************************************************************/



    /************************************************************************
     * Code used to parse XML without JFlex's help. We use this code to
     * parse the non-DTD portion of an XML document when namespaces is
     * turned off, because that parsing is simple enough that it is faster
     * to use hand-crafted switch statements than JFlex's transition tables.
     ************************************************************************/


    /* The driver for our non-JFlex XML parsing.
     * Return values:
     *      0 = break out of non-JFlex mode but do not return a token to
     *          Piccolo.
     *      non-zero = return this token value to Piccolo
     */
    private int parseXML() throws SAXException, IOException {

        if (parser.fNamespaces)
            return parseXMLNS();

        while(true) {
            parseCdata();
            parser.reportCdata(cdataBuffer,cdataStart,cdataLength);
            yynextAction();
            if (yystate() == tagStartState) {
                int token = parseTag();
                switch (token) {
                    case -1:
                        return 0;
                    case 0:
                        yynextAction();
                        break;
                    default:
                        return token;
                }
            }
            else
                return 0;
        }
    }


    // Same as parseXML but with namespaces
    private int parseXMLNS() throws SAXException, IOException {

        while(true) {
            parseCdata();
            parser.reportCdata(cdataBuffer,cdataStart,cdataLength);
            yynextAction();
            if (yystate() == tagStartState) { // No namespaces!
                int token = parseTagNS();
                switch (token) {
                    case -1:
                        return 0;
                    case 0:
                        yynextAction();
                        break;
                    default:
                        return token;
                }
            }
            else
                return 0;
        }
    }





    /* Parses an XML element when namespace processing is turned off.
     * Return values:
     *     -1  = we can't handle this tag. Break out of non-JFlex mode.
     *      0  = we finished processing this tag.
     *      Piccolo.CLOSE_TAG = this is the last ending tag. Return
     *         this token value to Piccolo.
     */
    private int parseTag() throws SAXException, IOException {

        int token;

        // Check the first character
        if ((yy_endRead-yy_markedPos) > 0) {
            int c = yy_buffer[yy_markedPos];
            switch (c) {
                case '?':
                case '!':
                    yybegin(tagStartState);
                    return -1; // Leave special tags for lex

                case '/':
                    return parseCloseTag();

                default:
                    return parseOpenTag();
            }
        }
        else
            return -1;
    }

    // Same as parseTag but with namespaces
    private int parseTagNS() throws SAXException, IOException {

        int token;

        // Check the first character
        if ((yy_endRead-yy_markedPos) > 0) {
            int c = yy_buffer[yy_markedPos];
            switch (c) {
                case '?':
                case '!':
                    yybegin(tagStartState);
                    return -1; // Leave special tags for lex

                case '/':
                    return parseCloseTagNS();

                default:
                    return parseOpenTagNS();
            }
        }
        else
            return -1;
    }




    private int parseOpenTag() throws SAXException, IOException  {
        // Get the element name first
        stringValue = parseElementName();
        if (stringValue == null) {
            yybegin(tagStartState);
            return -1;
        }


        for (int c = yy_buffer[yy_markedPos++];true;c = yynextChar()) {
            while (true) {

                if (c == '>') {
                    // yycolumn_next++;
//                    if (parser.fNamespaces) {
//                        nsSupport.pushContext();
//                        elementURI = nsSupport.getURI(elementURI);
//                    }
                    yybegin(baseState);
                    processSimpleElement(stringValue);
                    parser.reportStartTag(elementURI,elementLocalName,stringValue);
                    attribs.clear();
                    tagStack.push(stringValue);
                    tagType = Piccolo.OPEN_TAG;
                    if (tokenizeInput)
                        return Piccolo.OPEN_TAG;
                    else
                        return 0;
                }
                else
                if (c == '/') {
                    // yycolumn_next++;
                    c = yynextChar();
                    if (c  != '>')
                        throw fatalError("'/' should be followed by '>'");

                    // yycolumn_next++;
                    yybegin(baseState);

//                    if (parser.fNamespaces)
//                        elementURI = nsSupport.getURI(elementURI);

                    processSimpleElement(stringValue);
                    parser.reportStartTag(elementURI,elementLocalName,stringValue);
                    parser.reportEndTag(elementURI,elementLocalName,stringValue);
                    attribs.clear();

                    tagType = Piccolo.EMPTY_TAG;
                    if (tokenizeInput)
                        return Piccolo.EMPTY_TAG;
                    else
                        return 0;
                }
                else
                if (c == ' ' || c == '\t') {
                    // yycolumn_next++;
                }
                else
                if (c == '\n') {
                    yyline_next++;
                    // yycolumn_next = 0;
                }
                else {
                        yy_markedPos--;
                        prepareComplexElement(stringValue);

//                        if (parser.fNamespaces)
//                            nsSupport.pushContext();

                        return parseAttributes();
                }

                if ((yy_endRead-yy_markedPos) > 0)
                    c = yy_buffer[yy_markedPos++];
                else
                    break;
            }
        }
    }

    // Same as parseOpenTag but with namespaces
    private int parseOpenTagNS() throws SAXException, IOException  {
        // Get the element name first
        stringValue = parseElementNameNS();
        if (stringValue == null) {
            yybegin(tagStartState);
            return -1;
        }


        for (int c = yy_buffer[yy_markedPos++];true;c = yynextChar()) {
            while (true) {

                if (c == '>') {
                    // yycolumn_next++;
//                    if (parser.fNamespaces) {
                        nsSupport.pushContext();
                        elementURI = nsSupport.getURI(elementURI);
//                    }
                    yybegin(baseState);
                    processSimpleElement(stringValue);
                    parser.reportStartTag(elementURI,elementLocalName,stringValue);
                    attribs.clear();
                    tagStack.push(stringValue);
                    tagType = Piccolo.OPEN_TAG;
                    if (tokenizeInput)
                        return Piccolo.OPEN_TAG;
                    else
                        return 0;
                }
                else
                if (c == '/') {
                    // yycolumn_next++;
                    c = yynextChar();
                    if (c  != '>')
                        throw fatalError("'/' should be followed by '>'");

                    // yycolumn_next++;
                    yybegin(baseState);

//                    if (parser.fNamespaces)
                        elementURI = nsSupport.getURI(elementURI);

                    processSimpleElement(stringValue);
                    parser.reportStartTag(elementURI,elementLocalName,stringValue);
                    parser.reportEndTag(elementURI,elementLocalName,stringValue);
                    attribs.clear();
                    tagType = Piccolo.EMPTY_TAG;
                    if (tokenizeInput)
                        return Piccolo.EMPTY_TAG;
                    else
                        return 0;
                }
                else
                if (c == ' ' || c == '\t') {
                    // yycolumn_next++;
                }
                else
                if (c == '\n') {
                    yyline_next++;
                    // yycolumn_next = 0;
                }
                else {
                        yy_markedPos--;
                        prepareComplexElement(stringValue);

//                        if (parser.fNamespaces)
                            nsSupport.pushContext();

                        return parseAttributesNS();
                }

                if ((yy_endRead-yy_markedPos) > 0)
                    c = yy_buffer[yy_markedPos++];
                else
                    break;
            }
        }
    }






    /* Parse the attributes and remainder of an open (or empty) tag.
     * Return values:
     *     -1  = we can't handle this tag. Break out of non-JFlex mode.
     *      0  = we finished processing this tag.
     *      Piccolo.CLOSE_TAG = this is the last ending tag. Return
     *         this token value to Piccolo.
     */
    private int parseAttributes() throws SAXException, IOException {
        String name,value;
        yybegin(tagState);

        // loop through sets of Name, '=', Value
        int c = 0;

        endOfTag = false; // set to true when [/>] is hit after a literal
        while(!endOfTag) {
            if ((yy_endRead-yy_markedPos) > 0) {
                // Name
                parseAttributeName();
                if (attributeQName == null)
                    break;

                // '='
                int bufferLeft = (yy_endRead-yy_markedPos);
                loop_eq:
                while (bufferLeft-- > 0) {
                    switch (yy_buffer[yy_markedPos++]) {
                        case '=':
                            break loop_eq;

                        case ' ':
                        case '\t':
                            // yycolumn_next++;
                            break;

                        case '\n':
                            yyline_next++;
                            // yycolumn_next = 0;
                            break;

                        default:
                            // hit something weird; kick back to lex
                            yy_markedPos--;
                            yybegin(TAG_VALUE);
                            return -1;
                    }
                }
                if (bufferLeft < 0) {
                    yybegin(TAG_VALUE);
                    return -1;
                }


                // Whitespace, ' or " (to begin the value)
                value_loop:
                for (c = yynextChar(); c != YYEOF; c = yynextChar()) {
                    switch (c) {
                        case '"':
                            // yycolumn_next++;
                            parseQuotedTagValue();
                            if (yystate() != tagState)
                                return -1;
                            break value_loop;

                        case '\'':
                            // yycolumn_next++;
                            parseSingleQuotedTagValue();
                            if (yystate() != tagState)
                                return -1;
                            break value_loop;

                        case ' ':
                        case '\t':
                            // yycolumn_next++;
                            break;

                        case '\n':
                            yyline_next++;
                            // yycolumn_next = 0;
                            break;

                        default:
                            throw fatalError("Unexpected character encountered: '"
                                + (char)c + "'");
                    }
                }
                if (c == YYEOF)
                    throw fatalError("Unexpected end of file");
            }
            else {
                // ran out of buffer; kick back to lex
                return -1;
            }
        }


        // No more attributes; parse the end of the tag
        while ((yy_endRead-yy_markedPos) > 0) {
            switch (yy_buffer[yy_markedPos++]) {
                case '>':
                    // yycolumn_next++;
                    yybegin(baseState);
                    processComplexElement();

//                    if (parser.fNamespaces) {
//                        resolveNamespacePrefixes();
//                    }

                    parser.reportStartTag(elementURI,elementLocalName,stringValue);
                    tagStack.push(stringValue);
                    attribs.clear();
                    tagType = Piccolo.OPEN_TAG;
                    if (tokenizeInput)
                        return Piccolo.OPEN_TAG;
                    else
                        return 0;

                case '/':
                    // yycolumn_next++;
                    if ( (yynextChar()) != '>')
                        throw fatalError("'/' should be followed by '>'");
                    // yycolumn_next++;

                    yybegin(baseState);
                    processComplexElement();

//                    if (parser.fNamespaces) {
//                        resolveNamespacePrefixes();
//                        parser.reportStartTag(elementURI,elementLocalName,stringValue);
//                        parser.reportEndTag(elementURI,elementLocalName,stringValue);
//                        processNSContextEnd();
//                    }
//                    else {
                        parser.reportStartTag(elementURI,elementLocalName,stringValue);
                        parser.reportEndTag(elementURI,elementLocalName,stringValue);
//                    }


                    attribs.clear();
                    tagType = Piccolo.EMPTY_TAG;
                    if (tokenizeInput)
                        return Piccolo.EMPTY_TAG;
                    else
                        return 0;

                case ' ':
                case '\t':
                    // yycolumn_next++;
                    break;

                case '\n':
                    yyline_next++;
                    // yycolumn_next = 0;
                    break;

                default:
                    throw fatalError("Unexpected character: " + (char)c);
            }
        }
        // hit the end of the buffer
        return -1;
    }


  // Same as parseAttributes but with namespaces
  private int parseAttributesNS() throws SAXException, IOException {
        String name,value;
        yybegin(tagState);

        // loop through sets of Name, '=', Value
        int c = 0;

        endOfTag = false; // set to true when [/>] is hit after a literal
        while(!endOfTag) {
            if ((yy_endRead-yy_markedPos) > 0) {
                // Name
                parseAttributeNameNS();
                if (attributeQName == null)
                    break;

                // '='
                int bufferLeft = (yy_endRead-yy_markedPos);
                loop_eq:
                while (bufferLeft-- > 0) {
                    switch (yy_buffer[yy_markedPos++]) {
                        case '=':
                            break loop_eq;

                        case ' ':
                        case '\t':
                            // yycolumn_next++;
                            break;

                        case '\n':
                            yyline_next++;
                            // yycolumn_next = 0;
                            break;

                        default:
                            // hit something weird; kick back to lex
                            yy_markedPos--;
                            yybegin(TAG_VALUE);
                            return -1;
                    }
                }
                if (bufferLeft < 0) {
                    yybegin(TAG_VALUE);
                    return -1;
                }


                // Whitespace, ' or " (to begin the value)
                value_loop:
                for (c = yynextChar(); c != YYEOF; c = yynextChar()) {
                    switch (c) {
                        case '"':
                            // yycolumn_next++;
                            parseQuotedTagValue();
                            if (yystate() != tagState)
                                return -1;
                            break value_loop;

                        case '\'':
                            // yycolumn_next++;
                            parseSingleQuotedTagValue();
                            if (yystate() != tagState)
                                return -1;
                            break value_loop;

                        case ' ':
                        case '\t':
                            // yycolumn_next++;
                            break;

                        case '\n':
                            yyline_next++;
                            // yycolumn_next = 0;
                            break;

                        default:
                            throw fatalError("Unexpected character encountered: '"
                                + (char)c + "'");
                    }
                }
                if (c == YYEOF)
                    throw fatalError("Unexpected end of file");
            }
            else {
                // ran out of buffer; kick back to lex
                return -1;
            }
        }

        // No more attributes; parse the end of the tag
        while ((yy_endRead-yy_markedPos) > 0) {
            switch (yy_buffer[yy_markedPos++]) {
                case '>':
                    // yycolumn_next++;
                    yybegin(baseState);
                    processComplexElement();

//                    if (parser.fNamespaces) {
                        resolveNamespacePrefixes();
//                    }

                    parser.reportStartTag(elementURI,elementLocalName,stringValue);
                    tagStack.push(stringValue);
                    attribs.clear();
                    tagType = Piccolo.OPEN_TAG;
                    if (tokenizeInput)
                        return Piccolo.OPEN_TAG;
                    else
                        return 0;

                case '/':
                    // yycolumn_next++;
                    if ( (yynextChar()) != '>')
                        throw fatalError("'/' should be followed by '>'");
                    // yycolumn_next++;

                    yybegin(baseState);
                    processComplexElement();

//                    if (parser.fNamespaces) {
                        resolveNamespacePrefixes();
                        parser.reportStartTag(elementURI,elementLocalName,stringValue);
                        parser.reportEndTag(elementURI,elementLocalName,stringValue);
                        processNSContextEnd();
//                    }
//                    else {
//                        parser.reportStartTag(elementURI,elementLocalName,stringValue);
//                        parser.reportEndTag(elementURI,elementLocalName,stringValue);
//                    }


                    attribs.clear();
                    tagType = Piccolo.EMPTY_TAG;
                    if (tokenizeInput)
                        return Piccolo.EMPTY_TAG;
                    else
                        return 0;

                case ' ':
                case '\t':
                    // yycolumn_next++;
                    break;

                case '\n':
                    yyline_next++;
                    // yycolumn_next = 0;
                    break;

                default:
                    throw fatalError("Unexpected character: " + (char)c);
            }
        }
        // hit the end of the buffer
        return -1;
    }



    private void parseAttributeName() throws SAXException, IOException {

//        if (parser.fNamespaces) {
//            attributeURI = null;
//            isNamespaceDeclaration = false;
//        }


        // Skip leading whitespace and get the first char
        int c = yy_buffer[yy_markedPos++];
//        int localNameOffset=0;
        ws_loop:
        for (; true;
             c = yynextChar()) {

            while (true) {
                if (c==' '||c=='\t') {
                    // yycolumn_next++;
                }
                else
                if (c=='\n') {
                    yyline_next++;
                    // yycolumn_next = 0;
                }
                else
                if (c == '/') {
                    yy_markedPos--;
                    attributeQName = null;
                    return;
                }
                else
                if (c == '>') {
                    yy_markedPos--;
                    attributeQName = null;
                    return;
                }
                else if (isASCIINameStartChar(c)) {
                    // yycolumn_next++;
                    yy_startRead = yy_markedPos-1;
                    break ws_loop;
                }
//                else
//                if (c == ':') {
//                    if (parser.fNamespaces) {
//                        localNameOffset = yy_markedPos - yy_startRead;
//                        attributeURI = "";
//                    }
//                    break ws_loop;
//                }
                else {
                    // Something weird. unread the char and return
                    yy_markedPos--;
                    attributeQName = "";
                    return;
                }

                if ((yy_endRead-yy_markedPos) > 0)
                    c = yy_buffer[yy_markedPos++];
                else
                    break;
            }
        }

        // Read attribute name
        for (; true;
             c = yynextChar()) {

            while (true) {
                if (isASCIINameChar(c)) {
                    // yycolumn_next++;
                }
/*
                else
                if (c == ':') {
                    // yycolumn_next++;
                    if (parser.fNamespaces && attributeURI == null) {
                        // only the first ':' separates
                        attributeURI = stringConverter.convert(yy_buffer,
                                        yy_startRead,
                                        (yy_markedPos-1)-yy_startRead);
                        localNameOffset = yy_markedPos-yy_startRead;
                    }
                }
 */
                else {
                    yy_markedPos--;

/*
                    if (parser.fNamespaces) {
                        if (attributeURI == null)
                            attributeURI = "";

                        attributeLocalName
                            = yytext2(localNameOffset,
                                yy_markedPos-(yy_startRead+localNameOffset));
                        if (attributeURI == "xmlns" ||
                            attributeLocalName == "xmlns")
                            isNamespaceDeclaration = true;
                    }
 */
                    attributeQName = yytext2();
                    return;
                }

                if ((yy_endRead-yy_markedPos) > 0)
                    c = yy_buffer[yy_markedPos++];
                else
                    break;
            }
        }
    }


    // Same as parseAttributeName but with namespaces
    private void parseAttributeNameNS() throws SAXException, IOException {

//        if (parser.fNamespaces) {
            attributeURI = null;
            isNamespaceDeclaration = false;
//        }


        // Skip leading whitespace and get the first char
        int c = yy_buffer[yy_markedPos++];
        int localNameOffset=0;
        int bufferLeft = (yy_endRead-yy_markedPos);
        ws_loop:
        for (; true;
             c = yynextChar()) {

            while (true) {
                if (c==' '||c=='\t') {
                    // yycolumn_next++;
                }
                else
                if (c=='\n') {
                    yyline_next++;
                    // yycolumn_next = 0;
                }
                else
                if (c == '/') {
                    yy_markedPos--;
                    attributeQName = null;
                    return;
                }
                else
                if (c == '>') {
                    yy_markedPos--;
                    attributeQName = null;
                    return;
                }
                else if (isASCIINameStartChar(c)) {
                    // yycolumn_next++;
                    yy_startRead = yy_markedPos-1;
                    break ws_loop;
                }
                else
                if (c == ':') {
//                    if (parser.fNamespaces) {
                        localNameOffset = yy_markedPos - yy_startRead;
                        attributeURI = "";
//                    }
                    break ws_loop;
                }
                else {
                    // Something weird. unread the char and return
                    yy_markedPos--;
                    attributeQName = "";
                    return;
                }

                if ((yy_endRead-yy_markedPos) > 0)
                    c = yy_buffer[yy_markedPos++];
                else
                    break;
            }
        }

        // Read attribute name
        for (; true;
             c = yynextChar()) {

            while (true) {
                if (isASCIINameCharNS(c)) {
                    // yycolumn_next++;
                }
                else
                if (c == ':') {
                    // yycolumn_next++;
//                    if (parser.fNamespaces && attributeURI == null) {
                    if (attributeURI == null) {
                        // only the first ':' separates
                        attributeURI = stringConverter.convert(yy_buffer,
                                        yy_startRead,
                                        (yy_markedPos-1)-yy_startRead);
                        localNameOffset = yy_markedPos-yy_startRead;
                    }
                }
                else {
                    yy_markedPos--;

//                    if (parser.fNamespaces) {
                        if (attributeURI == null)
                            attributeURI = "";

                        attributeLocalName
                            = yytext2(localNameOffset,
                                yy_markedPos-(yy_startRead+localNameOffset));
                        if (attributeURI == "xmlns" ||
                            attributeLocalName == "xmlns")
                            isNamespaceDeclaration = true;
//                    }

                    attributeQName = yytext2();
                    return;
                }

                if ((yy_endRead-yy_markedPos) > 0)
                    c = yy_buffer[yy_markedPos++];
                else
                    break;
            }
        }
    }



    /* Parse a close tag. The element name starts at yy_buffer[yy_markedPos].
     * Return values:
     *     -1  = we can't handle this tag. Break out of non-JFlex mode.
     *      0  = we finished processing this tag.
     *      Piccolo.CLOSE_TAG = this is the last ending tag. Return
     *         this token value to Piccolo.
     */
    private int parseCloseTag() throws SAXException, IOException {
        yy_markedPos++; // skip the "/"
        // yycolumn_next++;

        stringValue = parseElementName();
        if (stringValue == null) {
            // We ran into trouble; kick it back to lex
            yybegin(tagStartState);
            yy_markedPos--; // unread the "/"
            // yycolumn_next--;
            return -1;
        }

        while ((yy_endRead-yy_markedPos) > 0) {
            char c = yy_buffer[yy_markedPos++];

            switch (c) {
                case '>':
                    // yycolumn_next++;
                    checkEndTag(stringValue);

//                    if (parser.fNamespaces) {
//                        parser.reportEndTag(elementURI,elementLocalName,stringValue);
//                        processNSContextEnd();
//                    }
//                    else {
                        parser.reportEndTag(elementURI,elementLocalName,stringValue);
//                    }

                    yybegin(baseState);
                    tagType = Piccolo.CLOSE_TAG;
                    if (tokenizeInput)
                        return Piccolo.CLOSE_TAG;
                    else
                        return 0;

                case ' ':
                case '\t':
                    // yycolumn_next++;
                    break;

                case '\n':
                    yyline_next++;
                    // yycolumn_next = 0;
                    break;

                default:
                    // Something that shouldn't be here
                    throw fatalError("Unexpected character encountered while in a closing tag: '"
                                    + c + "'");
            }
        }

        // We hit the end of the buffer; let lex continue
        yybegin(parser.fNamespaces? CLOSE_TAG_NS : CLOSE_TAG);
        return -1;
    }


  // Same as parseCloseTag but with namespaces
  private int parseCloseTagNS() throws SAXException, IOException {
        yy_markedPos++; // skip the "/"
        // yycolumn_next++;

        stringValue = parseElementNameNS();
        if (stringValue == null) {
            // We ran into trouble; kick it back to lex
            yybegin(tagStartState);
            yy_markedPos--; // unread the "/"
            // yycolumn_next--;
            return -1;
        }

        while ((yy_endRead-yy_markedPos) > 0) {
            char c = yy_buffer[yy_markedPos++];

            switch (c) {
                case '>':
                    // yycolumn_next++;
                    checkEndTag(stringValue);

//                    if (parser.fNamespaces) {
                            elementURI = nsSupport.getURI(elementURI);
                        parser.reportEndTag(elementURI,elementLocalName,stringValue);
                        processNSContextEnd();
//                    }
//                    else {
//                        parser.reportEndTag(elementURI,elementLocalName,stringValue);
//                    }

                    yybegin(baseState);
                    tagType = Piccolo.CLOSE_TAG;
                    if (tokenizeInput)
                        return Piccolo.CLOSE_TAG;
                    else
                        return 0;

                case ' ':
                case '\t':
                    // yycolumn_next++;
                    break;

                case '\n':
                    yyline_next++;
                    // yycolumn_next = 0;
                    break;

                default:
                    // Something that shouldn't be here
                    throw fatalError("Unexpected character encountered while in a closing tag: '"
                                    + c + "'");
            }
        }

        // We hit the end of the buffer; let lex continue
        yybegin(parser.fNamespaces? CLOSE_TAG_NS : CLOSE_TAG);
        return -1;
    }


    private String parseElementName() throws SAXException, IOException {
        yy_startRead = yy_markedPos;
//        int localNameOffset = 0;

//        if (parser.fNamespaces)
//            elementURI = null;


        // First character
        int c = yynextChar();

        if (isASCIINameStartChar(c)) {
            // yycolumn_next++;
        }
/*
        else
        if (c == ':') {
            // yycolumn_next++;
            if (parser.fNamespaces) {
                localNameOffset = 1;
                elementURI = "";
            }
        }
 */
        else {
            yybegin(tagStartState);
            yy_markedPos--;
            return null;
        }

        // The rest of the element name
        element_loop:
        while(true) {

            while ( (yy_endRead-yy_markedPos) > 0) {
                c = yy_buffer[yy_markedPos++];

                if (isASCIINameChar(c)) {
                    // yycolumn_next++;
                }
                else
                if (c == '>' || c == ' ' || c == '/')
                    break element_loop;
/*
                else
                if (c == ':') {
                    if (parser.fNamespaces && elementURI == null) { // only the first ':' separates
                        elementURI = stringConverter.convert(yy_buffer,
                                        yy_startRead,(yy_markedPos-yy_startRead)-1);
                        localNameOffset = (yy_markedPos-yy_startRead);
                    }
                }
 */
                else
                if (c == '\n' || c == '\t')
                    break element_loop;
                else {
                    yy_markedPos = yy_startRead;
                    return null;
                }
            }

            c = yynextChar();
            if (c < 0)
                throw fatalError("Unexpected end of file");
            yy_markedPos--;
        }
        yy_markedPos--;

//        if (parser.fNamespaces) {
//            elementLocalName = yytext2(localNameOffset,
//                                yy_markedPos-(yy_startRead+localNameOffset));
//        }

        return yytext2();
    }


    // Same as parseElementName but with namespaces enabled
    private String parseElementNameNS() throws SAXException, IOException {
        yy_startRead = yy_markedPos;
        int localNameOffset = 0;

//        if (parser.fNamespaces)
            elementURI = null;


        // First character
        int c = yynextChar();

        if (isASCIINameStartCharNS(c)) {
            // yycolumn_next++;
        }
        else
        if (c == ':') {
            // yycolumn_next++;
//            if (parser.fNamespaces) {
                localNameOffset = 1;
                elementURI = "";
//            }
        }
        else {
            yybegin(tagStartState);
            yy_markedPos--;
            return null;
        }

        // The rest of the element name
        element_loop:
        while (true) {

            while ( (yy_endRead-yy_markedPos) > 0) {
                c = yy_buffer[yy_markedPos++];

                if (isASCIINameCharNS(c)) {
                    // yycolumn_next++;
                }
                else
                if (c == '>' || c == ' ' || c == '/')
                    break element_loop;
                else
                if (c == ':') {
//                    if (parser.fNamespaces && elementURI == null) { // only the first ':' separates
                    if (elementURI == null) {
                        elementURI = stringConverter.convert(yy_buffer,
                                        yy_startRead,(yy_markedPos-yy_startRead)-1);
                        localNameOffset = (yy_markedPos-yy_startRead);
                    }
                }
                else
                if (c == '\n' || c == '\t')
                    break element_loop;
                else {
                    yy_markedPos = yy_startRead;
                    return null;
                }
            }
            c = yynextChar();
            if (c < 0)
                throw fatalError("Unexpected end of file");
            yy_markedPos--;

        }
        yy_markedPos--;

//        if (parser.fNamespaces) {
            elementLocalName = yytext2(localNameOffset,
                                yy_markedPos-(yy_startRead+localNameOffset));
//        }

        // TEMP
        if (localNameOffset == 0)
            return elementLocalName;
        else
            return yytext2();
    }


    // Build an array of booleans to tell us quickly if characters are valid "name" characters
    static private void calcAsciiTables() {
        asciiNameStartChars = new boolean[0x100];
        asciiNameStartCharsNS = new boolean[0x100];
        asciiNameChars = new boolean[0x100];
        asciiNameCharsNS = new boolean[0x100];

        for (int c=0; c < 0x100; c++) {
            asciiNameStartChars[c] =
                    ( (c>=0x61&&c<=0x7A)||(c==':')||(c>=0x41&&c<=0x5A)
                        ||(c=='_')
                        ||(c>=0xC0&&c<=0xD6)||(c>=0xD8&&c<=0xF6)
                        ||(c>=0xF8&&c<=0xFF) );

            asciiNameStartCharsNS[c] =
                    (c != ':' && asciiNameStartChars[c]);

            asciiNameChars[c] =
                    ( (c>=0x61&&c<=0x7A)||(c==':')||(c>=0x41&&c<=0x5A)
                        ||(c == '.')||(c=='-')||(c=='_')
                        ||(c == 0xB7)
                        ||(c>=0x30&&c<=0x39)||(c>=0xC0&&c<=0xD6)
                        ||(c>=0xD8&&c<=0xF6)||(c>=0xF8&&c<=0xFF) );

            asciiNameCharsNS[c] =
                    (c != ':' && asciiNameChars[c]);
        }
    }

    // Is this a valid name start character when not in namespace mode
    static private boolean isASCIINameStartChar(int c) {
        return ( c <= 0xFF && asciiNameStartChars[c]);
    }

    // Same but excludes the colon
    static private boolean isASCIINameStartCharNS(int c) {
        return ( c <= 0xFF && asciiNameStartCharsNS[c]);
    }


    // Is this a valid name character when not in namespace mode
    static private boolean isASCIINameChar(int c) {
        return ( c <= 0xFF && asciiNameChars[c]);
    }

    // Same but excludes the colon
    static private boolean isASCIINameCharNS(int c) {
        return ( c <= 0xFF && asciiNameCharsNS[c]);
    }



    /* Parses what may be whitespace.
     * Returns the token Piccolo.CDATA or Piccolo.WHITESPACE
     */
    private int parseWhitespace() throws SAXException, IOException {

        cdataBuffer = yy_buffer;
        cdataStart = yy_startRead;
        while ((yy_endRead-yy_markedPos) > 0) {

            int c = yy_buffer[yy_markedPos++];

            switch (c) {
                case ' ':
                case '\t':
                    //yycolumn_next++;
                    break;

                case '<':
                    tokenStartLine = yyline_next + 1;
                    // Report the CDATA and begin the tag
                    //yycolumn_next++;
                    yybegin(tagStartState);
                    cdataLength = (yy_markedPos-1) - yy_startRead;
                    yybegin(tagStartState);
                    return Piccolo.WHITESPACE;

                case '\n':
                    yyline_next++;
                    //yycolumn_next = 0;
                    break;

                case '&':
                    // An entity is not whitespace. Report as
                    // CDATA and go parse the entity reference.
                    //yycolumn_next++;
                    yybegin(ENTITYREF);
                    cdataLength = (yy_markedPos-1) - yy_startRead;
                    return Piccolo.CDATA;

                default:
                    // Got a character. Continue parsing as CDATA
                    //yycolumn_next++;
                    parseCdata();
                    return Piccolo.CDATA;
            }
        }

        // Getting here means we hit the end of the character buffer
        cdataLength = yy_markedPos - yy_startRead;
        return Piccolo.WHITESPACE;
    }


    /* Parses some CDATA (text content) */
    private void parseCdata() throws SAXException, IOException {

        cdataBuffer = yy_buffer;
        cdataStart = yy_startRead;
        while (yy_endRead > yy_markedPos) {

            int c = yy_buffer[yy_markedPos++];

            switch (c) {
                case '<':
                    // Report the CDATA and begin the tag
                    //yycolumn_next++;
                    yybegin(tagStartState);
                    cdataLength = (yy_markedPos-1) - yy_startRead;
                    tokenStartLine = yyline_next + 1;
                    return;

                case '\n':
                    yyline_next++;
                    //yycolumn_next = 0;
                    break;

                case '&':
                    // Report the CDATA and go parse the entity reference.
                    //yycolumn_next++;
                    yybegin(ENTITYREF);
                    cdataLength = (yy_markedPos-1) - yy_startRead;
                    return;

                case ']':
                    for (int numBrackets=1; true; ) {
                        if ((yy_endRead-yy_markedPos) >= 1)
                            c = yy_buffer[yy_markedPos++];
                        else {
                            parser.reportCdata(cdataBuffer,cdataStart,yy_markedPos-yy_startRead);
                            yynextAction();
                            c = yynextChar();
                            cdataBuffer = yy_buffer;
                            cdataStart = yy_startRead;
                        }

                        if (c == ']')
                            numBrackets++;
                        else
                        if (c == '>' && numBrackets >= 2)
                            throw fatalError("Illegal ']]>' construct in character data");
                        else {
                            if (c != YYEOF) {
                                yy_markedPos--;
                            }
                            break;
                        }
                    }
                    break;

                default:
                    //yycolumn_next++;
                    break;
            }
        }

        // Getting here means we hit the end of the character buffer
        cdataLength = yy_markedPos - yy_startRead;
    }


    /* Parses a <![CDATA[...]]> section */
    private void parseCdataSection() throws SAXException, IOException {

        yynextAction();

        while (true) {
            while (yy_endRead > yy_markedPos) {
                int c = yy_buffer[yy_markedPos++];

                switch (c) {
                    case ']':
                        bracket_loop:
                        for (int numBrackets=1; true; ) {
                            if (yy_endRead > yy_markedPos)
                                c = yy_buffer[yy_markedPos++];
                            else {
                                // Report everything up to the last 2 brackets, because they could be
                                // the end marker
                                int bracketsToKeep = Math.min(2,numBrackets);
                                yy_markedPos -= bracketsToKeep;
                                parser.reportCdata(yy_buffer,yy_startRead,yy_markedPos-yy_startRead);
                                yynextAction();
                                yy_markedPos += bracketsToKeep;
                                c = yynextChar();
                            }

                            if (c == ']')
                                numBrackets++;
                            else
                            if (c == '>' && numBrackets >= 2) {
                                int len = (yy_markedPos-3)-yy_startRead;
                                if (len > 0)
                                    parser.reportCdata(yy_buffer,yy_startRead,len);
                                return;
                            }
                            else if (c == YYEOF)
                                throw fatalError("Unexpected end of file in CDATA section");
                            else {
                                // this wasn't a closing CDATA marker
                                yy_markedPos--; // rescan the last character for linefeeds
                                break bracket_loop;
                            }
                        }
                        break;

                    case '\n':
                        yyline_next++;
                        //yycolumn_next = 0;
                        break;

                    default:
                        //yycolumn_next++;
                        break;
                }
            }
            if (yynextChar() == YYEOF)
                throw fatalError("Unexpected end of file in CDATA section");
            yy_markedPos--;
        }
    }





    /************************************************************************
     * End Code used to parse XML without JFlex's help.
     ************************************************************************/




    /************************************************************************
     * Methods to handle the parsing of parsed entities
     ************************************************************************/

    /*
     * Starts parsing the given external entity. When
     * the entity is fully parsed, the ENTITY_END token
     * will be returned, and parsing of the current entity will continue.
     */

    void pushEntity (String name, Entity entity, boolean isParamEntity, boolean returnEndToken)
    throws SAXException, IOException {
        pushEntity(name,entity,isParamEntity,returnEndToken,0);
    }

    void pushEntity (String name, Entity entity, boolean isParamEntity, boolean returnEndToken, int resumeLexState)
    throws SAXException, IOException {
        try {
            if (name != null)
                parser.reportStartEntity(name);


            entity.open();

            if (entity.isInternal()) {
                char[] valueBuffer = entity.charArrayValue();
                yypushBuffer(valueBuffer, 0, valueBuffer.length);
            }
            else {
                yypushStream(entity.getReader());
            }

            entityStack.push(currentEntity);
            currentEntity = entity;
            pushEntityState(name,isParamEntity,returnEndToken,resumeLexState);

        } catch (RecursionException e) {
            throw  fatalError("Recursive reference to entity '"
                + entity.getSystemID() + "'");
        }
    }

    void pushEntity (String name, String pubID, String sysID, boolean isParamEntity, boolean returnEndToken)
    throws SAXException, IOException {
        pushEntity(name,pubID,sysID,isParamEntity,returnEndToken,0);
    }

    void pushEntity (String name, String pubID, String sysID, boolean isParamEntity,
                     boolean returnEndToken, int resumeLexState) throws SAXException, IOException {
        Entity en = entityManager.getByID(currentEntity,pubID,sysID);
        pushEntity(name,en,isParamEntity,returnEndToken,resumeLexState);
    }


    // Should we parse external entities of type entityType?
    boolean parseExternalEntities(int entityType) {
        if (currentEntity.isStandalone()) {
            return false;
        }
        switch (entityType) {
            case EntityManager.PARAMETER:
                return parser.fExternalParameterEntities;

            case EntityManager.GENERAL:
            default:
                return parser.fExternalGeneralEntities;
        }
    }


    private void pushEntityState(String entityName, boolean newIsParamEntity, boolean newReturnEndToken)
    throws SAXException {
        pushEntityState(entityName,newIsParamEntity,newReturnEndToken,0);
    }

    private void pushEntityState(String entityName,boolean newIsParamEntity, boolean newReturnEndToken, int newReturnLexState)
    throws SAXException {
        long entityState = (entityBaseDepth << 11)
                        | ( (prevEntityLexState & 0xFF) << 3)
                        | (returnEntityEndToken? 4 : 0)
                        | (isParamEntity? 2 : 0)
                        | (isEntityBeingParsed? 1 : 0);

        entityStateStack.push(entityState);
        entityBaseDepth = tagStack.size();

        entityNameStack.push(currentEntityName);
        currentEntityName = entityName;

        isParamEntity = newIsParamEntity;
        returnEntityEndToken = newReturnEndToken;
        isEntityBeingParsed = true;
        prevEntityLexState = newReturnLexState;
    }

    private void popEntityState() throws SAXException {
        if (prevEntityLexState != 0)
            yybegin(prevEntityLexState);

        long entityState = entityStateStack.pop();
        returnEntityEndToken = ((entityState & 4) == 4);
        isParamEntity = ((entityState & 2) == 2);
        isEntityBeingParsed = ((entityState & 1) == 1);
        entityBaseDepth =  (int) ((entityState >> 11) & 0xFFFF);
        prevEntityLexState = (int) ((entityState >> 3) & 0xFF);

        if (currentEntityName != null)
            parser.reportEndEntity(currentEntityName);

        currentEntityName = entityNameStack.pop();

        if (tagStack.size() > entityBaseDepth)
            setTokenize(false);
    }

    private void clearEntityState() {
        entityStateStack.clear();
        entityNameStack.clear();
        returnEntityEndToken = true;
        isParamEntity = false;
        entityBaseDepth = 0;
        isEntityBeingParsed = true;
        prevEntityLexState = 0;
        currentEntityName = null;
    }




    /* Handles an entity reference, either general or paramter.
     * Returns a token which should be passed on to Piccolo,
     * or zero if no token should be returned.
     */
    private int handleEntityRef (String name, int entityType)
    throws IOException, SAXException {
        Entity entity = entityManager.getByName(name, entityType);

        if (entity == null) {
            handleUnknownEntityRef(name,entityType);
            return 0;
        }

        boolean isParam = (entityType == EntityManager.PARAMETER);
        String entityReportedName;

        // We only report the start/end of parameter entities
        // if they're at the "top level" and not within a declaration
        if (isParam) {
            if (yystate() == DTD)
                entityReportedName = "%"+name;
            else
                entityReportedName = null;
        }
        else
            entityReportedName = name;

        if (entity.isInternal()) {
            pushEntity(entityReportedName,entity,isParam,true);
            setTokenize(true);
            return  Piccolo.INTERNAL_ENTITY_REF;
        }
        else if (name == "[dtd]" || parseExternalEntities(entityType)) {
            pushEntity(entityReportedName,entity,isParam,true);
            setTokenize(true);
            return  Piccolo.EXTERNAL_ENTITY_REF;
        }
        else {
             entityWasSkipped = true;
             parser.reportSkippedEntity(entityReportedName);
             return 0;
        }
    }


    /* Handles an entity reference within a quoted string.
     * Returns true if the entity was replaced, or false if the
     * entity was skipped.
     */
    private boolean handleLiteralEntityRef (String name, int entityType)
    throws IOException, SAXException {
        Entity entity = entityManager.getByName(name, entityType);
        boolean isParam = false;
        if (entityType == EntityManager.PARAMETER)
            isParam = true;

        if (entity == null) {
            if (! (isParam || (!currentEntity.isStandalone() && entityWasSkipped)) )
                throw fatalError("Reference to undefined entity: " + name);
            else
                return false;
        }
        else if (entity.isInternal()) {
            pushEntity(null,entity,isParam,false,prevState);
            yybegin( (isParam? DTD_TAG_VALUE_ENTITY
                             : TAG_VALUE_ENTITY) );
            return  true;
        }
        else if (!isParam) {
            throw fatalError("Referencing an external entity within an " +
                             "attribute value is illegal");
        }
        else if (parseExternalEntities(entityType)) {
            // Reference to external entity within DTD literal
            yybegin(DTD_TAG_VALUE_EXTERNAL_ENTITY);
            pushEntity(null,entity,isParam,false,prevState);
            return true;
        }
        else {
            entityWasSkipped = true;
            return  false;
        }
    }


    private void handleUnknownEntityRef(String name, int type) throws SAXException {
        boolean isParam = (type == EntityManager.PARAMETER);
        String reportedName = (isParam? "%" : "") + name;

        if (!currentEntity.isStandalone() && entityWasSkipped)
            parser.reportSkippedEntity(reportedName);
        else
            throw fatalError("Reference to undefined entity: " + reportedName);
    }




    private boolean isTopEntity() {
        return !(yymoreStreams());
    }

    /************************************************************************
     * End Methods to handle the parsing of parsed entities
     ************************************************************************/




    /************************************************************************
     * Methods used by this class for parsing, both by the JFlex-based
     * code and by parseXML().
     ************************************************************************/

    /* Parse the attribute value of a double-quoted string and add the
     * attribute.
     */
    private void parseQuotedTagValue () throws SAXException, IOException {
        if (elementDefinition == null) {
            parseCdataLiteral('\"',TAG_QSTRING_CDATA_BUFFERED);
        }
        else {
            IndexedObject o = elementDefinition.getIndexedAttribute(attributeQName);
            if (o == null) {
                attributeValueType = "CDATA";
                parseCdataLiteral('\"',TAG_QSTRING_CDATA_BUFFERED);
            }
            else {
                defaultAttributeSpecified[o.getIndex()] = true;
                int type = ((AttributeDefinition)o.getObject()).getValueType();
                if (type == AttributeDefinition.CDATA) {
                    attributeValueType = "CDATA";
                    parseCdataLiteral('\"',TAG_QSTRING_CDATA_BUFFERED);
                }
                else {
                    attributeValueType = AttributeDefinition.getValueTypeString(type);
                    yybegin(TAG_QSTRING_NORMALIZE);
                }
            }
        }
    }

    /* Same, but for a single-quoted value */
    private void parseSingleQuotedTagValue () throws SAXException, IOException {
        if (elementDefinition == null) {
            parseCdataLiteral('\'',TAG_SQSTRING_CDATA_BUFFERED);
        }
        else {
            IndexedObject o = elementDefinition.getIndexedAttribute(attributeQName);
            if (o == null) {
                attributeValueType = "CDATA";
                parseCdataLiteral('\'',TAG_SQSTRING_CDATA_BUFFERED);
            }
            else {
                defaultAttributeSpecified[o.getIndex()] = true;
                int type = ((AttributeDefinition)o.getObject()).getValueType();
                if (type == AttributeDefinition.CDATA) {
                    attributeValueType = "CDATA";
                    parseCdataLiteral('\'',TAG_SQSTRING_CDATA_BUFFERED);
                }
                else {
                    attributeValueType = AttributeDefinition.getValueTypeString(type);
                    yybegin(TAG_SQSTRING_NORMALIZE);
                }
            }
        }
    }


    /*
     * Parses a double- or single-quoted string. If we hit the end of the
     * input buffer or encounter an entity reference, put JFlex into
     * the state supplied in "bufferedState".
     */
    private void parseCdataLiteral(char closingQuote, int bufferedState)
    throws SAXException, IOException {
        // We parse this ourselves so we can translate whitespace
        // inline without copying to a buffer
        int startPos = yy_markedPos;

        while ((yy_endRead-yy_markedPos) > 0) {
            char c = yy_buffer[yy_markedPos++];

            if (c == '&') {
                //yycolumn_next++;
                clearCbuf();
                appendToCbuf(yy_buffer, startPos, (yy_markedPos-1) - startPos);
                prevState = bufferedState;
                yybegin(TAG_VALUE_ENTITYREF);
                return;
            }
            else if (c == '<') {
                throw  fatalError(
                  "Illegal '<' found in attribute value. Use '&lt;' instead.");
            }

            // Check common characters as early as possible
            else if (c > '\'') {
                //yycolumn_next++;
            }

            else if (c == closingQuote) {
                //yycolumn_next++;
                String value;
                int valueLen = (yy_markedPos-1) - startPos;

                // Cache and intern short strings and all URIs
                if (valueLen < 4 || isNamespaceDeclaration)
                    value = stringConverter.convert(yy_buffer,startPos,valueLen);
                else
                    value = new String(yy_buffer,startPos,valueLen);

                addAttribute(attributeURI,attributeLocalName,attributeQName,
                             attributeValueType, value);


                // Next character must be a space, ">" or "/"
                int n;
                if ((yy_endRead-yy_markedPos) <= 0) {
                    n = yynextChar();
                }
                else {
                    n = yy_buffer[yy_markedPos++];
                }

                switch (n) {
                    case ' ':
                    case '\t':
                        //yycolumn_next++;
                        break;

                    case '\n':
                        yyline_next++;
                        //yycolumn_next = 0;
                        break;

                    case '/':
                    case '>':
                        yy_markedPos--;
                        endOfTag = true;
                        return;

                    default:
                        throw fatalError("Whitespace missing after attribute value");
                }

                // Discard any trailing whitespace
                while ((yy_endRead-yy_markedPos) > 0) {
                    switch (yy_buffer[yy_markedPos]) {
                        case ' ':
                        case '\t':
                            yy_markedPos++;
                            //yycolumn_next++;
                            break;

                        case '\n':
                            yy_markedPos++;
                            yyline_next++;
                            //yycolumn_next = 0;
                            break;

                        default:
                            return;
                    }
                }

                return;
            }

            else if (c == '\t') {
                //yycolumn_next++;
                yy_buffer[yy_markedPos-1] = ' ';
            }
            else if (c == '\n') {
                yyline_next++;
                //yycolumn_next = 0;
                yy_buffer[yy_markedPos-1] = ' ';
            }
            else {
                //yycolumn_next++;
            }
        }

        // we hit the end of the read buffer and so need to buffer this string
        clearCbuf();
        appendToCbuf(yy_buffer, startPos, yy_markedPos - startPos);
        prevState = bufferedState;
        yybegin(bufferedState);
    }


    // Parses a character entity and appends it to the character buffer.
    // A character entity reference can produce 1 or 2 characters.
    private void parseEncodedChar(char[] buf, int off, int len, int radix)
    throws CharConversionException {
        try {
            int result=0;
            for (int i=0; i < len; i++)
                result = (result*radix) + Character.digit(buf[off+i],radix);

            if (result >= 0x110000)
                throw new IllegalCharException("Character reference to illegal XML character");


            if (result >= 0x10000) { // This is a 2-character entity
                result -= 0x10000;

                appendToCbuf((char) ((result >> 10) + 0xD800) );
                appendToCbuf((char) ((result & ((1 << 10) - 1)) + 0xDC00) );
            }
            else
            if ((result < 0x20 && result != '\t' && result != '\r' && result != '\n')
                || (result >= 0xD800 && result < 0xE000)
                || result >= 0xFFFE)
                throw new IllegalCharException(
                    "Character reference to illegal XML character");
            else
                appendToCbuf((char)result);
        }
        catch (ClassCastException e) {
            throw new CharConversionException();
        }
    }


    // Prepare an element that may have attributes
    // Call this before any attributes are read for the current element
    private void prepareComplexElement(String elementQName) {

        isNamespaceDeclaration = false;

        elementDefinition = getElement(elementQName);
        // if necessary, resize the array of attribute default specified flags
        if (elementDefinition != null) {
            numAttributesDefined = elementDefinition.getAttributeCount();
            int currentSize = defaultAttributeSpecified.length;
            if (currentSize < numAttributesDefined) {
                defaultAttributeSpecified = new boolean[Math.max(2*currentSize,numAttributesDefined)];
            }

            for (int i=0; i < numAttributesDefined; i++) {
                defaultAttributeSpecified[i] = false;
            }
        }
        else {
            attributeValueType = "CDATA";
        }
    }

    // Call this after completing the parsing of an element with attributes
    private void processComplexElement() throws SAXException, IOException {
        if (elementDefinition != null) {
            AttributeDefinition[] attributes = elementDefinition.getAttributes();
            for (int i=0; i < numAttributesDefined; i++) {
                if (!defaultAttributeSpecified[i]) {
                    AttributeDefinition ad = attributes[i];
                    String defaultValue = ad.getDefaultValue();
                    if (defaultValue != null) {
                        attribs.addAttribute(ad.getPrefix(),ad.getLocalName(),
                                             ad.getQName(),ad.getValueTypeString(),
                                             defaultValue);
                    }
                }
            }
        }
    }

    private void processNSContextEnd() throws SAXException {
        int mappings = nsSupport.getContextSize();
        for (int i=0; i < mappings; i++) {
            parser.reportEndPrefixMapping(nsSupport.getContextPrefix(i));
        }
        nsSupport.popContext();
    }

    // Add an attribute to the current element
    private void addAttribute(String prefix, String localName, String qName,
                         String type, String value)
    throws SAXException {

        // If we saw an entity within a non-CDATA value, we need to normalize
        // it again.
        if (needsNormalization) {
            value = normalizeValue(value);
            needsNormalization = false;
        }

        if (isNamespaceDeclaration && parser.fNamespaces) {
            if (parser.fNamespacePrefixes)
                attribs.addAndCheckAttribute(
                    prefix,localName,qName,type,value);

            if (prefix == "") {
                if (localName == "xmlns")
                    localName = "";
                nsSupport.declarePrefix(localName,value);
                parser.reportStartPrefixMapping(localName,value);
            }
            else if (prefix != "xml") {
                nsSupport.declarePrefix(localName,value);
                parser.reportStartPrefixMapping(localName,value);
            }
        }
        else
            attribs.addAndCheckAttribute(
                prefix,localName,qName,type,value);
    }



    // Call this after parsing an element with no attributes
    private void processSimpleElement(String elementQName) throws SAXException, IOException {
        elementDefinition = getElement(elementQName);

        if (elementDefinition != null) {
            AttributeDefinition[] defaults = elementDefinition.getAttributes();
            int numDefaults = elementDefinition.getAttributeCount();
            for (int i=0; i < numDefaults; i++) {
                AttributeDefinition ad = defaults[i];
                String defaultValue = ad.getDefaultValue();

                if (defaultValue != null) {
                    attribs.addAttribute(ad.getPrefix(),ad.getLocalName(),
                                         ad.getQName(),ad.getValueTypeString(),
                                         defaultValue);
                }
            }
        }
    }


    String rescanAttributeValue(String defaultValue) throws SAXException, IOException {
        clearCbuf();
        char[] valbuf = defaultValue.toCharArray();
        yypushBuffer(valbuf,0,valbuf.length);
        pushEntityState(null,false,true,yystate());
        yybegin(TAG_VALUE_ENTITY);
        isEntityBeingParsed = false;
        if (yylex() != Piccolo.ENTITY_END)
            throw fatalError("Unexpected element while parsing attribute default value");
        isEntityBeingParsed = true;

        // We need to internalize values for namespace declarations. Not much
        // harm in just internalizing all attribute defaults.
        return stringConverter.convert(cbuf,0,cbuflen);
    }


    // Resolves the element and attribute prefixes for the element we just parsed
    // into URIs
    private void resolveNamespacePrefixes() {
        elementURI = nsSupport.getURI(elementURI);
        int numAttributes = attribs.getLength();
        for (int i=0; i < numAttributes; i++) {
            String prefix = attribs.getURI(i);
            if (prefix != "") {
                String uri = nsSupport.getURI(prefix);
                if (uri != "")
                    attribs.setURI(i,uri);
            }

        }
    }

    // Ensures that the end tag we just parsed properly closes a start tag.
    // If we've just hit the top-level end tag, turn tokenization back on
    // so we return a token to Piccolo.
    private void checkEndTag(String endQName) throws SAXException {
        String properEnd = tagStack.pop();
        if (tagStack.size() == entityBaseDepth) {
            setTokenize(true);
        }

        if (properEnd != endQName)
            throw fatalError("</"+endQName+"> does not close tag <"+properEnd+">.");
    }


    /************************************************************************
     * End Methods used by this class for parsing.
     ************************************************************************/







    /************************************************************************
     * Miscellaneous methods used internally to this class
     ************************************************************************/


    // Like JFlex's yytext(), but the String returned is internalized.
    private String yytext2 () {
        return  stringConverter.convert(yy_buffer, yy_startRead, yy_markedPos
                - yy_startRead);
    }


    // Like yytext(int start, int length), but the String returned is internalized
    private String yytext2 (int start, int length) {
        return  stringConverter.convert(yy_buffer, yy_startRead + start, length);
    }



    // Throws a fatal SAXException
    private FatalParsingException fatalError (String msg) {
        return new FatalParsingException(msg);
    }

    // Same but with an embedded exception
    private FatalParsingException fatalError (String msg, Exception e) {
        return new FatalParsingException(msg,e);
    }

    // backup one character mentaining the corect line number
    private void safeBacktrack()
    {
        if (yy_buffer[--yy_markedPos] == '\n')
            yyline_next--;
        // todo: have to reset yycolumn_next to previous line's value as well?
    }

    /************************************************************************
     * End Miscellaneous methods
     ************************************************************************/



  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param   in  the java.io.Reader to read input from.
   */
  PiccoloLexer(java.io.Reader in) {
    this.yy_reader = in;
  }

  /**
   * Creates a new scanner.
   * There is also java.io.Reader version of this constructor.
   *
   * @param   in  the java.io.Inputstream to read input from.
   */
  PiccoloLexer(java.io.InputStream in) {
    this(new java.io.InputStreamReader(in));
  }

  /** 
   * Unpacks the split, compressed DFA transition table.
   *
   * @return the unpacked transition table
   */
  private static int [] yy_unpack() {
    int [] trans = new int[21172];
    int offset = 0;
    offset = yy_unpack(yy_packed0, offset, trans);
    return trans;
  }

  /** 
   * Unpacks the compressed DFA transition table.
   *
   * @param packed   the packed transition table
   * @return         the index of the last entry
   */
  private static int yy_unpack(String packed, int offset, int [] trans) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do trans[j++] = value; while (--count > 0);
    }
    return j;
  }

  /** 
   * Unpacks the compressed character translation table.
   *
   * @param packed   the packed character translation table
   * @return         the unpacked character translation table
   */
  private static char [] yy_unpack_cmap(String packed) {
    char [] map = new char[0x10000];
    int i = 0;  /* index in packed string  */
    int j = 0;  /* index in unpacked array */
    while (i < 1350) {
      int  count = packed.charAt(i++);
      char value = packed.charAt(i++);
      do map[j++] = value; while (--count > 0);
    }
    return map;
  }


  /**
   * Refills the input buffer.
   *
   * @return      <code>false</code>, iff there was new input.
   *
   * @exception   IOException  if any I/O-Error occurs
   */
  private boolean yy_refill() throws java.io.IOException {

    /* first: make room (if you can) */
    int save_at = yy_savePos < 0 ? yy_startRead : yy_savePos;
    if (save_at > 0) {
      System.arraycopy(yy_buffer, save_at,
                       yy_buffer, 0,
                       yy_endRead-save_at);

      /* translate stored positions */
      yy_endRead-= save_at;
      yy_currentPos-= save_at;
      yy_markedPos-= save_at;
      yy_pushbackPos-= save_at;
      yy_startRead -= save_at;
      if (yy_savePos >= 0)
          yy_savePos = 0;
    }

    /* is the buffer big enough? */
    if (yy_markedPos >= yy_buffer.length || yy_currentPos >= yy_buffer.length) {
      /* if not: blow it up */
      char newBuffer[] = new char[yy_buffer.length*2];
      System.arraycopy(yy_buffer, 0, newBuffer, 0, yy_buffer.length);
      yy_buffer = newBuffer;

      // Always save the largest buffer for future parsing
      if (yy_buffer.length > yy_saved_buffer.length) {
        yy_saved_buffer = yy_buffer;
      }
    }

    /* finally: fill the buffer with new input */
    int numRead = yy_reader.read(yy_buffer, yy_endRead,
                                            yy_buffer.length-yy_endRead);

    if (numRead < 0) {
      return true;
    }
    else {
      yy_endRead+= numRead;
      return false;
    }
  }


  /**
   * Closes the input stream.
   */
  final public void yyclose() throws java.io.IOException {
    yy_atEOF = true;            /* indicate end of file */
    yy_endRead = yy_startRead;  /* invalidate buffer    */

    if (yy_reader != null)
      yy_reader.close();
  }


  /**
   * Stores the current input stream on a stack, and
   * reads from a new stream. Lexical state, line,
   * char, and column counting remain untouched.
   *
   * The current input stream can be restored with
   * yypopstream (usually in an <<EOF>> action).
   *
   * @param reader the new input stream to read from
   *
   * @see #yypopStream()
   */
  final public void yypushStream(java.io.Reader reader) {
    yy_streams.push(
      new YY_StreamInfo(yy_reader, yy_endRead, yy_startRead, yy_savePos, yy_currentPos,
                        yy_markedPos, yy_pushbackPos, yy_buffer, yy_atEOF,
                        yyline_next, yycolumn_next)
    );
    yy_atEOF  = false;
    yy_buffer = new char[YY_BUFFERSIZE];
    yy_reader = reader;
    yy_endRead = yy_startRead = 0;
    yy_savePos = -1;
    yy_currentPos = yy_markedPos = yy_pushbackPos = 0;
    yyline = yycolumn = yyline_next = yycolumn_next = 0;

   // Yuval Oren 2002-01-09 added to correct the case in which you pushStream() and don't "return"
   yy_endRead_l = yy_endRead;
   yy_buffer_l = yy_buffer;
  }


  final public void yypushBuffer(char[] buffer, int off, int len) {
    yy_streams.push(
      new YY_StreamInfo(yy_reader, yy_endRead, yy_startRead, yy_savePos, yy_currentPos,
                        yy_markedPos, yy_pushbackPos, yy_buffer, yy_atEOF,
                        yyline, yycolumn)
    );
    yy_atEOF  = true;
    yy_buffer = buffer;
    yy_reader = null;
    yy_startRead = yy_markedPos = yy_currentPos = yy_pushbackPos = off;
    yy_savePos = -1;
    yy_endRead = yy_startRead + len;
    yyline = yycolumn = yyline_next = yycolumn_next = 0;

    // Yuval added
    yy_endRead_l = yy_endRead;
    yy_buffer_l = yy_buffer;
  }





  /**
   * Closes the current input stream and continues to
   * read from the one on top of the stream stack.
   *
   * @throws java.util.EmptyStackException
   *         if there is no further stream to read from.
   *
   * @throws java.io.IOException
   *         if there was an error in closing the stream.
   *
   * @see #yypushStream(java.io.Reader)
   */
  final public void yypopStream() throws java.io.IOException {
    if (yy_reader != null)
      yy_reader.close();
    YY_StreamInfo s = (YY_StreamInfo) yy_streams.pop();
    yy_buffer      = s.yy_buffer;
    yy_reader      = s.yy_reader;
    yy_endRead     = s.yy_endRead;
    yy_startRead   = s.yy_startRead;
    yy_savePos     = s.yy_savePos;
    yy_currentPos  = s.yy_currentPos;
    yy_markedPos   = s.yy_markedPos ;
    yy_pushbackPos = s.yy_pushbackPos;
    yy_atEOF       = s.yy_atEOF;
    yyline         = s.yyline;
    yycolumn       = s.yycolumn;
    yyline_next = yyline;
    yycolumn_next = yycolumn;

    // Yuval added
    yy_endRead_l = yy_endRead;
    yy_buffer_l = yy_buffer;
    yycmap_l = yycmap;


  }


  /**
   * Returns true iff there are still streams left
   * to read from on the stream stack.
   */
  final public boolean yymoreStreams() {
    return !yy_streams.isEmpty();
  }


  /**
   * Closes the current stream, and resets the
   * scanner to read from a new input stream.
   *
   * All internal variables are reset, the old input stream
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>YY_INITIAL</tt>.
   *
   * @param reader   the new input stream
   *
   * @see #yypushStream(java.io.Reader)
   * @see #yypopStream()
   */
  final public void yyreset(java.io.Reader reader) throws java.io.IOException {
    yyclose();

    yy_buffer = yy_saved_buffer;

    yy_reader = reader;
    yy_atBOL  = true;
    yy_atEOF  = false;
    yy_endRead = yy_startRead = 0;
    yy_savePos = -1;
    yy_currentPos = yy_markedPos = yy_pushbackPos = 0;

    yyline = yychar = yycolumn = 0;
    yy_state = yy_lexical_state = YYINITIAL;
    yy_sawCR = false;
    yyline_next = yycolumn_next = 0;

    yy_streams.clear();
  }


  final public void yyreset(char[] buffer, int off, int len) throws java.io.IOException {
    yyclose();
    yy_buffer = buffer;
    yy_reader = null;
    yy_atBOL  = true;
    yy_atEOF  = true;
    yy_currentPos = yy_markedPos = yy_pushbackPos = yy_startRead = off;

    yy_savePos = -1;
    yy_endRead = off + len;
    yyline = yychar = yycolumn = 0;
    yy_state = yy_lexical_state = YYINITIAL;
    yy_sawCR = false;
    yyline_next = yycolumn_next = 0;

    yy_endRead_l = yy_endRead;
    yy_buffer_l = yy_buffer;

    yy_streams.clear();
  }


  /**
   * Returns the current lexical state.
   */
  final public int yystate() {
    return yy_lexical_state;
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  final public void yybegin(int newState) {
    yy_lexical_state = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  final public String yytext() {
    return new String( yy_buffer, yy_startRead, yy_markedPos-yy_startRead );
  }

  /**
   * Returns the text matched by the current regular expression.
   *
   * @param start starting offset from the beginning of the current expression.
   * @param length number of characters to include in the string.
   */
  final public String yytext(int offset, int length) {
    return new String(yy_buffer,yy_startRead+offset,length);
  }


  /**
   * Accept the current action as completed and update line, column and
   * character counters accordingly. Used in conjunction with
   * yynextChar().
   *
   * @see #yynextChar()
   */
  final public void yynextAction() {
    yyline = yyline_next;
    yycolumn = yycolumn_next;
    // Uncomment for %char directive: yychar += (yy_markedPos - yy_startRead);
    yy_currentPos = yy_startRead = yy_markedPos;
  }


  /**
   * Extends the matched text by one character and returns it.
   *
   * @returns the next character, or YYEOF
   */
  final public int yynextChar() throws IOException {
    if (yy_markedPos < yy_endRead)
        return yy_buffer[yy_markedPos++];
    else if (yy_atEOF) {
        return YYEOF;
    }
    else {
        boolean eof  = yy_refill();
        yy_buffer_l  = yy_buffer;
        yy_endRead_l = yy_endRead;
        if (eof)
            return YYEOF;
        else
            return yy_buffer[yy_markedPos++];
    }
  }


  /**
   * Extends the matched text by one character and returns it.
   * Similar to yynextChar(), but the caller guarantees [by using
   * yybufferLeft()] that there is at least one more character in the
   * buffer.
   *
   *
   * @returns the next character, or YYEOF
   */
  final public int yynextBufferChar() {
    return yy_buffer[yy_markedPos++];
  }

  /**
   * Counts the character for line and column counting.
   */
  final public void yycountChar(int yy_input) {
        switch (yy_input) {
/* Piccolo eliminates all CR's before they get to JFlex
            case '\r':
                yyline_next++;
                yycolumn_next = 0;
                yy_sawCR = true;
                break;
 */
            case '\n':
//                if (yy_sawCR)
//                    yy_sawCR = false;
//                else {
                    yyline_next++;
//                    yycolumn_next = 0;
//                }
                break;

            default:
//                yy_sawCR = false;
//                yycolumn_next++;
                break;
        }
  }


  /**
   * Returns the character at position <tt>pos</tt> from the
   * matched text.
   *
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch.
   *            A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
  final public char yycharat(int pos) {
    return yy_buffer[yy_startRead+pos];
  }

  /**
   * Returns the number of characters remaining in the buffer,
   * not including the matched text, before more
   * characters must be read from the input Reader.
   *
   */
  final public int yybufferLeft() {
    return yy_endRead - yy_markedPos;
  }

  /**
   * Skips past the specified number of characters.
   * These characters will be included in line, column, and character
   * counting, but they will not be used for matching.
   *
   * @param n the number of characters to skip
   */
   final public void yyskip(int n) {
     yy_markedPos += n;
     yy_markedPos_l = yy_markedPos;
     if (yy_markedPos > yy_endRead)
       yy_ScanError(YY_SKIP_2BIG);
   }


  /**
   * Returns the length of the matched text region.
   */
  final public int yylength() {
    return yy_markedPos-yy_startRead;
  }


  /**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of
   * yypushback(int) and a match-all fallback rule) this method
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
  private void yy_ScanError(int errorCode) {
    String message;
    try {
      message = YY_ERROR_MSG[errorCode];
    }
    catch (ArrayIndexOutOfBoundsException e) {
      message = YY_ERROR_MSG[YY_UNKNOWN_ERROR];
    }

    throw new Error(message);
  }


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *                This number must not be greater than yylength()!
   */
  private void yypushback(int number)  {
    if ( number > yylength() )
      yy_ScanError(YY_PUSHBACK_2BIG);

    yy_markedPos -= number;

    // Recount the lines and columns
    yyline_next = yyline;
    yycolumn_next = yycolumn;
    yy_sawCR = yy_prev_sawCR;
    for (int pos=yy_startRead; pos < yy_markedPos; pos++)
        yycountChar(yy_buffer[pos]);
  }


  /**
   * Contains user EOF-code, which will be executed exactly once,
   * when the end of file is reached
   */
  private void yy_do_eof() throws java.io.IOException {
    if (!yy_eof_done) {
      yy_eof_done = true;
      yyclose();
    }
  }



    // Yuval moved cached fields to class level so yypushStream() can set them.
    private int yy_currentPos_l;
    private int yy_startRead_l;
    private int yy_markedPos_l;
    private int yy_endRead_l;
    private char [] yy_buffer_l;
    private char [] yycmap_l;

    // Line and column counting variables.
    private boolean yy_sawCR = false; // Was the last character a CR?
    private boolean yy_prev_sawCR = false; // value of yy_sawCR before this action was parsed
    private int yyline_next = 0; // What yyline should be after matched text
    private int yycolumn_next = 0; // What yycolumn should be after matched text

  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   IOException  if any I/O-Error occurs
   */

  public int yylex() throws java.io.IOException,   org.xml.sax.SAXException,
  FatalParsingException
 {
    int yy_input;
    int yy_action;

    // Set cached fields:
    yy_endRead_l = yy_endRead;
    yy_buffer_l = yy_buffer;
    yycmap_l = yycmap;


    int [] yytrans_l = yytrans;
    int [] yy_rowMap_l = yy_rowMap;
    byte [] yy_attr_l = YY_ATTRIBUTE;
    int yy_pushbackPos_l = yy_pushbackPos = -1;
    boolean yy_was_pushback;
    int yyline_next_l,yycolumn_next_l;

    while (true) {
      yy_markedPos_l = yy_markedPos;

      // Add the lines and columns found in the last matching text
      yyline = yyline_next_l = yyline_next;
//      yycolumn = yycolumn_next_l = yycolumn_next;
//      yy_prev_sawCR = yy_sawCR;


      yy_action = -1;

      yy_startRead_l = yy_currentPos_l = yy_currentPos =
                       yy_startRead = yy_markedPos_l;

      yy_state = yy_lexical_state;

      yy_was_pushback = false;

      yy_forAction: {
        while (true) {

          if (yy_currentPos_l < yy_endRead_l)
            yy_input = yy_buffer_l[yy_currentPos_l++];
          else if (yy_atEOF) {
            yy_input = YYEOF;
            break yy_forAction;
          }
          else {
            // store back cached positions
            yy_currentPos  = yy_currentPos_l;
            yy_markedPos   = yy_markedPos_l;
            yy_pushbackPos = yy_pushbackPos_l;
            boolean eof = yy_refill();
            // get translated positions and possibly new buffer
            yy_currentPos_l  = yy_currentPos;
            yy_markedPos_l   = yy_markedPos;
            yy_buffer_l      = yy_buffer;
            yy_endRead_l     = yy_endRead;
            yy_pushbackPos_l = yy_pushbackPos;
            if (eof) {
              yy_input = YYEOF;
              break yy_forAction;
            }
            else {
              yy_input = yy_buffer_l[yy_currentPos_l++];
            }
          }
            switch (yy_input) {
/*
                case '\r':
                    yyline_next_l++;
                    yycolumn_next_l = 0;
                    yy_sawCR = true;
                    break;
*/
                case '\n':
//                    if (yy_sawCR)
//                          yy_sawCR = false;
//                    else {
                        yyline_next_l++;
//                        yycolumn_next_l = 0;
//                    }
                    break;

                default:
//                    yy_sawCR = false;
//                    yycolumn_next_l++;
                    break;
            }

          int yy_next = yytrans_l[ yy_rowMap_l[yy_state] + yycmap_l[yy_input] ];
          if (yy_next == -1) break yy_forAction;
          yy_state = yy_next;

          int yy_attributes = yy_attr_l[yy_state];
          if ( (yy_attributes & 2) == 2 )
            yy_pushbackPos_l = yy_currentPos_l;

          if ( (yy_attributes & 1) == 1 ) {
            yy_was_pushback = (yy_attributes & 4) == 4;
            yy_action = yy_state;
            yy_markedPos_l = yy_currentPos_l;
            yyline_next = yyline_next_l;
//            yycolumn_next = yycolumn_next_l;


            if ( (yy_attributes & 8) == 8 ) break yy_forAction;
          }

        }
      }

      // store back cached position
      yy_markedPos = yy_markedPos_l;

      if (yy_was_pushback)
        yy_markedPos = yy_pushbackPos_l;

      switch (yy_action) {

        case 322: 
          {  appendToCbuf('&'); yybegin(prevState);  }
        case 434: break;
        case 422: 
          {  yybegin(DTD_TAG); return Piccolo.NMTOKENS;  }
        case 435: break;
        case 421: 
          {  yybegin(DTD_TAG); return Piccolo.ENTITIES;  }
        case 436: break;
        case 416: 
          {  yybegin(DTD_ENTITY_DECL); return Piccolo.ENTITY_DECL_START;  }
        case 437: break;
        case 408: 
          {  yybegin(DTD_TAG); return Piccolo.NMTOKEN;  }
        case 438: break;
        case 388: 
          {  yybegin(DTD_TAG); return Piccolo.IDREFS;  }
        case 439: break;
        case 385: 
          {  yybegin(DTD_TAG); return Piccolo.ENTITY;  }
        case 440: break;
        case 122: 
          {  yybegin(DTD_TAG); return Piccolo.RPAREN;  }
        case 441: break;
        case 106: 
          {  yybegin(DTD_TAG_START); bypassPERefs=bypassGERefs=false;  }
        case 442: break;
        case 348: 
          {  yybegin(baseState); parser.reportCdata('"');  }
        case 443: break;
        case 347: 
          {  yybegin(baseState); parser.reportCdata('\'');  }
        case 444: break;
        case 311: 
          {  yybegin(baseState); parser.reportCdata('&');  }
        case 445: break;
        case 263: 
          {  yybegin(baseState); parser.reportCdata('>');  }
        case 446: break;
        case 257: 
          {  yybegin(baseState); parser.reportCdata('<');  }
        case 447: break;
        case 222: 
          {  yybegin(DTD_TAG); return Piccolo.ID;  }
        case 448: break;
        case 113: 
          {  yybegin(DTD); return Piccolo.TAG_END;  }
        case 449: break;
        case 425: 
          {  return Piccolo.IMPLIED;  }
        case 450: break;
        case 414: 
          {  return Piccolo.PCDATA;  }
        case 451: break;
        case 411: 
          {  return Piccolo.INCLUDE;  }
        case 452: break;
        case 391: 
          {  return Piccolo.IGNORE;  }
        case 453: break;
        case 224: 
          {  return Piccolo.PERCENT;  }
        case 454: break;
        case 139: 
          {  return Piccolo.LPAREN;  }
        case 455: break;
        case 142: 
          {  return Piccolo.RPAREN;  }
        case 456: break;
        case 5: 
        case 54: 
          {  yybegin(PI);  }
        case 457: break;
        case 138: 
          {  yybegin(DTD); return Piccolo.LBRACKET;  }
        case 458: break;
        case 431: 
          {  return Piccolo.REQUIRED;  }
        case 459: break;
        case 424: 
          {  return Piccolo.NOTATION;  }
        case 460: break;
        case 423: 
          {  return Piccolo.NOTATION;  }
        case 461: break;
        case 132: 
          {  return Piccolo.QUESTION;  }
        case 462: break;
        case 427: 
          {  yybegin(DTD_TAG); return Piccolo.ELEMENT_DECL_START;  }
        case 463: break;
        case 393: 
          {  bypassPERefs = bypassGERefs = true; yybegin(DTD_PUBLIC_ID); return Piccolo.PUBLIC;  }
        case 464: break;
        case 39: 
          { 
        int token = parseWhitespace();
        if (token == Piccolo.CDATA) {
            parser.reportCdata();
        }

        return token;
     }
        case 465: break;
        case 119: 
          {  yybegin(DTD_TAG); return stringToken(Piccolo.NAME,yytext2());  }
        case 466: break;
        case 153: 
          { 
        appendToCbuf(yy_buffer,yy_startRead,yy_markedPos-yy_startRead);
        yybegin(DTD_TAG_VALUE_ENTITY);
     }
        case 467: break;
        case 361: 
          {  yybegin(DTD_TAG); return Piccolo.CDATA;  }
        case 468: break;
        case 360: 
          {  yybegin(DTD_TAG); return Piccolo.IDREF;  }
        case 469: break;
        case 196: 
          {  yybegin(tagState); parseSingleQuotedTagValue();  }
        case 470: break;
        case 396: 
          {  return Piccolo.FIXED;  }
        case 471: break;
        case 364: 
          {  return Piccolo.NDATA;  }
        case 472: break;
        case 362: 
          {  return Piccolo.EMPTY;  }
        case 473: break;
        case 296: 
          {  return Piccolo.ANY;  }
        case 474: break;
        case 206: 
          { 
      yybegin(tagState);
      String value;

      // Cache and internalize short strings and all URIs
      if (cbuflen < 4 || attributeQName == "xmlns")
        value = stringConverter.convert(cbuf,0,cbuflen);
      else
        value = new String(cbuf,0,cbuflen);

      addAttribute(attributeURI,attributeLocalName,attributeQName,
                   attributeValueType, value);
 }
        case 475: break;
        case 121: 
          {  return stringToken(Piccolo.NAME,yytext2());  }
        case 476: break;
        case 123: 
          {  return Piccolo.PIPE;  }
        case 477: break;
        case 133: 
        case 134: 
        case 135: 
        case 136: 
        case 137: 
        case 140: 
        case 232: 
        case 233: 
        case 234: 
        case 235: 
        case 236: 
        case 237: 
        case 238: 
        case 239: 
        case 291: 
        case 292: 
        case 293: 
        case 294: 
        case 295: 
        case 297: 
        case 298: 
        case 330: 
        case 331: 
        case 332: 
        case 333: 
        case 334: 
        case 335: 
        case 336: 
        case 363: 
        case 365: 
        case 366: 
        case 367: 
        case 368: 
        case 389: 
        case 390: 
        case 410: 
          {  return stringToken(Piccolo.NAME,yytext2());  }
        case 478: break;
        case 143: 
          {  return Piccolo.STAR;  }
        case 479: break;
        case 144: 
          {  return Piccolo.PLUS;  }
        case 480: break;
        case 145: 
          {  return Piccolo.COMMA;  }
        case 481: break;
        case 96: 
        case 100: 
          {  appendToCbuf(' ');  }
        case 482: break;
        case 404: 
          { 
        attributeURI = "xmlns";
        attributeLocalName = yytext2(6,yylength()-6);
        attributeQName = yytext2();
        isNamespaceDeclaration = true;
        yybegin(TAG_VALUE);
     }
        case 483: break;
        case 283: 
          { 
        yybegin(DTD_ATT_TYPE);
        return stringToken(Piccolo.PREFIXED_NAME,yytext2());
     }
        case 484: break;
        case 282: 
          { 
        if (isTopEntity())
            throw fatalError("Parameter entities may not appear in the internal subset");

        if (handleEntityRef(yytext2(1,yylength()-2),EntityManager.PARAMETER) != 0)
            returnEntityEndToken = false;
        return Piccolo.WHITESPACE;
     }
        case 485: break;
        case 195: 
          {  yybegin(tagState); parseQuotedTagValue();  }
        case 486: break;
        case 13: 
        case 14: 
        case 17: 
        case 18: 
        case 83: 
        case 87: 
        case 95: 
        case 99: 
          { 
    appendToCbuf(yy_buffer,yy_startRead,yy_markedPos-yy_startRead);
 }
        case 487: break;
        case 11: 
        case 74: 
          { 
        appendToCbuf(yy_buffer,yy_startRead,yy_markedPos-yy_startRead);
     }
        case 488: break;
        case 33: 
        case 154: 
        case 155: 
          {  yybegin(DTD_TAG_VALUE_ENTITY);  }
        case 489: break;
        case 111: 
        case 112: 
        case 218: 
          { 
        yybegin(DTD_ATT_TYPE);
        return stringToken(Piccolo.UNPREFIXED_NAME,yytext2());
     }
        case 490: break;
        case 179: 
          { 
        yybegin(baseState);
        processComplexElement();
        parser.reportStartTag("","",stringValue);
        parser.reportEndTag("","",stringValue);
        attribs.clear();
        if (tokenizeInput)
            return Piccolo.EMPTY_TAG;
     }
        case 491: break;
        case 186: 
          { 
        yybegin(CLOSE_TAG);
        stringValue = yytext2(1,yylength()-1);
     }
        case 492: break;
        case 38: 
          { 
        safeBacktrack();
        parseCdata();
        parser.reportCdata();

        return Piccolo.CDATA;
     }
        case 493: break;
        case 97: 
          { 
    needsNormalization = true;

    // prevState is already set from the <TAG>"\"" or <TAG>"\'" rule
    yybegin(TAG_VALUE_ENTITYREF);
 }
        case 494: break;
        case 85: 
          { 
    // prevState is already set from the <TAG>"\"" or <TAG>"\'" rule
    yybegin(TAG_VALUE_ENTITYREF);
 }
        case 495: break;
        case 75: 
          { 
        appendToCbuf(' ');
     }
        case 496: break;
        case 21: 
        case 22: 
        case 23: 
        case 24: 
        case 25: 
        case 26: 
        case 29: 
        case 30: 
        case 105: 
        case 131: 
          { 
    return Piccolo.WHITESPACE;
 }
        case 497: break;
        case 350: 
          { 
    throw fatalError("'?xml' is a reserved processing instruction target and must be in lower case.");
 }
        case 498: break;
        case 92: 
          { 
        clearCbuf();
        prevState = TAG_SQSTRING_NORMALIZE_BUFFERED;
        yybegin(prevState);
        appendToCbuf(yy_buffer,yy_startRead,yy_markedPos-yy_startRead);
     }
        case 499: break;
        case 88: 
          { 
        clearCbuf();
        prevState = TAG_QSTRING_NORMALIZE_BUFFERED;
        yybegin(prevState);
        appendToCbuf(yy_buffer,yy_startRead,yy_markedPos-yy_startRead);
     }
        case 500: break;
        case 146: 
          { 
        prevState = DTD_TAG_QSTRING_BUFFERED;
        clearCbuf();
        appendToCbuf(yy_buffer,yy_startRead+1,yylength()-1);
        yybegin(prevState);
     }
        case 501: break;
        case 159: 
          { 
        yybegin(DTD_TAG);
        return stringToken(Piccolo.STRING,new String(cbuf,0,cbuflen));
     }
        case 502: break;
        case 281: 
          {  return Piccolo.DOUBLE_RBRACKET_END;  }
        case 503: break;
        case 152: 
          {  yybegin(DTD_TAG_VALUE_PARAM_ENTITYREF);  }
        case 504: break;
        case 378: 
          { 
        yybegin(baseState);
        parser.reportComment(yy_buffer,yy_startRead+3,(yy_markedPos-yy_startRead)-6);
        if (tokenizeInput)
            return Piccolo.COMMENT;
     }
        case 505: break;
        case 349: 
          { 
    prevState = baseState;
    yybegin(XML_TAG);
 }
        case 506: break;
        case 58: 
          { 
        yybegin(baseState);
        tagStack.push(stringValue);
        processComplexElement();
        parser.reportStartTag(elementURI,elementLocalName,stringValue);
        attribs.clear();
        if (tokenizeInput) {
            setTokenize(false);
            return Piccolo.OPEN_TAG;
        }
     }
        case 507: break;
        case 32: 
        case 150: 
          {  appendToCbuf(yy_buffer,yy_startRead,yy_markedPos-yy_startRead);  }
        case 508: break;
        case 147: 
          { 
        prevState = DTD_TAG_SQSTRING_BUFFERED;
        clearCbuf();
        appendToCbuf(yy_buffer,yy_startRead+1,yylength()-1);
        yybegin(prevState);
     }
        case 509: break;
        case 177: 
          { 
    yybegin(piPrevState);
    parser.reportPI(elementQName,yytext(0,yylength()-2));
    if (tokenizeInput) {
        return Piccolo.PI;
    }
 }
        case 510: break;
        case 189: 
          { 
        yybegin(baseState);
        processComplexElement();
        resolveNamespacePrefixes();
        parser.reportStartTag(elementURI,elementLocalName,stringValue);
        parser.reportEndTag(elementURI,elementLocalName,stringValue);
        processNSContextEnd();
        attribs.clear();
        if (tokenizeInput)
            return Piccolo.EMPTY_TAG;
     }
        case 511: break;
        case 310: 
          { 
        yybegin(baseState);
        try {
            clearCbuf();
            parseEncodedChar(yy_buffer,yy_startRead+2,yylength()-3,16);
            parser.reportCdata(cbuf,0,cbuflen);
        }
        catch (IllegalCharException e) {
            throw fatalError("Invalid character entity reference: &"+yytext());
        }
     }
        case 512: break;
        case 258: 
          { 
        yybegin(baseState);
        try {
            clearCbuf();
            parseEncodedChar(yy_buffer,yy_startRead+1,yylength()-2,10);
            parser.reportCdata(cbuf,0,cbuflen);
        }
        catch (IllegalCharException e) {
            throw fatalError("Invalid character entity reference: &"+yytext());
        }
     }
        case 513: break;
        case 42: 
        case 43: 
        case 45: 
        case 46: 
        case 47: 
        case 48: 
        case 49: 
        case 50: 
        case 51: 
        case 52: 
        case 53: 
        case 55: 
        case 59: 
        case 61: 
        case 62: 
        case 63: 
        case 68: 
        case 71: 
        case 72: 
        case 73: 
        case 77: 
        case 78: 
        case 79: 
        case 80: 
        case 81: 
        case 82: 
        case 86: 
        case 91: 
        case 98: 
        case 101: 
        case 103: 
        case 107: 
        case 108: 
        case 110: 
        case 114: 
        case 115: 
        case 116: 
        case 117: 
        case 120: 
        case 124: 
        case 125: 
        case 129: 
        case 130: 
        case 141: 
        case 148: 
        case 149: 
        case 161: 
        case 162: 
          { 
    throw fatalError("Unexpected character encountered (lex state " + yystate() + "): '" + yytext() + "'");
 }
        case 514: break;
        case 252: 
          { 
        yybegin(DTD_TAG);
        if (isTopEntity())
            throw fatalError("'<![' constructs are not allowed in the internal DTD subset");

        return Piccolo.CONDITIONAL_START;
     }
        case 515: break;
        case 208: 
          { 
    yybegin(tagState);
    addAttribute(attributeURI,attributeLocalName,
                 attributeQName,attributeValueType,"");
 }
        case 516: break;
        case 104: 
          { 
    yybegin(baseState);
    checkEndTag(stringValue);
    parser.reportEndTag(elementURI,elementLocalName,stringValue);
    processNSContextEnd();
    if (tokenizeInput)
        return Piccolo.CLOSE_TAG;
 }
        case 517: break;
        case 165: 
          { 
    if (currentEntity.isInternal())
        throw fatalError("XML declarations are not allowed in internal entities");

    yybegin(prevState);

    if (currentEntity.getXMLVersion() != null) {
        if (currentEntity.getDeclaredEncoding() == null)
            return Piccolo.XML_DOC_DECL;
        else
        if (currentEntity.isStandaloneDeclared())
            return Piccolo.XML_DOC_DECL;
        else
            return Piccolo.XML_DOC_OR_TEXT_DECL;
    }
    else
    if (currentEntity.getDeclaredEncoding() != null
            && !currentEntity.isStandaloneDeclared())
            return Piccolo.XML_TEXT_DECL;
    else
        throw fatalError("XML declaration is not well-formed");
 }
        case 518: break;
        case 15: 
        case 89: 
          { 
        clearCbuf();
        prevState = TAG_QSTRING_NORMALIZE_BUFFERED;
        yybegin(prevState);
     }
        case 519: break;
        case 151: 
          {  yybegin(DTD_TAG_VALUE_STD_ENTITYREF);  }
        case 520: break;
        case 290: 
          {  return Piccolo.IGNORED_CONDITIONAL_START;  }
        case 521: break;
        case 309: 
          {  yybegin(DTD_COMMENT);  }
        case 522: break;
        case 76: 
          { 
        yybegin(TAG_VALUE_ENTITYREF);
     }
        case 523: break;
        case 230: 
          { 
        yybegin(DTD_TAG);
        return stringToken(Piccolo.STRING,yytext(1,yylength()-2));
     }
        case 524: break;
        case 244: 
          { 
        return stringToken(Piccolo.STRING,yytext(1,yylength()-2));
     }
        case 525: break;
        case 64: 
        case 65: 
        case 66: 
        case 187: 
        case 188: 
        case 270: 
        case 319: 
        case 354: 
        case 382: 
          { 
        isNamespaceDeclaration = false;
        attributeLocalName = attributeQName = yytext2();
        attributeURI = "";
        yybegin(TAG_VALUE);
     }
        case 526: break;
        case 191: 
        case 192: 
        case 272: 
          { 
        yybegin(CLOSE_TAG_NS);
        elementURI = nsSupport.getDefaultURI();
        stringValue = elementLocalName = yytext2(1,yylength()-1);
     }
        case 527: break;
        case 16: 
        case 93: 
          { 
        clearCbuf();
        prevState = TAG_SQSTRING_NORMALIZE_BUFFERED;
        yybegin(prevState);
     }
        case 528: break;
        case 215: 
          {  return Piccolo.RBRACKET_END;  }
        case 529: break;
        case 180: 
        case 181: 
        case 182: 
        case 264: 
        case 265: 
        case 314: 
        case 315: 
          { 
    piPrevState = baseState;
    elementQName = yytext2(1,yylength()-1);
    yybegin(PI_WS);
 }
        case 530: break;
        case 57: 
          { 
        attributeQName = yytext2();
        yybegin(TAG_VALUE);
     }
        case 531: break;
        case 40: 
          { 
    int result;

    tokenStartLine = yyline_next + 1;

    yybegin(tagStartState);

    if (parser.fNamespaces)
        result = parseTagNS();
    else
        result = parseTag();

    if (result != -1) {
        if (tokenizeInput) {
            if (tagType == Piccolo.OPEN_TAG)
                setTokenize(false);
            return tagType;
        }
    }

 }
        case 532: break;
        case 109: 
          { 
    yybegin(DTD_ATT_NAME);
    bypassPERefs=true;
    return stringToken(Piccolo.NAME,yytext2());
 }
        case 533: break;
        case 432: 
          {  yybegin(DTD_TAG); return Piccolo.NOTATION_START;  }
        case 534: break;
        case 429: 
          {  yybegin(DTD_ATTLIST_ELEMENT); return Piccolo.ATTLIST_START;  }
        case 535: break;
        case 392: 
          {  bypassPERefs = bypassGERefs = true; return Piccolo.SYSTEM;  }
        case 536: break;
        case 356: 
          {  appendToCbuf('\"'); yybegin(prevState);  }
        case 537: break;
        case 355: 
          {  appendToCbuf('\'');  yybegin(prevState);  }
        case 538: break;
        case 279: 
          {  appendToCbuf('>');  yybegin(prevState);  }
        case 539: break;
        case 273: 
          {  appendToCbuf('<');  yybegin(prevState);  }
        case 540: break;
        case 118: 
          {  yybegin(DTD_NMTOKENS); return Piccolo.LPAREN;  }
        case 541: break;
        case 256: 
          { 
    if (isTopEntity())
        throw fatalError("Parameter entities may not appear in the internal subset");

    if (!handleLiteralEntityRef(yytext2(0,yylength()-1),EntityManager.PARAMETER)) {
        appendToCbuf('%');
        appendToCbuf(yy_buffer,yy_startRead,yy_markedPos-yy_startRead);
        yybegin(prevState);
    }
 }
        case 542: break;
        case 269: 
          { 
        isNamespaceDeclaration = false;
        attributeQName = yytext2();
        int colon = attributeQName.indexOf(':');
        attributeURI = yytext2(0,colon);
        // fixing bug when computing localname
        attributeLocalName = yytext2(colon+1,(yylength()-colon-1));
        yybegin(TAG_VALUE);
     }
        case 543: break;
        case 254: 
          { 
    appendToCbuf('&');
    appendToCbuf(yy_buffer,yy_startRead,yylength());
    yybegin(prevState);
 }
        case 544: break;
        case 102: 
          { 
    yybegin(baseState);
    checkEndTag(stringValue);
    parser.reportEndTag(elementURI,elementLocalName,stringValue);
    if (tokenizeInput)
        return Piccolo.CLOSE_TAG;
 }
        case 545: break;
        case 34: 
        case 156: 
          { 
        appendToCbuf(yy_buffer,yy_startRead,yylength());
     }
        case 546: break;
        case 35: 
        case 160: 
          { 
        appendToCbuf(yy_buffer,yy_startRead,yylength());
     }
        case 547: break;
        case 84: 
          { 
    for (int i=0; i < yylength(); i++) {
        appendToCbuf(' ');
    }
 }
        case 548: break;
        case 280: 
          { 
        int token = handleEntityRef(yytext2(1,yylength()-2),EntityManager.PARAMETER);
        if (token != 0) {
            returnEntityEndToken = false;
            return token;
        }
     }
        case 549: break;
        case 60: 
          { 
        yybegin(TAG);
        stringValue = yytext2();
        prepareComplexElement(stringValue);
     }
        case 550: break;
        case 44: 
          { 
        /* Instead of making flex deal with the simple parsing,
         * we use a handwritten loop that can handle simple text and
         * tags more efficiently.
         *
         * parseCdata();
         * parser.reportCdata(cdataBuffer,cdataStart,cdataLength);
         */

        safeBacktrack();
        int token = parseXML();

        if (token != 0)
            return token;
     }
        case 551: break;
        case 41: 
          { 
        yybegin(ENTITYREF);
     }
        case 552: break;
        case 167: 
          { 
        yybegin(baseState);

        int token = handleEntityRef(yytext2(0,yylength()-1),EntityManager.GENERAL);
        if (token != 0)
            return token;
     }
        case 553: break;
        case 178: 
          { 
    yybegin(piPrevState);
    parser.reportPI(elementQName,"");
    if (piPrevState != DTD_TAG_VALUE_EXTERNAL_ENTITY && tokenizeInput) {
        return Piccolo.PI;
    }
 }
        case 554: break;
        case 430: 
          { 
        yybegin(DTD_TAG);
        if (parseExternalEntities(EntityManager.GENERAL))
            return Piccolo.DTD_START;
        else
            return Piccolo.DTD_START_SKIPEXTERNAL;
     }
        case 555: break;
        case 419: 
          { 
        yybegin(baseState);
        startCdata();
        parseCdataSection();
        if (tokenizeInput)
            return Piccolo.CDATA;
        endCdata();
     }
        case 556: break;
        case 406: 
          { 
        attributeURI = "xmlns";
        attributeLocalName = "";
        attributeQName = "xmlns";
        isNamespaceDeclaration = true;
        parseCdataLiteral('\'',TAG_SQSTRING_CDATA_BUFFERED);
     }
        case 557: break;
        case 405: 
          { 
        attributeURI = "xmlns";
        attributeLocalName = "";
        attributeQName = "xmlns";
        isNamespaceDeclaration = true;
        parseCdataLiteral('\"',TAG_QSTRING_CDATA_BUFFERED);
     }
        case 558: break;
        case 321: 
          { 
        yybegin(prevState);
         try {
             parseEncodedChar(yy_buffer,yy_startRead+2,yylength()-3,16);
         }
         catch (ClassCastException e) {
             throw fatalError("Invalid character entity reference: &"+yytext());
         }
      }
        case 559: break;
        case 289: 
          { 
    yybegin(DTD);
    parser.reportComment(yy_buffer,yy_startRead,(yy_markedPos-3)-yy_startRead);

    // Comments are never important in the DTD
//    if (tokenizeInput)
//        return Piccolo.COMMENT;
 }
        case 560: break;
        case 274: 
          { 
        yybegin(prevState);
        try {
            parseEncodedChar(yy_buffer,yy_startRead+1,yylength()-2,10);
        }
       catch (ClassCastException e) {
            throw fatalError("Invalid character entity reference: &"+yytext());
       }
     }
        case 561: break;
        case 271: 
          { 
        nsSupport.pushContext();
        yybegin(TAG_NS);
        stringValue = yytext2();
        int colon = stringValue.indexOf(':');
        elementURI = yytext2(0,colon);
        elementLocalName = yytext2(colon+1,yylength()-(colon+1));
        prepareComplexElement(stringValue);
     }
        case 562: break;
        case 210: 
          { 
    yybegin(tagState);
    addAttribute(attributeURI,attributeLocalName,
                 attributeQName,attributeValueType,
                 new String(cbuf,0,cbuflen));
 }
        case 563: break;
        case 94: 
          { 
        clearCbuf();
        prevState = TAG_SQSTRING_NORMALIZE_BUFFERED;
        needsNormalization = true;
        yybegin(TAG_VALUE_ENTITYREF);
     }
        case 564: break;
        case 90: 
          { 
        clearCbuf();
        prevState = TAG_QSTRING_NORMALIZE_BUFFERED;
        needsNormalization = true;
        yybegin(TAG_VALUE_ENTITYREF);
     }
        case 565: break;
        case 69: 
        case 70: 
        case 190: 
          { 
        nsSupport.pushContext();
        yybegin(TAG_NS);
        elementURI = "";
        elementLocalName = stringValue = yytext2();
        prepareComplexElement(stringValue);
     }
        case 566: break;
        case 67: 
          { 
        yybegin(baseState);
        processComplexElement();
        resolveNamespacePrefixes();
        parser.reportStartTag(elementURI,elementLocalName,stringValue);
        attribs.clear();
        tagStack.push(stringValue);
        if (tokenizeInput) {
            setTokenize(false);
            return Piccolo.OPEN_TAG;
        }
     }
        case 567: break;
        case 157: 
          { 
            if (bypassGERefs)
                appendToCbuf('&');
            else
                yybegin(DTD_TAG_VALUE_STD_ENTITYREF);
         }
        case 568: break;
        case 158: 
          { 
            if (bypassPERefs)
                appendToCbuf('%');
            else
                yybegin(DTD_TAG_VALUE_PARAM_ENTITYREF);
         }
        case 569: break;
        case 198: 
          { 
    if (!handleLiteralEntityRef(yytext2(0,yylength()-1),EntityManager.GENERAL)) {
        appendToCbuf('&');
        appendToCbuf(yy_buffer,yy_startRead,yy_markedPos-yy_startRead);
        yybegin(prevState);
    }
  }
        case 570: break;
        case 373: 
          { 
    prevState = DTD;
    yybegin(XML_TAG);
 }
        case 571: break;
        case 320: 
          { 
        yybegin(CLOSE_TAG_NS);
        stringValue = yytext2(1,yylength()-1);
        int colon = stringValue.indexOf(':') + 1;
        elementURI = nsSupport.getURI(yytext2(1,colon-1));
        elementLocalName = yytext2(colon+1,(yylength()-1)-colon);
     }
        case 572: break;
        case 245: 
        case 246: 
        case 247: 
        case 303: 
        case 304: 
        case 341: 
        case 342: 
          { 
    piPrevState = DTD;
    yybegin(PI_WS);
    elementQName = yytext2(1,yylength()-1);
 }
        case 573: break;
        case 28: 
        case 126: 
        case 127: 
        case 128: 
          {  }
        case 574: break;
        case 6: 
        case 8: 
        case 56: 
          {  }
        case 575: break;
        default:
          if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
            yy_atEOF = true;
            yy_do_eof();
            switch (yy_lexical_state) {
            case CLOSE_TAG_NS:
              { 
    throw fatalError("Entity is not well-formed (ending lex state: " + yystate() + ")");
 }
            case 434: break;
            case PI:
              { 
    throw fatalError("Entity is not well-formed (ending lex state: " + yystate() + ")");
 }
            case 435: break;
            case ENTITYREF:
              { 
    throw fatalError("Entity is not well-formed (ending lex state: " + yystate() + ")");
 }
            case 436: break;
            case TAG_VALUE_ENTITYREF:
              { 
    throw fatalError("Entity is not well-formed (ending lex state: " + yystate() + ")");
 }
            case 437: break;
            case TAG_NS:
              { 
    throw fatalError("Entity is not well-formed (ending lex state: " + yystate() + ")");
 }
            case 438: break;
            case DTD_COMMENT:
              { 
    throw fatalError("Entity is not well-formed (ending lex state: " + yystate() + ")");
 }
            case 439: break;
            case PI_WS:
              { 
    throw fatalError("Entity is not well-formed (ending lex state: " + yystate() + ")");
 }
            case 440: break;
            case TAG_START_NS:
              { 
    throw fatalError("Entity is not well-formed (ending lex state: " + yystate() + ")");
 }
            case 441: break;
            case TAG_VALUE:
              { 
    throw fatalError("Entity is not well-formed (ending lex state: " + yystate() + ")");
 }
            case 442: break;
            case CLOSE_TAG:
              { 
    throw fatalError("Entity is not well-formed (ending lex state: " + yystate() + ")");
 }
            case 443: break;
            default:
              { 

    if (yymoreStreams()) {
        yypopStream();

        if (isEntityBeingParsed) {
            if (currentEntity != null)
                currentEntity.close();
            currentEntity = (Entity) entityStack.pop();
        }

        boolean prevReturnEndToken = returnEntityEndToken;
        boolean prevIsParamEntity = isParamEntity;

        popEntityState();


        if (prevReturnEndToken)
            return Piccolo.ENTITY_END;
        else if (prevIsParamEntity)
            return Piccolo.WHITESPACE;
    }
    else
        return 0;
 }
            }
          }
          else {
            yy_ScanError(YY_NO_MATCH);
          }
      }
    }
  }


}
