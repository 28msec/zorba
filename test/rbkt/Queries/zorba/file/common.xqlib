module namespace commons = "http://expath.org/ns/file/tests/commons";

import module namespace file = "http://expath.org/ns/file";

import schema namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";

declare function commons:error($messages as xs:string*) as xs:string* {
  "
************************************************************************
ERROR:
  Location:", file:resolve-path("."), "
  Cause:",
  $messages,
  "
************************************************************************
"
};

(: ******************************** SIMPLE TESTS ******************************** :)

declare %sequential function commons:testExists($path as xs:string) as xs:string* {
  if (file:exists($path)) then
    "SUCCESS"
  else
    ("testExists failed for path:", $path)
};

declare %sequential function commons:testCreateDirectory($path as xs:string) as xs:string* {
  try {
    file:create-directory($path);
    "SUCCESS";
  } catch * {
    exit returning ("testCreateDirectory failed for path:", $path)
  }
};

declare %sequential function commons:testWriteXml($path as xs:string, $xml as item()) as xs:string* {
  file:write($path, $xml, ());
  "SUCCESS";
};

declare %sequential function commons:testReadAndCompareXml($path as xs:string, $xml as item()) as xs:string* {
  let $x := fn:parse-xml(file:read-text($path))
  return
    if($x eq $xml) then 
      "SUCCESS"
    else
      ("testReadXml failed for path:", $path, "compared with the reference xml:
", fn:serialize($xml))
};

declare %sequential function commons:testReadBinary($path as xs:string) as xs:base64Binary {
  file:read-binary($path)
};

declare %sequential function commons:testDelete($path as xs:string) as xs:string* {
  try {
    file:delete($path);
    "SUCCESS";
  } catch * {
    exit returning ("testDelete failed for path:", $path)
  };
};

declare %sequential function commons:testWriteSerializeXml($path as xs:string, $xml as item()) as xs:string* {
  file:write(
    $path,
    $xml,
    <output:serialization-parameters>
      <output:method value="xml"/>
    </output:serialization-parameters>);

  "SUCCESS";
};


(: ****************************** COMPOSITE TESTS ******************************* :)

declare %sequential function commons:testInitDir($dir as xs:string) as xs:string* {
  (: ==================================================================== :)
  (: the test directory must not exist :)
  (: ========= :)
  let $s := commons:testExists($dir)
  return
    if (commons:isSuccess($s)) then
      exit returning ("testInitDir failed - directory already exists:", $dir)
    else ();

  (: ==================================================================== :)
  (: it must be able to create the test directory :)
  (: ========= :)
  let $s := commons:testCreateDirectory($dir)
  return 
    if (fn:not(commons:isSuccess($s))) then
      (: exit returning ("testInitDir failed - could not create directory:", $dir) :)
      ()
    else ();

  (: ==================================================================== :)
  (: the test directory must exist :)
  (: ========= :)
  let $s := commons:testExists($dir)
  return 
    if (fn:not(commons:isSuccess($s))) then
      exit returning ("testInitDir failed - directory must exists:", $dir)
    else ();
  (: ==================================================================== :)

  "SUCCESS";
};


declare %sequential function commons:testUnInitDir($dir as xs:string) as xs:string* 
{
  (: ==================================================================== :)
  (: delete the directory :)
  (: ========= :)
  declare $dirFullPath := file:resolve-path($dir);
  declare $s := commons:testDelete($dirFullPath);

  if (fn:not(commons:isSuccess($s))) 
  then
    exit returning ("testUnInitDir failed - could not delete directory:", $dirFullPath)
  else
    ();
  (: ==================================================================== :)

  "SUCCESS";
};


(: ******************************* COMMON EXTRAS ******************************** :)

declare function commons:isSuccess($status as xs:string*) as xs:boolean 
{
  if (fn:count($status) eq 0 or (fn:count($status) eq 1 and $status eq "SUCCESS")) then
    fn:true()
  else
    fn:false()    
};
