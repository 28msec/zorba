#!/usr/bin/perl
use strict;
use Getopt::Long;
use FindBin;
use File::Temp;

my ($html, $blame);
GetOptions ("html" => \$html, "blame" => \$blame);

my $test_path = $FindBin::RealBin;

my %queries;

sub add_case {
    my ($q, $file, $fun, $assertion) = @_;
    $_ = "$file: $fun: $assertion";
    if ($html) {
        s/([&])/$1amp;/g; s/([<])/&lt;/g; s/[>]/&gt;/g;
    }
    push @{ $queries {$_} }, $q;
}

sub by_number_desc_then_string {
    return -(($a <=> $b) || ($a cmp $b));
}

sub svn_blame {
    if (! $blame) { return ""; }
    
    my $author;

    my ($qfh, $qf) = File::Temp::tempfile ();
    print $qfh '
declare option saxon:output "omit-xml-declaration=yes";
declare variable $line external;
//entry [@line-number eq $line]//author/text()
';
    close ($qfh);
    
    if (m#([^:]+):([^:]+):#) {
        my ($file, $line) = ($1, $2);
        $author = `svn blame --xml $file | $test_path/zorbatest/xquery -s - $qf line=$line`
    }

    # unlink $qf;
    return "$author: ";
}

my $query;

while (<>) {
    if (m#^[0-9]+/[0-9]+ Testing: (.*)$#) {
        $query = $1;
    } elsif (m#^[^:]+: ([^:]+:[0-9]+): (.*): Assertion (.*) failed.$#) {
        add_case $query, $1, $2, $3;
    } elsif (m#XQP0005:.*Assertion (.*) failed in ([^:]+:[0-9]+): (.*)$#) {
        add_case $query, $2, $3, $1;
    }
}

# change testcase names to include fault count
my %queries_new;
foreach (keys %queries) {
    my @qs = @{ $queries {$_} };
    $_ = scalar @qs . " queries: " . svn_blame . $_;
    @{ $queries_new {$_} } = @qs;
}
%queries = %queries_new;

foreach (sort (by_number_desc_then_string keys(%queries))) {
    my $case = $_;
    my @qs = @{ $queries {$case} };
    print $case . "\n" . join ("\n", @qs) . "\n\n";
}
