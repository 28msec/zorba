<div class="doxygen">
  <div><h1 class="title">JSONiq for XQuery users tutorial</h1>
<html><head><title>JSON for XQuery</title><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=lhDjYqiy3mZ0x6ROQEUoUw');ol{margin:0;padding:0}.c9{padding-left:0pt;text-align:justify;margin-left:36pt}.c7{list-style-type:disc;margin:0;padding:0}.c19{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c20{color:inherit;text-decoration:inherit}.c11{text-indent:-13pt;margin-left:77pt}.c2{font-size:36pt;font-weight:bold}.c21{color:#1155cc;text-decoration:underline}.c16{font-weight:bold}.c3{color:#38761d}.c15{text-indent:120pt}.c22{color:#4a86e8}.c17{text-align:center}.c13{margin-left:49.5pt}.c6{text-align:right}.c10{text-indent:156pt}.c0{font-family:"Consolas"}.c12{text-indent:144pt}.c14{text-align:justify}.c8{text-indent:139.5pt}.c5{margin-left:144pt}.c18{font-style:italic}.c4{height:11pt}.c1{direction:ltr}.title{padding-top:24pt;line-height:1.15;text-align:center;color:#4a86e8;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#4a86e8;font-size:24pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#ff9900;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#000000;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#000000;font-size:11pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}</style></head><body class="c19"><p class="c17 c1"><span class="c2">JSONiq for XQuery users</span></p><p class="c4 c1 c15"><span/></p><p class="c1 c17"><span>This tutorial introduces the JSONiq language, which declaratively manipulates JSON data.</span></p><p class="c17 c1"><span>Why don't you go ahead can try the queries of this document on our online demo interface?</span></p><p class="c17 c1"><span> </span><span class="c21 c16"><a class="c20" href="http://www.zorba-xquery.com/html/jsoniq">http://www.zorba-xquery.com/html/jsoniq</a></span></p><p class="c4 c1"><span/></p><h1 class="c1"><a name="h.f453h84m2u1a"/><span>JSON</span></h1><p class="c14 c1"><span>As explained on </span><span class="c21"><a class="c20" href="http://www.json.org/">http://www.json.org/</a></span><span>, JSON is a lightweight data-interchange format designed for humans as well as for computers. It supports as values:</span></p><ol class="c7" start="1"><li class="c9 c1"><span>objects (string-to-value map)</span></li><li class="c9 c1"><span>arrays (ordered sequence of values)</span></li><li class="c1 c9"><span>strings</span></li><li class="c9 c1"><span>numbers</span></li><li class="c9 c1"><span>booleans (true, false)</span></li><li class="c9 c1"><span>null</span></li></ol><p class="c4 c1"><span/></p><p class="c1"><span>JSONiq extends XQuery to query and update JSON data, like XML data.</span></p><h1 class="c1"><a name="h.qtfakecy3fr7"/><span>Elevator Pitch</span></h1><p class="c14 c1"><span>Here is an appetizer before we start the tutorial from scratch.</span></p><p class="c4 c1"><span/></p><p class="c1"><span class="c0">let $stores :=</span></p><p class="c1"><span class="c0">[</span></p><p class="c1"><span class="c0">  { "store number" : 1, "state" : "MA" },</span></p><p class="c1"><span class="c0">  { "store number" : 2, "state" : "MA" },</span></p><p class="c1"><span class="c0">  { "store number" : 3, "state" : "CA" },</span></p><p class="c1"><span class="c0">  { "store number" : 4, "state" : "CA" }</span></p><p class="c1"><span class="c0">]</span></p><p class="c1"><span class="c0">let $sales := [</span></p><p class="c1"><span class="c0">   { "product" : "broiler", "store number" : 1, "quantity" : 20  },</span></p><p class="c1"><span class="c0">   { "product" : "toaster", "store number" : 2, "quantity" : 100 },</span></p><p class="c1"><span class="c0">   { "product" : "toaster", "store number" : 2, "quantity" : 50 },</span></p><p class="c1"><span class="c0">   { "product" : "toaster", "store number" : 3, "quantity" : 50 },</span></p><p class="c1"><span class="c0">   { "product" : "blender", "store number" : 3, "quantity" : 100 },</span></p><p class="c1"><span class="c0">   { "product" : "blender", "store number" : 3, "quantity" : 150 },</span></p><p class="c1"><span class="c0">   { "product" : "socks", "store number" : 1, "quantity" : 500 },</span></p><p class="c1"><span class="c0">   { "product" : "socks", "store number" : 2, "quantity" : 10 },</span></p><p class="c1"><span class="c0">   { "product" : "shirt", "store number" : 3, "quantity" : 10 }</span></p><p class="c1"><span class="c0">]</span></p><p class="c1"><span class="c0">let $join :=</span></p><p class="c1"><span class="c0">  for $store in jn:members($stores), $sale in jn:members($sales)</span></p><p class="c1"><span class="c0">  where $store("store number") = $sale("store number")</span></p><p class="c1"><span class="c0">  return {</span></p><p class="c1"><span class="c0">    "nb" : $store("store number"),</span></p><p class="c1"><span class="c0">    "state" : $store("state"),</span></p><p class="c1"><span class="c0">    "sold" : $sale("product")</span></p><p class="c1"><span class="c0">  }</span></p><p class="c1"><span class="c0">return [$join]</span></p><p class="c5 c1"><span class="c3 c0">[ </span></p><p class="c5 c1"><span class="c3 c0">  { "nb" : 1, "state" : "MA", "sold" : "broiler" },</span></p><p class="c5 c1"><span class="c3 c0">  { "nb" : 1, "state" : "MA", "sold" : "socks" },</span></p><p class="c5 c1"><span class="c3 c0">  { "nb" : 2, "state" : "MA", "sold" : "toaster" },</span></p><p class="c5 c1"><span class="c3 c0">  { "nb" : 2, "state" : "MA", "sold" : "toaster" },</span></p><p class="c5 c1"><span class="c3 c0">  { "nb" : 2, "state" : "MA", "sold" : "socks" },</span></p><p class="c5 c1"><span class="c3 c0">  { "nb" : 3, "state" : "CA", "sold" : "toaster" },</span></p><p class="c5 c1"><span class="c3 c0">  { "nb" : 3, "state" : "CA", "sold" : "blender" },</span></p><p class="c5 c1"><span class="c3 c0">  { "nb" : 3, "state" : "CA", "sold" : "blender" },</span></p><p class="c5 c1"><span class="c3 c0">  { "nb" : 3, "state" : "CA", "sold" : "shirt" }</span></p><p class="c5 c1"><span class="c3 c0"> ]</span></p><p class="c4 c1"><span/></p><h1 class="c1"><a name="h.yugk1mszt0re"/><span>And here you go</span></h1><h2 class="c1"><a name="h.39rm37noeh9g"/><span>JSONiq types</span></h2><p class="c1"><span>JSONiq maps JSON types to the XQuery data model. Numbers are xs:integer, xs:decimal or xs:double, strings are xs:string, true and false are xs:boolean and null is the unique value of a new atomic type jn:null.</span></p><p class="c4 c1"><span/></p><p class="c1"><span>By default, in JSONiq, for convenience, true, false and null are recognized as literals instead of the classical XQuery path expression semantics (i.e., they would otherwise navigate to XML elements named "true", "false" or "null"). However, this can be deactivated to use the path expression semantics.</span></p><p class="c4 c1"><span/></p><p class="c1"><span>JSONiq also introduces new items: objects and arrays. Objects are sets of key/value pairs. Arrays have members which are values. Values are objects, arrays, XML nodes, functions or atomic items. Note that, in particular, Arrays can nest, unlike sequences.</span></p><p class="c4 c1"><span/></p><p class="c1"><span>The new item types for objects and arrays are object() and array(). json-item() is a supertype of both. structured-item() is a supertype for json-item() and node().</span></p><h2 class="c1"><a name="h.j0wg8654ivtw"/><span>JSON Constructors</span></h2><p class="c1"><span>JSONiq introduces JSON constructors, in a similar way to XML constructors.</span></p><p class="c4 c1"><span/></p><p class="c1"><span>You can put any expression in a array. The items in the sequence produced by the expression will become members of the array:</span></p><p class="c4 c1"><span/></p><p class="c1"><span class="c0">[ 1 to 10 ]</span></p><p class="c6 c1"><span class="c3 c0">[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</span></p><p class="c6 c4 c1"><span class="c3 c0"/></p><p class="c1"><span>Or you can dynamically compute an object:</span></p><p class="c4 c1"><span/></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">  "Greeting" : let $d := "Mister Spock"</span></p><p class="c1"><span class="c0">               return concat("Hello, ", $d),</span></p><p class="c1"><span class="c0">  "Farewell" : string-join(("Live", "long", "and", "prosper"),</span></p><p class="c1"><span class="c0">                           " ")</span></p><p class="c1"><span class="c0">}</span></p><p class="c4 c1"><span class="c3 c0"/></p><p class="c6 c1"><span class="c3 c0">{ "Greeting" : "Hello, Mister Spock", "Farewell" : "Live long and prosper" }</span></p><p class="c4 c1"><span class="c3"/></p><p class="c1"><span>You can also dynamically generate singleton objects:</span></p><p class="c4 c1"><span class="c0"/></p><p class="c1"><span class="c0">{ concat("Square of ", 2) : 2 * 2 }</span></p><p class="c6 c1"><span class="c3 c0">{ "Square of 2" : 4 }</span></p><p class="c6 c4 c1"><span class="c3 c0"/></p><p class="c1"><span>and then use the {| |} construct to wrap several of them in a bigger object:</span></p><p class="c4 c1"><span class="c0"/></p><p class="c1"><span class="c0">{|</span></p><p class="c1"><span class="c0">  for $i in 1 to 10</span></p><p class="c1"><span class="c0">  return { concat("Square of ", $i) : $i * $i }</span></p><p class="c1"><span class="c0">|}</span></p><p class="c5 c1"><span class="c3 c0">{</span></p><p class="c5 c1"><span class="c3 c0">"Square of 1" : 1,</span></p><p class="c5 c1"><span class="c3 c0">"Square of 2" : 4,</span></p><p class="c5 c1"><span class="c3 c0">"Square of 3" : 9,</span></p><p class="c1 c5"><span class="c3 c0">"Square of 4" : 16,</span></p><p class="c5 c1"><span class="c3 c0">"Square of 5" : 25,</span></p><p class="c5 c1"><span class="c3 c0">"Square of 6" : 36,</span></p><p class="c5 c1"><span class="c3 c0">"Square of 7" : 49,</span></p><p class="c5 c1"><span class="c3 c0">"Square of 8" : 64,</span></p><p class="c5 c1"><span class="c3 c0">"Square of 9" : 81,</span></p><p class="c5 c1"><span class="c3 c0">"Square of 10" : 100</span></p><p class="c5 c1"><span class="c3 c0">}</span></p><p class="c4 c1"><span/></p><h2 class="c1"><a name="h.qe57mgdf5ql"/><span>JSON as a subset of JSONiq</span></h2><p class="c14 c1"><span>As a rule of thumb, a well-formed JSON document is a JSONiq expression as well. This means that you can copy-and-paste a JSON document into a query. The following are JSONiq queries that are "idempotent" (they just output themselves):</span></p><p class="c4 c1"><span/></p><p class="c1"><span class="c0">{ "pi" : 3.14, "sq2" : 1.4 }</span></p><p class="c6 c1"><span class="c3 c0">{ "pi" : 3.14, "sq2" : 1.4 }</span></p><p class="c1 c4"><span class="c3 c0"/></p><p class="c1"><span class="c0">[ 2, 3, 5, 7, 11, 13 ]</span></p><p class="c6 c1"><span class="c3 c0">[ 2, 3, 5, 7, 11, 13 ]</span></p><p class="c4 c1"><span class="c0"/></p><p class="c1"><span class="c0">{</span></p><p class="c1"><span class="c0">  "operations" : [</span></p><p class="c1"><span class="c0">    { "binary" : [ "and", "or"] },</span></p><p class="c1"><span class="c0">    { "unary" : ["not"] }</span></p><p class="c1"><span class="c0">  ],</span></p><p class="c1"><span class="c0">  "bits" : [</span></p><p class="c1"><span class="c0">    0, 1</span></p><p class="c1"><span class="c0">  ]</span></p><p class="c1"><span class="c0">}</span></p><p class="c12 c1"><span class="c0 c3">{</span></p><p class="c12 c1"><span class="c3 c0">  "operations" : [</span></p><p class="c12 c1"><span class="c3 c0">    { "binary" : [ "and", "or" ] },</span></p><p class="c1 c12"><span class="c3 c0">    { "unary" : [ "not" ] }</span></p><p class="c12 c1"><span class="c3 c0">  ],</span></p><p class="c12 c1"><span class="c3 c0">  "bits" : [</span></p><p class="c12 c1"><span class="c3 c0">    0, 1</span></p><p class="c12 c1"><span class="c3 c0">  ]</span></p><p class="c12 c1"><span class="c3 c0">}</span></p><p class="c6 c4 c1"><span class="c3 c0"/></p><p class="c14 c1"><span>This works with objects, arrays (even nested), strings, numbers, booleans, null. </span><span class="c18">The exceptions to this rule (but we are working on it!) are that:</span></p><p class="c14 c1"><span class="c18">(i) empty objects are not recognized</span></p><p class="c14 c1"><span class="c18">(ii) characters escaped with the \ in JSON strings are not recognized, XML character references are recognized instead.</span></p><p class="c4 c1"><span class="c0 c18"/></p><p class="c14 c1"><span>It also works the other way round: if your query outputs an object or an array, you can directly use it as a JSON document.</span></p><p class="c6 c4 c1"><span class="c3 c0"/></p><h1 class="c1"><a name="h.dewn8sw3husv"/><span>JSON Navigation</span></h1><p class="c14 c1"><span>Up to now, you learnt how to compose expressions so as to do some computations and to build objects and arrays. It also works the other way round: if you have some JSON data, you can access it and navigate.</span></p><p class="c10 c4 c1"><span/></p><p class="c14 c1"><span>All you need to know is: JSONiq views</span></p><ol class="c7" start="1"><li class="c9 c1"><span>an array as an ordered list of values,</span></li><li class="c9 c1"><span>an object as a set of name/value pairs</span></li></ol><h2 class="c14 c1"><a name="h.zcnazhl6374z"/><span>Objects</span></h2><p class="c14 c1"><span>You can use an object as if it were a function and pass the call an argument of type xs:string. It will return the value associated thereto:</span></p><p class="c10 c4 c1"><span/></p><p class="c1"><span class="c0">let $person := {</span></p><p class="c1"><span class="c0"> "first name" : "Sarah",</span></p><p class="c1"><span class="c0"> "age" : 13,</span></p><p class="c1"><span class="c0"> "gender" : "female",</span></p><p class="c1"><span class="c0"> "friends" : [ "Jim", "Mary", "Jennifer"]</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">return $person("first name")</span></p><p class="c6 c10 c1"><span class="c3 c0">"Sarah"</span></p><p class="c10 c4 c1"><span class="c3 c0"/></p><p class="c1"><span>You can also ask for all keys in an object:</span></p><p class="c4 c1"><span/></p><p class="c1"><span class="c0">let $person := {</span></p><p class="c1"><span class="c0"> "name" : "Sarah",</span></p><p class="c1"><span class="c0"> "age" : 13,</span></p><p class="c1"><span class="c0"> "gender" : "female",</span></p><p class="c1"><span class="c0"> "friends" : [ "Jim", "Mary", "Jennifer"]</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">return { "keys" : [ jn:keys($person)] }</span></p><p class="c10 c4 c1"><span class="c0"/></p><p class="c6 c1 c11"><span class="c3 c0">{ "keys" : [ "name", "age", "gender", "friends" ] }</span></p><h2 class="c1"><a name="h.30wafxvenhgy"/><span>Arrays</span></h2><p class="c14 c1"><span>You can use an array as if it were a function and pass the call an argument of type xs:integer. It will return the entry at that position:</span></p><p class="c10 c4 c1"><span/></p><p class="c1"><span class="c0">let $friends := [ "Jim", "Mary", "Jennifer"]</span></p><p class="c1"><span class="c0">return $friends(2)</span></p><p class="c6 c10 c1"><span class="c3 c0">Mary</span></p><p class="c4 c1"><span class="c3 c0"/></p><p class="c1"><span>It is also possible to get the size of an array:</span></p><p class="c4 c1 c10"><span/></p><p class="c1"><span class="c0">let $person := {</span></p><p class="c1"><span class="c0"> "name" : "Sarah",</span></p><p class="c1"><span class="c0"> "age" : 13,</span></p><p class="c1"><span class="c0"> "gender" : "female",</span></p><p class="c1"><span class="c0"> "friends" : [ "Jim", "Mary", "Jennifer"]</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">return { "how many friends" : jn:size($person("friends")) }</span></p><p class="c10 c4 c1"><span class="c0"/></p><p class="c6 c10 c1"><span class="c3 c0">{ "how many friends" : 3 }</span></p><p class="c10 c4 c1"><span class="c3 c0"/></p><p class="c1"><span>For convenience, there is a function that returns all elements in an array, as a sequence:</span></p><p class="c10 c4 c1"><span/></p><p class="c1"><span class="c0">let $person := {</span></p><p class="c1"><span class="c0"> "name" : "Sarah",</span></p><p class="c1"><span class="c0"> "age" : 13,</span></p><p class="c1"><span class="c0"> "gender" : "female",</span></p><p class="c1"><span class="c0"> "friends" : [ "Jim", "Mary", "Jennifer"]</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">return jn:members($person("friends"))</span></p><p class="c4 c1"><span class="c0"/></p><p class="c6 c10 c1"><span class="c3 c0">Jim Mary Jennifer</span></p><h1 class="c1"><a name="h.eb0bxle2oykl"/><span>Relational Algebra</span></h1><p class="c14 c1"><span>Remember SQL's SELECT FROM WHERE statements? JSONiq inherits selection, projection and join capability from XQuery FLWOR expressions. In order to traverse an array, jn:members() converts it into a sequence which can then be iterated over by a FLWOR expression.</span></p><p class="c4 c1"><span/></p><p class="c1"><span class="c0">let $stores :=</span></p><p class="c1"><span class="c0">[</span></p><p class="c1"><span class="c0">  { "store number" : 1, "state" : "MA" },</span></p><p class="c1"><span class="c0">  { "store number" : 2, "state" : "MA" },</span></p><p class="c1"><span class="c0">  { "store number" : 3, "state" : "CA" },</span></p><p class="c1"><span class="c0">  { "store number" : 4, "state" : "CA" }</span></p><p class="c1"><span class="c0">]</span></p><p class="c1"><span class="c0">let $sales := [</span></p><p class="c1"><span class="c0">   { "product" : "broiler", "store number" : 1, "quantity" : 20  },</span></p><p class="c1"><span class="c0">   { "product" : "toaster", "store number" : 2, "quantity" : 100 },</span></p><p class="c1"><span class="c0">   { "product" : "toaster", "store number" : 2, "quantity" : 50 },</span></p><p class="c1"><span class="c0">   { "product" : "toaster", "store number" : 3, "quantity" : 50 },</span></p><p class="c1"><span class="c0">   { "product" : "blender", "store number" : 3, "quantity" : 100 },</span></p><p class="c1"><span class="c0">   { "product" : "blender", "store number" : 3, "quantity" : 150 },</span></p><p class="c1"><span class="c0">   { "product" : "socks", "store number" : 1, "quantity" : 500 },</span></p><p class="c1"><span class="c0">   { "product" : "socks", "store number" : 2, "quantity" : 10 },</span></p><p class="c1"><span class="c0">   { "product" : "shirt", "store number" : 3, "quantity" : 10 }</span></p><p class="c1"><span class="c0">]</span></p><p class="c1"><span class="c0">let $join :=</span></p><p class="c1"><span class="c0">  for $store in jn:members($stores), $sale in jn:members($sales)</span></p><p class="c1"><span class="c0">  where $store("store number") = $sale("store number")</span></p><p class="c1"><span class="c0">  return {</span></p><p class="c1"><span class="c0">    "nb" : $store("store number"),</span></p><p class="c1"><span class="c0">    "state" : $store("state"),</span></p><p class="c1"><span class="c0">    "sold" : $sale("product")</span></p><p class="c1"><span class="c0">  }</span></p><p class="c1"><span class="c0">return [$join]</span></p><p class="c8 c1"><span class="c3 c0">[ </span></p><p class="c8 c1"><span class="c3 c0">{ "nb" : 1, "state" : "MA", "sold" : "broiler" },</span></p><p class="c8 c1"><span class="c3 c0">{ "nb" : 1, "state" : "MA", "sold" : "socks" },</span></p><p class="c1 c8"><span class="c3 c0">{ "nb" : 2, "state" : "MA", "sold" : "toaster" },</span></p><p class="c8 c1"><span class="c3 c0">{ "nb" : 2, "state" : "MA", "sold" : "toaster" },</span></p><p class="c8 c1"><span class="c3 c0">{ "nb" : 2, "state" : "MA", "sold" : "socks" },</span></p><p class="c8 c1"><span class="c3 c0">{ "nb" : 3, "state" : "CA", "sold" : "toaster" },</span></p><p class="c8 c1"><span class="c3 c0">{ "nb" : 3, "state" : "CA", "sold" : "blender" },</span></p><p class="c8 c1"><span class="c3 c0">{ "nb" : 3, "state" : "CA", "sold" : "blender" },</span></p><p class="c8 c1"><span class="c3 c0">{ "nb" : 3, "state" : "CA", "sold" : "shirt" }</span></p><p class="c8 c1"><span class="c3 c0"> ]</span></p><h1 class="c1"><a name="h.oii6pvliilhi"/><span>Access external data</span></h1><p class="c1"><span>Our implementation supports collections of (and indices on) JSON objects or arrays:</span></p><p class="c4 c1"><span/></p><p class="c1"><span class="c0">dml:collection("my:data")</span></p><p class="c6 c1"><span class="c3 c0">{ "foo" : "Your" }</span></p><p class="c6 c1"><span class="c3 c0">{ "foo" : "Collection" }</span></p><p class="c6 c1"><span class="c3 c0">{ "foo" : "of" }</span></p><p class="c6 c1"><span class="c3 c0">{ "foo" : "JSON" }</span></p><p class="c6 c1"><span class="c3 c0">{ "foo" : "objects" }</span></p><p class="c4 c1 c6"><span class="c3 c0"/></p><p class="c1"><span>It is also possible to get JSON content with an HTTP request, or by parsing it from a string. The EXPath http-client module (described in the Zorba documentation)  allows you to make HTTP requests, and the jn:parse-json() function allows you to use the body as an object or an array.</span></p><p class="c4 c1"><span class="c3 c0"/></p><h1 class="c1"><a name="h.fopcxnkoydgt"/><span>JSON and XML</span></h1><p class="c14 c1"><span>You can use XML and JSON in the same program. An XML node can be a value in an object or array, however, arrays and object may not be children of an XML node - but you can extract atomic values or XML nodes inside objects and arrays to insert them in a new XML node.</span></p><p class="c4 c1"><span/></p><p class="c1"><span class="c0">let $data := {</span></p><p class="c1"><span class="c0">  "color" : "blue",</span></p><p class="c1"><span class="c0">  "closed" : true,</span></p><p class="c1"><span class="c0">  "points" : [[10,10], [20,10], [20,20], [10,20]]</span></p><p class="c1"><span class="c0">}</span></p><p class="c1"><span class="c0">let $stroke := attribute stroke { $data("color") }</span></p><p class="c1"><span class="c0">let $points := attribute points { jn:flatten($data("points")) }</span></p><p class="c1"><span class="c0">return</span></p><p class="c1"><span class="c0">  if ($data("closed")) then</span></p><p class="c1"><span class="c0">    &lt;svg&gt;&lt;polygon&gt;{ $stroke, $points }&lt;/polygon&gt;&lt;/svg&gt;</span></p><p class="c1"><span class="c0">  else</span></p><p class="c1"><span class="c0">    &lt;svg&gt;&lt;polyline&gt;{ $stroke, $points }&lt;/polyline&gt;&lt;/svg&gt;</span></p><p class="c4 c1"><span class="c0"/></p><p class="c13 c6 c1"><span class="c3 c0">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></p><p class="c6 c1 c13"><span class="c3 c0">&lt;svg&gt;&lt;polygon stroke="blue" points="10 10 20 10 20 20 10 20"/&gt;&lt;/svg&gt;</span></p><p class="c4 c1"><span/></p><h1 class="c1"><a name="h.bm3buqmzhtko"/><span>I want more</span></h1><p class="c1 c14"><span>JSONiq supports JSON updates by extending the XQuery Update Facility specification, so you can declaratively update your JSON data. JSONiq provides new expressions that produce update primitives on JSON items. The list of updates that is eventually output by your program is then applied to your JSON data.</span></p><p class="c4 c1"><span/></p><p class="c1"><span class="c0">copy $people := {</span></p><p class="c1"><span class="c0"> "John" : { "status" : "single" },</span></p><p class="c1"><span class="c0"> "Mary" : { "status" : "single" } }</span></p><p class="c1"><span class="c0">modify (replace json value of $people("John")("status") with "married",</span></p><p class="c1"><span class="c0">        replace json value of $people("Mary")("status") with "married")</span></p><p class="c1"><span class="c0">return $people</span></p><p class="c10 c4 c1"><span class="c0"/></p><p class="c6 c1"><span class="c3 c0">{ "John" : { "status" : "married" }, "Mary" : { "status" : "married" } }</span></p><p class="c4 c1"><span/></p><p class="c1"><span>JSONiq works with the XQuery 3.0 standard (switch, typeswitch and try-catch expressions, universal/existential quantifiers, path expressions, filtering expressions, functors, mappings, grouping, windowing will work). The Zorba implementation is also compatible with the proprietary Zorba scripting.</span></p><p class="c4 c1"><span/></p><p class="c14 c1"><span>The complete JSONiq specification is available on </span><span class="c21"><a class="c20" href="http://jsoniq.org/">http://jsoniq.org/</a></span></p><p class="c4 c1"><span/></p></body></html>     </div>
</div>