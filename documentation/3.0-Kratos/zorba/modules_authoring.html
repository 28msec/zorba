<div class="doxygen">
  <div><h1 class="title">Writing Your Own Modules</h1>
Writing your own modules for Zorba is easy.This guide will cover writing a simple XQuery module; using Zorba's CMake-based build system to deploy the module; versioning your module; and writing a more complex module with external functions implemented in C++.<div id="mod_author_simple" class="sect1"><h2>Creating a Simple XQuery Module</h2>
A "module" is simply a library of XQuery functions and variables, usually which perform a set of related functions. Modules are defined by the XQuery language specification.A module exists in a particular <em>namespace</em>, which is identified by a URI. A module must start with a module <em>declaration</em>, which specifies the namespace URI and associates that URI with a prefix for easy reference.<pre class="ace-static" ace-mode="xquery"><span class="normal">module<span> </span></span><span class="keyword">namespace<span> </span></span><span class="normal">mymod<span> </span>=<span> </span></span><span class="stringliteral">"http://zorba.io/mymod"</span><span class="normal">;</span>
</pre>After the module declaration, you may have as many <em>function</em> or <em>variable</em> declarations as you like. All of the functions and variables you declare in the modules namespace will be made available to queries that <em>import</em> your module.Here we declare a module which exposes a string variable (and assign it a value), as well as two simple functions.<pre class="ace-static" ace-mode="xquery"><span class="normal">module<span> </span></span><span class="keyword">namespace<span> </span></span><span class="normal">mymod<span> </span>=<span> </span></span><span class="stringliteral">"http://zorba.io/mymod"</span><span class="normal">;</span>
<span class="normal"/>
<span class="normal">declare<span> </span>variable<span> </span>$mymod:value<span> </span><a href="/pages/3.0/zorba/namespacezorba_1_1locale_1_1iso639__1?anchor=aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0">as</a><span> </span>xs:</span><span class="keywordtype">string</span><span class="normal"><span> </span>:=<span> </span></span><span class="stringliteral">"my<span> </span>string<span> </span>value"</span><span class="normal">;</span>
<span class="normal"/>
<span class="normal">declare<span> </span></span><span class="keyword">function</span><span class="normal"><span> </span>mymod:hello()<span> </span><a href="/pages/3.0/zorba/namespacezorba_1_1locale_1_1iso639__1?anchor=aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0">as</a><span> </span>xs:</span><span class="keywordtype">string</span><span class="normal"><span> </span>{</span>
<span class="normal"><span> </span><span> </span></span><span class="stringliteral">"hello"</span><span class="normal"/>
<span class="normal">};</span>
<span class="normal"/>
<span class="normal">declare<span> </span></span><span class="keyword">function</span><span class="normal"><span> </span>mymod:</span><span class="keyword">get</span><span class="normal">-value()<span> </span><a href="/pages/3.0/zorba/namespacezorba_1_1locale_1_1iso639__1?anchor=aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0">as</a><span> </span>xs:</span><span class="keywordtype">string</span><span class="normal"><span> </span>{</span>
<span class="normal"><span> </span><span> </span>$mymod:value</span>
<span class="normal">};</span>
</pre>Assuming for the moment that this file is stored in the current working directory as <tt>mymod.xq</tt>, we can write a query which imports the module and uses one of its functions:<pre class="ace-static" ace-mode="xquery"><span class="keyword">import</span><span class="normal"><span> </span>module<span> </span></span><span class="keyword">namespace<span> </span></span><span class="normal">mymod=</span><span class="stringliteral">"http://zorba.io/mymod"</span><span class="normal"/>
<span class="normal"><span> </span><span> </span>at<span> </span></span><span class="stringliteral">"mymod.xq"</span><span class="normal">;</span>
<span class="normal"/>
<span class="normal">mymod:hello()</span>
</pre>If this query is in a file called <tt>query.xq</tt> in the current working directory, we can execute it:<pre class="ace-static" ace-mode="xquery"><span class="normal">%<span> </span>zorba<span> </span>-f<span> </span>-q<span> </span>query.xq</span>
<span class="normal">&lt;?xml<span> </span>version=</span><span class="stringliteral">"1.0"</span><span class="normal"><span> </span>encoding=</span><span class="stringliteral">"UTF-8"</span><span class="normal">?&gt;</span>
<span class="normal">hello</span>
</pre></div>
<div id="mod_author_project" class="sect1"><h2>Creating a CMake Module Project</h2>
As mentioned in <a href="/pages/3.0/zorba/modules_using?anchor=mod_importing">Importing Modules</a>, using the <tt>at "..."</tt> clauses when importing modules is best avoided. There are also many ways to expand upon this example, such as introducing versioning for our module; importing schemas; depending on other modules; writing external function implementations in C++; and creating test cases to ensure your module's functionality.Zorba offers a comprehensive system for module authors to do all of the above easily and consistently, utilizing the same build tool that Zorba itself utilizes: CMake (<a href="http://www.cmake.org/" target="_blank">http://www.cmake.org/</a>). If you plan to write Zorba modules for use by other developers, we strongly recommend creating a CMake project so that you may easily integrate with Zorba and other modules.(Note: the majority of this section is also relevant if you are developing an entire stand-alone application which uses Zorba as a library.)Assuming that you have cmake installed (it is available in most Linux distributions, and installers are available for Windows and MacOS - it is also part of MacPorts), creating a project for a Zorba module is very easy. First, in a new directory, copy the <tt>mymod.xq</tt> file from above, and create a file named <tt>CMakeLists.txt</tt>:<pre class="ace-static" ace-mode="xquery"><span class="preprocessor">#<span> </span>My<span> </span>Zorba<span> </span>Module<span> </span>Project</span>
<span class="preprocessor"/><span class="normal"/>
<span class="normal">PROJECT<span> </span>(my_zorba_module)</span>
<span class="normal">CMAKE_MINIMUM_REQUIRED<span> </span>(VERSION<span> </span>2.6)</span>
<span class="normal"/>
<span class="normal">FIND_PACKAGE<span> </span>(Zorba<span> </span>REQUIRED)</span>
<span class="normal">INCLUDE<span> </span>("${Zorba_USE_FILE}</span><span class="stringliteral">")</span>
<span class="stringliteral"/>
<span class="stringliteral">DECLARE_ZORBA_MODULE<span> </span>(FILE<span> </span>mymod.xq<span> </span>URI<span> </span>"</span><span class="normal">http:</span><span class="comment">//zorba.io/mymod")</span><span class="normal"/>
<span class="normal"/>
<span class="normal">DONE_DECLARING_ZORBA_URIS<span> </span>()</span>
</pre>This is the minimum required "boilerplate" for your CMake project. Here is a brief explanation for each line:<pre class="ace-static" ace-mode="xquery"><span class="preprocessor">#<span> </span>My<span> </span>Zorba<span> </span>Module<span> </span>Project</span>
</pre>This is a CMake comment.<pre class="ace-static" ace-mode="xquery"><span class="normal">PROJECT<span> </span>(my_zorba_module)</span>
</pre>CMake groups build environments into <em>projects</em>, which must have unique names. The name can be anything you like, but should be descriptive. In future, if other module projects depend on your module project, they will use this name to identify it.<pre class="ace-static" ace-mode="xquery"><span class="normal">CMAKE_MINIMUM_REQUIRED<span> </span>(VERSION<span> </span>2.6)</span>
</pre>CMake has introduced many new features over time; Zorba's CMake support requires at least CMake version 2.6. Without the above line, your project will still work (assuming you are in fact using at least CMake 2.6), but will display a warning.<pre class="ace-static" ace-mode="xquery"><span class="normal">FIND_PACKAGE<span> </span>(Zorba<span> </span>REQUIRED)</span>
<span class="normal">INCLUDE<span> </span>(</span><span class="stringliteral">"${Zorba_USE_FILE}"</span><span class="normal">)</span>
</pre>CMake has an exhaustive facility for introspecting your development environment and finding dependencies. The <tt>FIND_PACKAGE()</tt> command will search for many things, including other CMake projects such as Zorba. Zorba ships CMake configuration files allowing it to be found in this way, and these configuration files tell our project where Zorba is located as well as setting a number of other useful variables describing the Zorba environment.One such variable, <tt>${Zorba_USE_FILE}</tt>, is a pointer to a CMake script containing a variety of utility CMake macros that are very useful when developing modules. By using <tt>INCLUDE()</tt> to load this file, we gain access to everything we need to build our module. (This "use file" technique is a convention for CMake projects.)<pre class="ace-static" ace-mode="xquery"><span class="normal">DECLARE_ZORBA_MODULE<span> </span>(FILE<span> </span>mymod.xq<span> </span>URI<span> </span></span><span class="stringliteral">"http://zorba.io/mymod"</span><span class="normal">)</span>
</pre><tt>DECLARE_ZORBA_MODULE()</tt> is the centerpiece of the Zorba module development environment; most of the rest of this guide will be describing how to use it in detail.<pre class="ace-static" ace-mode="xquery"><span class="normal">DONE_DECLARING_ZORBA_URIS()</span>
</pre>This must be the last thing called by your top-level <tt>CMakeLists.txt</tt> file. It collects all the information provided by earlier calls to <tt>DECLARE_ZORBA_MODULE()</tt> (and its sister macro, <tt>DECLARE_ZORBA_SCHEMA()</tt>, described later) and generates all the necessary build system rules and targets.</div>
<div id="mod_author_building" class="sect1"><h2>Building the Module Project</h2>
You have created a small but complete Zorba module CMake project. Now, the project must be built. One of the great things about CMake is that it is capable of creating build environments for a number of different tools. On Unix systems (include Windows with Cygwin), it can create a Makefile-based environment. It can also create projects for the KDevelop, Code::Blocks, and QtCreator IDEs, among others, and has some support for Eclipse as well. On MacOS, it can create Xcode projects. On Windows, it can create Visual Studio projects, and it can also create a Makefile-based environment for use with Visual Studio's nmake utility. See CMake's documentation for more details and other supported build environments.This guide will focus on a Makefile environment, but it should be equally applicable to all others.CMake encourages the use of "out-of-source" builds; that is, all files that are generated by the build are created in a directory which is separate from the source code. This is good practice. One common convention is to create a directory named <tt>build</tt> as a subdirectory of the top-level directory of the project, so from the command-line, execute the following commands from your project directory:<pre class="ace-static" ace-mode="xquery"><span class="normal">mkdir<span> </span>build</span>
<span class="normal">cd<span> </span>build</span>
<span class="normal">cmake<span> </span>..</span>
</pre>The <tt>cmake ..</tt> command tells CMake to create a build environment based on the source directory <tt>..</tt>, that is, the parent directory. You could also create your build directory anywhere on the system, in which case, you simply provide the full absolute or relative path to your source directory as the argument to <tt>cmake</tt>.If you have Zorba installed in a standard system-wide location, the above will likely be all you need to do. However, if the <tt>cmake</tt> step does not find Zorba, you can point CMake in the right direction like this:<pre class="ace-static" ace-mode="xquery"><span class="normal">cmake<span> </span>-DCMAKE_PREFIX_PATH=/path/<a href="/pages/3.0/zorba/namespacezorba_1_1locale_1_1iso639__1?anchor=aafd6e55905dc8efe50a3f9fd38616781a0f4527a84781e2e19c9796b2b7fcacba">to</a>/zorbaroot<span> </span>..</span>
</pre>"zorbaroot" is the root directory of a Zorba installation; it should contain <tt>bin/zorba</tt> (<tt>bin/zorba.exe</tt> on Windows) among other files.The default build configuration for CMake is "Unix Makefiles". If you are building using a different tool set, you must provide the <tt>-G</tt> option to <tt>cmake</tt>. For example, if you wish to create a Visual Studio 10 project, use:<pre class="ace-static" ace-mode="xquery"><span class="normal">cmake<span> </span>-G</span><span class="stringliteral">"Visual<span> </span>Studio<span> </span>10"</span><span class="normal"><span> </span>..</span>
</pre>No matter what your eventual <tt>cmake</tt> command line ends up being, the nice thing is you will only need to execute it once. From that point on, you can simply invoke the default build target in whatever build environment you have created. CMake sets up all dependencies correctly, and will automatically re-invoke itself if you modify the <tt>CMakeLists.txt</tt> file or make any other changes which would require <tt>cmake</tt> to generate the build environment again.So, go ahead and build! For Unix Makefiles, just type:<pre class="ace-static" ace-mode="xquery"><span class="normal">make</span>
</pre></div>
<div id="mod_author_built" class="sect1"><h2>What Happens When You Build?</h2>
For this very simple module project, not much happens when you build. You will probably see output similar to this:<pre class="ace-static" ace-mode="xquery"><span class="normal">Scanning<span> </span>dependencies<span> </span>of<span> </span>target<span> </span>check_uris</span>
<span class="normal">[<span> </span><span> </span>0%]<span> </span>Copying<span> </span>/tmp/myproject/mymod.xq<span> </span><a href="/pages/3.0/zorba/namespacezorba_1_1locale_1_1iso639__1?anchor=aafd6e55905dc8efe50a3f9fd38616781a0f4527a84781e2e19c9796b2b7fcacba">to</a><span> </span>URI<span> </span>path</span>
<span class="normal">[100%]<span> </span>Built<span> </span>target<span> </span>check_uris</span>
</pre>The primary result of building this project is that a directory named (by default) <tt>URI_PATH</tt> will be created in your build directory, containing all of your declared modules and schemas in an appropriate directory structure for Zorba's URI resolution mechanism (see <a href="/pages/3.0/zorba/uriresolvers">URI Resolvers</a>). This means that we can eliminate the <tt>at "..."</tt> clause from our test query which imports this module:<pre class="ace-static" ace-mode="xquery"><span class="keyword">import</span><span class="normal"><span> </span>module<span> </span></span><span class="keyword">namespace<span> </span></span><span class="normal">"http:</span><span class="comment">//zorba.io/mymod";</span><span class="normal"/>
<span class="normal"/>
<span class="normal">mymod:hello()</span>
</pre>and then execute Zorba as follows:<pre class="ace-static" ace-mode="xquery"><span class="normal">%<span> </span>zorba<span> </span>--uri-path<span> </span>/tmp/myproject/build/URI_PATH<span> </span>-f<span> </span>-q<span> </span>query.xq</span>
<span class="normal">&lt;?xml<span> </span>version=</span><span class="stringliteral">"1.0"</span><span class="normal"><span> </span>encoding=</span><span class="stringliteral">"UTF-8"</span><span class="normal">?&gt;</span>
<span class="normal">hello</span>
</pre>By providing this one <tt>--uri-path</tt> argument, Zorba will automatically be able to load any of our modules or schemas by URI, rather than requiring explicit filesystem paths to them. This makes it much easier to develop larger XQuery applications, because the entire application can be moved around easily, and you won't need to edit all of your queries to change the paths to load your modules as you move from development to production.<a href="/pages/3.0/zorba/modules_authoring_2">Module Authoring, Continued</a><a href="/pages/3.0/zorba/modules_building_in">Building Modules Into Zorba</a> </div>
    </div>
</div>