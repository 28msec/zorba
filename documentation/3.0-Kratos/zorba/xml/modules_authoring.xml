<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="modules_authoring" kind="page">
    <compoundname>modules_authoring</compoundname>
    <title>Writing Your Own Modules</title>
    <detaileddescription>
<para>Writing your own modules for Zorba is easy.</para><para>This guide will cover writing a simple XQuery module; using Zorba&apos;s CMake-based build system to deploy the module; versioning your module; and writing a more complex module with external functions implemented in C++.</para><sect1 id="modules_authoring_1mod_author_simple">
<title>Creating a Simple XQuery Module</title>
<para>A &quot;module&quot; is simply a library of XQuery functions and variables, usually which perform a set of related functions. Modules are defined by the XQuery language specification.</para><para>A module exists in a particular <emphasis>namespace</emphasis>, which is identified by a URI. A module must start with a module <emphasis>declaration</emphasis>, which specifies the namespace URI and associates that URI with a prefix for easy reference.</para><para><programlisting><codeline><highlight class="normal">module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">mymod<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/mymod&quot;</highlight><highlight class="normal">;</highlight></codeline>
</programlisting></para><para>After the module declaration, you may have as many <emphasis>function</emphasis> or <emphasis>variable</emphasis> declarations as you like. All of the functions and variables you declare in the modules namespace will be made available to queries that <emphasis>import</emphasis> your module.</para><para>Here we declare a module which exposes a string variable (and assign it a value), as well as two simple functions.</para><para><programlisting><codeline><highlight class="normal">module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">mymod<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/mymod&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">declare<sp/>variable<sp/>$mymod:value<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>:=<sp/></highlight><highlight class="stringliteral">&quot;my<sp/>string<sp/>value&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">declare<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>mymod:hello()<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="stringliteral">&quot;hello&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">declare<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>mymod:</highlight><highlight class="keyword">get</highlight><highlight class="normal">-value()<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>$mymod:value</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>Assuming for the moment that this file is stored in the current working directory as <computeroutput>mymod.xq</computeroutput>, we can write a query which imports the module and uses one of its functions:</para><para><programlisting><codeline><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">mymod=</highlight><highlight class="stringliteral">&quot;http://zorba.io/mymod&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>at<sp/></highlight><highlight class="stringliteral">&quot;mymod.xq&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">mymod:hello()</highlight></codeline>
</programlisting></para><para>If this query is in a file called <computeroutput>query.xq</computeroutput> in the current working directory, we can execute it:</para><para><programlisting><codeline><highlight class="normal">%<sp/>zorba<sp/>-f<sp/>-q<sp/>query.xq</highlight></codeline>
<codeline><highlight class="normal">&lt;?xml<sp/>version=</highlight><highlight class="stringliteral">&quot;1.0&quot;</highlight><highlight class="normal"><sp/>encoding=</highlight><highlight class="stringliteral">&quot;UTF-8&quot;</highlight><highlight class="normal">?&gt;</highlight></codeline>
<codeline><highlight class="normal">hello</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="modules_authoring_1mod_author_project">
<title>Creating a CMake Module Project</title>
<para>As mentioned in <ref refid="modules_using_1mod_importing" kindref="member">Importing Modules</ref>, using the <computeroutput>at &quot;...&quot;</computeroutput> clauses when importing modules is best avoided. There are also many ways to expand upon this example, such as introducing versioning for our module; importing schemas; depending on other modules; writing external function implementations in C++; and creating test cases to ensure your module&apos;s functionality.</para><para>Zorba offers a comprehensive system for module authors to do all of the above easily and consistently, utilizing the same build tool that Zorba itself utilizes: CMake (<ulink url="http://www.cmake.org/">http://www.cmake.org/</ulink>). If you plan to write Zorba modules for use by other developers, we strongly recommend creating a CMake project so that you may easily integrate with Zorba and other modules.</para><para>(Note: the majority of this section is also relevant if you are developing an entire stand-alone application which uses Zorba as a library.)</para><para>Assuming that you have cmake installed (it is available in most Linux distributions, and installers are available for Windows and MacOS - it is also part of MacPorts), creating a project for a Zorba module is very easy. First, in a new directory, copy the <computeroutput>mymod.xq</computeroutput> file from above, and create a file named <computeroutput>CMakeLists.txt</computeroutput>:</para><para><programlisting><codeline><highlight class="preprocessor">#<sp/>My<sp/>Zorba<sp/>Module<sp/>Project</highlight></codeline>
<codeline><highlight class="preprocessor"></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">PROJECT<sp/>(my_zorba_module)</highlight></codeline>
<codeline><highlight class="normal">CMAKE_MINIMUM_REQUIRED<sp/>(VERSION<sp/>2.6)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">FIND_PACKAGE<sp/>(Zorba<sp/>REQUIRED)</highlight></codeline>
<codeline><highlight class="normal">INCLUDE<sp/>(&quot;${Zorba_USE_FILE}</highlight><highlight class="stringliteral">&quot;)</highlight></codeline>
<codeline><highlight class="stringliteral"></highlight></codeline>
<codeline><highlight class="stringliteral">DECLARE_ZORBA_MODULE<sp/>(FILE<sp/>mymod.xq<sp/>URI<sp/>&quot;</highlight><highlight class="normal">http:</highlight><highlight class="comment">//zorba.io/mymod&quot;)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">DONE_DECLARING_ZORBA_URIS<sp/>()</highlight></codeline>
</programlisting></para><para>This is the minimum required &quot;boilerplate&quot; for your CMake project. Here is a brief explanation for each line:</para><para><programlisting><codeline><highlight class="preprocessor">#<sp/>My<sp/>Zorba<sp/>Module<sp/>Project</highlight></codeline>
</programlisting></para><para>This is a CMake comment.</para><para><programlisting><codeline><highlight class="normal">PROJECT<sp/>(my_zorba_module)</highlight></codeline>
</programlisting></para><para>CMake groups build environments into <emphasis>projects</emphasis>, which must have unique names. The name can be anything you like, but should be descriptive. In future, if other module projects depend on your module project, they will use this name to identify it.</para><para><programlisting><codeline><highlight class="normal">CMAKE_MINIMUM_REQUIRED<sp/>(VERSION<sp/>2.6)</highlight></codeline>
</programlisting></para><para>CMake has introduced many new features over time; Zorba&apos;s CMake support requires at least CMake version 2.6. Without the above line, your project will still work (assuming you are in fact using at least CMake 2.6), but will display a warning.</para><para><programlisting><codeline><highlight class="normal">FIND_PACKAGE<sp/>(Zorba<sp/>REQUIRED)</highlight></codeline>
<codeline><highlight class="normal">INCLUDE<sp/>(</highlight><highlight class="stringliteral">&quot;${Zorba_USE_FILE}&quot;</highlight><highlight class="normal">)</highlight></codeline>
</programlisting></para><para>CMake has an exhaustive facility for introspecting your development environment and finding dependencies. The <computeroutput>FIND_PACKAGE()</computeroutput> command will search for many things, including other CMake projects such as Zorba. Zorba ships CMake configuration files allowing it to be found in this way, and these configuration files tell our project where Zorba is located as well as setting a number of other useful variables describing the Zorba environment.</para><para>One such variable, <computeroutput>${Zorba_USE_FILE}</computeroutput>, is a pointer to a CMake script containing a variety of utility CMake macros that are very useful when developing modules. By using <computeroutput>INCLUDE()</computeroutput> to load this file, we gain access to everything we need to build our module. (This &quot;use file&quot; technique is a convention for CMake projects.)</para><para><programlisting><codeline><highlight class="normal">DECLARE_ZORBA_MODULE<sp/>(FILE<sp/>mymod.xq<sp/>URI<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/mymod&quot;</highlight><highlight class="normal">)</highlight></codeline>
</programlisting></para><para><computeroutput>DECLARE_ZORBA_MODULE()</computeroutput> is the centerpiece of the Zorba module development environment; most of the rest of this guide will be describing how to use it in detail.</para><para><programlisting><codeline><highlight class="normal">DONE_DECLARING_ZORBA_URIS()</highlight></codeline>
</programlisting></para><para>This must be the last thing called by your top-level <computeroutput>CMakeLists.txt</computeroutput> file. It collects all the information provided by earlier calls to <computeroutput>DECLARE_ZORBA_MODULE()</computeroutput> (and its sister macro, <computeroutput>DECLARE_ZORBA_SCHEMA()</computeroutput>, described later) and generates all the necessary build system rules and targets.</para></sect1>
<sect1 id="modules_authoring_1mod_author_building">
<title>Building the Module Project</title>
<para>You have created a small but complete Zorba module CMake project. Now, the project must be built. One of the great things about CMake is that it is capable of creating build environments for a number of different tools. On Unix systems (include Windows with Cygwin), it can create a Makefile-based environment. It can also create projects for the KDevelop, Code::Blocks, and QtCreator IDEs, among others, and has some support for Eclipse as well. On MacOS, it can create Xcode projects. On Windows, it can create Visual Studio projects, and it can also create a Makefile-based environment for use with Visual Studio&apos;s nmake utility. See CMake&apos;s documentation for more details and other supported build environments.</para><para>This guide will focus on a Makefile environment, but it should be equally applicable to all others.</para><para>CMake encourages the use of &quot;out-of-source&quot; builds; that is, all files that are generated by the build are created in a directory which is separate from the source code. This is good practice. One common convention is to create a directory named <computeroutput>build</computeroutput> as a subdirectory of the top-level directory of the project, so from the command-line, execute the following commands from your project directory:</para><para><programlisting><codeline><highlight class="normal">mkdir<sp/>build</highlight></codeline>
<codeline><highlight class="normal">cd<sp/>build</highlight></codeline>
<codeline><highlight class="normal">cmake<sp/>..</highlight></codeline>
</programlisting></para><para>The <computeroutput>cmake ..</computeroutput> command tells CMake to create a build environment based on the source directory <computeroutput>..</computeroutput>, that is, the parent directory. You could also create your build directory anywhere on the system, in which case, you simply provide the full absolute or relative path to your source directory as the argument to <computeroutput>cmake</computeroutput>.</para><para>If you have Zorba installed in a standard system-wide location, the above will likely be all you need to do. However, if the <computeroutput>cmake</computeroutput> step does not find Zorba, you can point CMake in the right direction like this:</para><para><programlisting><codeline><highlight class="normal">cmake<sp/>-DCMAKE_PREFIX_PATH=/path/<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a0f4527a84781e2e19c9796b2b7fcacba" kindref="member" tooltip="Tonga.">to</ref>/zorbaroot<sp/>..</highlight></codeline>
</programlisting></para><para>&quot;zorbaroot&quot; is the root directory of a Zorba installation; it should contain <computeroutput>bin/zorba</computeroutput> (<computeroutput>bin/zorba.exe</computeroutput> on Windows) among other files.</para><para>The default build configuration for CMake is &quot;Unix Makefiles&quot;. If you are building using a different tool set, you must provide the <computeroutput>-G</computeroutput> option to <computeroutput>cmake</computeroutput>. For example, if you wish to create a Visual Studio 10 project, use:</para><para><programlisting><codeline><highlight class="normal">cmake<sp/>-G</highlight><highlight class="stringliteral">&quot;Visual<sp/>Studio<sp/>10&quot;</highlight><highlight class="normal"><sp/>..</highlight></codeline>
</programlisting></para><para>No matter what your eventual <computeroutput>cmake</computeroutput> command line ends up being, the nice thing is you will only need to execute it once. From that point on, you can simply invoke the default build target in whatever build environment you have created. CMake sets up all dependencies correctly, and will automatically re-invoke itself if you modify the <computeroutput>CMakeLists.txt</computeroutput> file or make any other changes which would require <computeroutput>cmake</computeroutput> to generate the build environment again.</para><para>So, go ahead and build! For Unix Makefiles, just type:</para><para><programlisting><codeline><highlight class="normal">make</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="modules_authoring_1mod_author_built">
<title>What Happens When You Build?</title>
<para>For this very simple module project, not much happens when you build. You will probably see output similar to this:</para><para><programlisting><codeline><highlight class="normal">Scanning<sp/>dependencies<sp/>of<sp/>target<sp/>check_uris</highlight></codeline>
<codeline><highlight class="normal">[<sp/><sp/>0%]<sp/>Copying<sp/>/tmp/myproject/mymod.xq<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a0f4527a84781e2e19c9796b2b7fcacba" kindref="member" tooltip="Tonga.">to</ref><sp/>URI<sp/>path</highlight></codeline>
<codeline><highlight class="normal">[100%]<sp/>Built<sp/>target<sp/>check_uris</highlight></codeline>
</programlisting></para><para>The primary result of building this project is that a directory named (by default) <computeroutput>URI_PATH</computeroutput> will be created in your build directory, containing all of your declared modules and schemas in an appropriate directory structure for Zorba&apos;s URI resolution mechanism (see <ref refid="uriresolvers" kindref="compound">URI Resolvers</ref>). This means that we can eliminate the <computeroutput>at &quot;...&quot;</computeroutput> clause from our test query which imports this module:</para><para><programlisting><codeline><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">&quot;http:</highlight><highlight class="comment">//zorba.io/mymod&quot;;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">mymod:hello()</highlight></codeline>
</programlisting></para><para>and then execute Zorba as follows:</para><para><programlisting><codeline><highlight class="normal">%<sp/>zorba<sp/>--uri-path<sp/>/tmp/myproject/build/URI_PATH<sp/>-f<sp/>-q<sp/>query.xq</highlight></codeline>
<codeline><highlight class="normal">&lt;?xml<sp/>version=</highlight><highlight class="stringliteral">&quot;1.0&quot;</highlight><highlight class="normal"><sp/>encoding=</highlight><highlight class="stringliteral">&quot;UTF-8&quot;</highlight><highlight class="normal">?&gt;</highlight></codeline>
<codeline><highlight class="normal">hello</highlight></codeline>
</programlisting></para><para>By providing this one <computeroutput>--uri-path</computeroutput> argument, Zorba will automatically be able to load any of our modules or schemas by URI, rather than requiring explicit filesystem paths to them. This makes it much easier to develop larger XQuery applications, because the entire application can be moved around easily, and you won&apos;t need to edit all of your queries to change the paths to load your modules as you move from development to production.</para><para><ref refid="modules_authoring_2" kindref="compound">Module Authoring, Continued</ref></para><para><ref refid="modules_building_in" kindref="compound">Building Modules Into Zorba</ref> </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
