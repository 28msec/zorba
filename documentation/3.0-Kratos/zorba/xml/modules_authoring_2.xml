<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="modules_authoring_2" kind="page">
    <compoundname>modules_authoring_2</compoundname>
    <title>Module Authoring, Continued</title>
    <detaileddescription>
<sect1 id="modules_authoring_2_1mod_author_declare">
<title>Basics of DECLARE_ZORBA_MODULE()</title>
<para>This simple module example uses two of the arguments to <computeroutput>DECLARE_ZORBA_MODULE()</computeroutput>, namely <computeroutput>FILE</computeroutput> and <computeroutput>URI</computeroutput>. These are in fact the only required arguments. (By the way, all arguments may appear in any order.)</para><para>The <computeroutput>FILE</computeroutput> argument takes a single value, which is the path to the <computeroutput>.xq</computeroutput> for the module. If this is a relative path, it will be resolved relative to the current source directory (that is, the directory containing <computeroutput>CMakeLists.txt</computeroutput>). It may also be an absolute path. It is not required to put double-quotes around the value unless the path contains space characters (this is true of all CMake values). However, if your path includes any CMake variable references, such as <computeroutput>&quot;${CMAKE_CURRENT_SOURCE_DIR}/mymod.xq&quot;</computeroutput>, then it is good practice to surround the value with double-quotes in case the variable ever contains space characters in future.</para><para>The <computeroutput>URI</computeroutput> argument also takes a single value, which is the namespace URI of the module file. Note that it is very important that this URI matches the <computeroutput>module namespace</computeroutput> URI in the <computeroutput>.xq</computeroutput> file itself. Currently the CMake macros are not advanced enough to parse the XQuery file and verify that this is true.</para><para>As URIs cannot contain space characters, it is not necessary to surround the value with double-quotes. However, you may do so if it makes the statement more readable for you.</para><para>A note: the filename of your module (as passed to <computeroutput>FILE</computeroutput>) may be anything you like. It does not have to have anything in common with the namespace URI. Conventionally, it will be the final component of your URI with &quot;.xq&quot; appended, as in our example where the filename for the namespace URI <computeroutput><ulink url="http://zorba.io/mymod">http://zorba.io/mymod</ulink></computeroutput> was <computeroutput>mymod.xq</computeroutput>. This is a good convention, because once the module is <emphasis>installed</emphasis> into the <computeroutput>URI_PATH</computeroutput> directory or elsewhere, this is the filename it will have. However, it is not required.</para></sect1>
<sect1 id="modules_authoring_2_1mod_author_versioning">
<title>Introducing Versioning</title>
<para>Zorba extends XQuery by offering versioned access to modules (see <ref refid="modules_using_1mod_versioning" kindref="member">Versioning Modules</ref>). Adding versioning to your modules is very easy. There are two steps: Adding the <computeroutput>module-version</computeroutput> declaration to your module source code; and passing the <computeroutput>VERSION</computeroutput> argument to <computeroutput>DECLARE_ZORBA_MODULE</computeroutput>.</para><sect2 id="modules_authoring_2_1mod_auth_vers_option">
<title>The module-version Option</title>
<para>Zorba looks for an XQuery option to define the version of the module. XQuery options are identified by a QName. The specific QName Zorba looks for has the localname <computeroutput>module-version</computeroutput>, and is located in the namespace <computeroutput><ulink url="http://zorba.io/options/versioning">http://zorba.io/options/versioning</ulink></computeroutput>. Therefore, put the following two lines into your module, after the module declaration:</para><para><programlisting><codeline><highlight class="normal">declare<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">ver<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/options/versioning&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">declare<sp/>option<sp/>ver:module-version<sp/></highlight><highlight class="stringliteral">&quot;1.0&quot;</highlight><highlight class="normal">;</highlight></codeline>
</programlisting></para><para>Note: As your module grows more complex, you may find that you need to separate the above two lines. The XQuery language requires that all <emphasis>namespace declarations</emphasis> and <emphasis>import statements</emphasis> (<computeroutput>import module</computeroutput> and <computeroutput>import schema</computeroutput>) must occur before any <emphasis>variable</emphasis>, <emphasis>function</emphasis>, or <emphasis>option</emphasis> declarations. So the namespace declaration may end up being earlier in the file than the option declaration. This is fine.</para><para>Also note that, while the XQuery language allows you to have your variable, function, and option declarations in any order, Zorba requires the <computeroutput>module-version</computeroutput> option to be declared before any variables or functions in order to function correctly.</para></sect2>
<sect2 id="modules_authoring_2_1mod_auth_vers_declare">
<title>The VERSION Argument to DECLARE_ZORBA_MODULE()</title>
<para>Now you must also tell <computeroutput>DECLARE_ZORBA_MODULE()</computeroutput> the version of the module, so that it can copy it to the correct locations on the URI path. As with the <computeroutput>URI</computeroutput> argument, it is important that this matches the actual version as declared in the <computeroutput>.xq</computeroutput> file.</para><para><programlisting><codeline><highlight class="normal">DECLARE_ZORBA_MODULE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(FILE<sp/>mymod.xq<sp/>URI<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/mymod&quot;</highlight><highlight class="normal"><sp/>VERSION<sp/>1.0)</highlight></codeline>
</programlisting></para><para>As with <computeroutput>URI</computeroutput>, version numbers cannot contain space characters, and therefore double-quotes surrounding the value are optional.</para><para>That&apos;s it! Now query authors can import your module using the version fragment, as discussed in <ref refid="modules_using_1mod_versioning" kindref="member">Versioning Modules</ref>.</para><para>You may declare multiple versions of the same module (that is, with the same namespace URI), so that you can for instance maintain and contine to ship version 1.x of your module even after you have developed version 2.x. However, there is one limitation to <computeroutput>DECLARE_ZORBA_MODULE()</computeroutput> regarding this: You must ensure that you declare all versions of the same module in <emphasis>decreasing version number order</emphasis>, that is, starting with the highest version number and working backwards. So, for example, if you are shipping versions 3.1, 2.4, and 1.6 of your module, you may have:</para><para><programlisting><codeline><highlight class="normal">DECLARE_ZORBA_MODULE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(FILE<sp/>mymod-3.xq<sp/>URI<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/mymod&quot;</highlight><highlight class="normal"><sp/>VERSION<sp/>3.1)</highlight></codeline>
<codeline><highlight class="normal">DECLARE_ZORBA_MODULE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(FILE<sp/>mymod-2.xq<sp/>URI<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/mymod&quot;</highlight><highlight class="normal"><sp/>VERSION<sp/>2.4)</highlight></codeline>
<codeline><highlight class="normal">DECLARE_ZORBA_MODULE</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(FILE<sp/>mymod-1.xq<sp/>URI<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/mymod&quot;</highlight><highlight class="normal"><sp/>VERSION<sp/>1.6)</highlight></codeline>
</programlisting></para><para>If you do this incorrectly (out of order), you will get an error when you invoke CMake, so it is not possible to accidentally do it wrong.</para><para>(Note that the above example also demonstrates, as noted earlier, that the filename of your module <computeroutput>.xq</computeroutput> file need not directly correspond with the namespace URI. You may use different filenames for supporting different versions if you wish.)</para><para>Finally, note that if you declare a module <emphasis>without</emphasis> a VERSION argument, it will internally be treated as though the version was &quot;0.0.0&quot;.</para></sect2>
</sect1>
<sect1 id="modules_authoring_2_1mod_author_schemas">
<title>Adding schemas</title>
<para>If you develop modules that make use of your own XML Schemas, then you should keep those schemas as part of your module project and install them. Zorba provides a macro <computeroutput>DECLARE_ZORBA_SCHEMA()</computeroutput> for this purpose, which works almost identically to <computeroutput>DECLARE_ZORBA_MODULE()</computeroutput>:</para><para><programlisting><codeline><highlight class="normal">DECLARE_ZORBA_SCHEMA</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(URI<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/myschema&quot;</highlight><highlight class="normal"><sp/>FILE<sp/></highlight><highlight class="stringliteral">&quot;schema.xsd&quot;</highlight><highlight class="normal">)</highlight></codeline>
</programlisting></para><para>The semantics and meanings of the <computeroutput>URI</computeroutput> and <computeroutput>FILE</computeroutput> arguments are the same.</para><para>One important distinction is that Zorba does not currently support versioning of schemas, so there is no <computeroutput>VERSION</computeroutput> argument to <computeroutput>DECLARE_ZORBA_SCHEMA()</computeroutput>. We hope to add this functionality in a later release.</para></sect1>
<sect1 id="modules_authoring_2_1mod_author_testing">
<title>Writing Tests</title>
<para>Now that you&apos;ve written a module, it would be a great idea to write some test cases for it to ensure that later changes don&apos;t break any functionality. (In fact, if you subscribe to the Test-Driven Development philosophy, you probably want to write the tests first!) Zorba ships a testdriver program and macros to easily add XQuery-based tests to your project.</para><sect2 id="modules_authoring_2_1mod_author_testing_basic">
<title>Basic Testing</title>
<para>The basic steps are:</para><para>1. Create a test directory with two subdirectories named &quot;Queries&quot; and &quot;ExpQueryResults&quot;. Here we assume that directory is named <computeroutput>tests</computeroutput> and is located at the top of your project.</para><para>2. Inside <computeroutput>Queries</computeroutput>, create XQueries in files with the extension <computeroutput>.xq</computeroutput>. You may use any directory structure you like inside this directory to organize your test queries.</para><para>3. Inside <computeroutput>ExpQueryResults</computeroutput>, create expected results files for your queries with the extension <computeroutput>.xml.res</computeroutput>. The directory structure should be exactly the same as inside <computeroutput>Queries</computeroutput>. For instance, if you have a test in the file <computeroutput>tests/Queries/feature-A/test-1.xq</computeroutput>, then the expected results should be in <computeroutput>tests/ExpQueryResults/feature-A/test-1.xml.res</computeroutput>.</para><para>4. In your <computeroutput>CMakeLists.txt</computeroutput>, add the following lines near the top - for example right after the <computeroutput>PROJECT (...)</computeroutput> line:</para><para><programlisting><codeline><highlight class="normal">ENABLE_TESTING<sp/>()</highlight></codeline>
<codeline><highlight class="normal">INCLUDE<sp/>(CTest)</highlight></codeline>
</programlisting></para><para>5. Finally, elsewhere in your <computeroutput>CMakeLists.txt</computeroutput>, add:</para><para><programlisting><codeline><highlight class="normal">ADD_TEST_DIRECTORY<sp/>(tests)</highlight></codeline>
</programlisting></para><para>That&apos;s it! Now, from your build directory, after re-building your project, you can run all your tests by simply executing the command <computeroutput>ctest</computeroutput>. CTest is a testing framework that ships with CMake. It has a great many features, but the two most important command-line options are:</para><para>1. <computeroutput>ctest -R [pattern]</computeroutput> will execute only those tests whose name matches the given pattern. Since <computeroutput>ADD_TEST_DIRECTORY()</computeroutput> creates the test names based on the directory structure under <computeroutput>Queries</computeroutput>, this makes it easy to run a subset of your tests. For instance, <computeroutput>ctest -R feature-A</computeroutput> will run all the tests in the &quot;feature-A&quot; directory.</para><para>2. <computeroutput>ctest -V</computeroutput> will show the output of the tests, rather than just a synopsis of the results. This is useful when debugging. Since the output of testdriver is fairly verbose, it is best to combine <computeroutput>-V</computeroutput> with a <computeroutput>-R</computeroutput> option that limits ctest to exactly one test; for example: <computeroutput>ctest -V -R feature-A/test-1</computeroutput>.</para></sect2>
<sect2 id="modules_authoring_2_1mod_author_testing_advanced">
<title>More Advanced Testing</title>
<para>Zorba&apos;s testdriver has several other features - it is actually the same test program used by Zorba itself both for its own internal testing as well as running the W3C&apos;s XQuery Test Suite conformance suite, which has a number of complex requirements.</para><para>testdriver activates additional features when a test query has a corresponding <computeroutput>.spec</computeroutput> file. This is a file in the same directory as an <computeroutput>.xq</computeroutput> test query, with the same file name but a <computeroutput>.spec</computeroutput> extension. For instance, for the test mentioned in step 3 above, the spec file would be <computeroutput>tests/Queries/feature-A/test-1.spec</computeroutput>. We will briefly document the two most useful features here.</para><para>1. Negative tests: If you would like to test error conditions, you can add a line such as the following to your .spec file:</para><para><programlisting><codeline><highlight class="normal"><ref refid="namespacezorba_1a0299a82ee3cd6825cc41a5794e257c48" kindref="member">Error</ref>:<sp/>http:</highlight><highlight class="comment">//www.w3.org/2005/xqt-errors:XPTY0004</highlight></codeline>
</programlisting></para><para>This tells testdriver to expect that the query will raise an error with the given QName. If any other error, or no error at all, is raised, then the test will fail. In this case, it is not necessary to have an expected results <computeroutput>.xml.res</computeroutput> file, as the expected result is instead the error.</para><para>2. Binding external variables: If your query has external variables, you may bind them with lines in your .spec file such as the following:</para><para><programlisting><codeline><highlight class="normal">Args:</highlight></codeline>
<codeline><highlight class="normal">-x</highlight></codeline>
<codeline><highlight class="normal">var:=value</highlight></codeline>
</programlisting></para><para>(Unfortunately, it is necessary to put the above assignment exactly as shown, on three separate lines in the .spec file.)</para><para>This will bind the string value &quot;value&quot; to the variable <computeroutput>$var</computeroutput> in the query.</para><para>You may also bind an XML file as a document variable by using &quot;=&quot; instead of &quot;:=&quot; in the assignment:</para><para><programlisting><codeline><highlight class="normal">Args:</highlight></codeline>
<codeline><highlight class="normal">-x</highlight></codeline>
<codeline><highlight class="normal">var=$RBKT_SRC_DIR/input.xml</highlight></codeline>
</programlisting></para><para>This will parse the specified XML file and bind the resulting document node to the variable <computeroutput>$var</computeroutput>.</para><para>The expression <computeroutput>$RBKT_SRC_DIR</computeroutput> will be replaced by the full path to the directory that was originally passed to <computeroutput>ADD_TEST_DIRECTORY()</computeroutput>. (The named <computeroutput>$RBKT_SRC_DIR</computeroutput> is a strange historical artifact of the early days of Zorba testing.)</para></sect2>
</sect1>
<sect1 id="modules_authoring_2_1mod_author_cpp">
<title>External Functions in C++</title>
<para>The final advanced feature of <computeroutput>DECLARE_ZORBA_MODULE</computeroutput> is building a dynamic library for any external module functions that are implemented in C++. For information about actually writing these functions, see <ref refid="external_functions" kindref="compound">Writing Your Own External Functions</ref>. Here we describe how <computeroutput>DECLARE_ZORBA_MODULE()</computeroutput> automates the building and distributing of these libraries.</para><para>If you have a module with external function declarations named <computeroutput>module.xq</computeroutput>, then you simply create a subdirectory named <computeroutput>module.xq.src</computeroutput> in the same directory as the <computeroutput>.xq</computeroutput> file. <computeroutput>DECLARE_ZORBA_MODULE()</computeroutput> will identify this directory and:</para><para>1. Add build rules to your project that compiles all <computeroutput>.cpp</computeroutput> files in the <computeroutput>.xq.src</computeroutput> directory (or any subdirectories of that directory)</para><para>2. Link them together into an appropriately-named shared library for your operating system</para><para>3. Copy the resulting shared library into <programlisting><codeline><highlight class="normal">&lt;build_dir&gt;/LIB_PATH</highlight></codeline>
</programlisting> with the correct name and location, and</para><para>4. Create an <computeroutput>INSTALL</computeroutput> rule so that the shared library will be installed correctly along with your project. It will be automatically installed into Zorba&apos;s default non-core library path (see <ref refid="uriresolvers_1libpath" kindref="member">Zorba&apos;s Library Path</ref>).</para><para>If your code depends on other dynamic libraries, you can pass the full paths to those libraries to <computeroutput>DECLARE_ZORBA_MODULE()</computeroutput> using the <computeroutput>LINK_LIBRARIES</computeroutput> option. In most cases, you will have this full path available because you used CMake&apos;s <computeroutput>FIND_PACKAGE()</computeroutput> command to locate it. For example, here is a bit of the <computeroutput>CMakeLists.txt</computeroutput> for the non-core XSLT module, which depends on libxslt:</para><para><programlisting><codeline><highlight class="normal">FIND_PACKAGE<sp/>(LibXslt)</highlight></codeline>
<codeline><highlight class="normal">IF<sp/>(LIBXSLT_FOUND)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>INCLUDE_DIRECTORIES<sp/>(${LIBXSLT_INCLUDE_DIR})</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DECLARE_ZORBA_MODULE<sp/>(FILE<sp/>xslt.xq<sp/>VERSION<sp/>1.0</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>URI<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/xslt&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>LINK_LIBRARIES<sp/></highlight><highlight class="stringliteral">&quot;${LIBXSLT_LIBRARIES}&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">ENDIF<sp/>(LIBXSLT_FOUND)</highlight></codeline>
</programlisting></para><para>Note that while <computeroutput>DECLARE_ZORBA_MODULE</computeroutput> will set up all the above build rules for your source code, it is still your responsibility to ensure that those .cpp files can find the necessary header files by using CMake&apos;s <computeroutput>INCLUDE_DIRECTORIES()</computeroutput> command. Again, generally speaking the path to the appropriate include directory will be set in a CMake variable by the <computeroutput>FIND_PACKAGE()</computeroutput> command.</para><para>Important note: <computeroutput>DECLARE_ZORBA_MODULE</computeroutput> discovers all <computeroutput>.cpp</computeroutput> files in the source directory automatically, using a glob pattern (i.e., <computeroutput>*.cpp</computeroutput>). This is convenient, but it does have a hidden downside: If you add new <computeroutput>.cpp</computeroutput> files to this directory, CMake has no way of knowing that you have done so, and so those files will not automatically get built. This can lead to strange compilation or runtime errors. Fortunately, there is a simple solution: Whenever you add new <computeroutput>.cpp</computeroutput> files for a module, always remember to immediately re-run <computeroutput>cmake</computeroutput> in your build directory. This will cause the glob pattern to be re-run and will pick up any new source code files. Likewise, if you delete any <computeroutput>.cpp</computeroutput> files from your source directory, you will need to re-run <computeroutput>cmake</computeroutput> for the same reason - although at least in that case you will get a clear error message if you forget to do so.</para></sect1>
<sect1 id="modules_authoring_2_1mod_author_declare_synopsis">
<title>Zorba Module CMake Macros: Summary</title>
<para>For reference, here is the complete set of options for all macros provided by Zorba:</para><para><programlisting><codeline><highlight class="normal">DECLARE_ZORBA_MODULE<sp/>(FILE<sp/>&lt;.xq<sp/>filename&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>URI<sp/>&lt;module<sp/>URI&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[<sp/>VERSION<sp/>&lt;version<sp/>number&gt;<sp/>]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[<sp/>LINK_LIBRARIES<sp/>&lt;library&gt;<sp/>[<sp/>&lt;library&gt;<sp/>...]<sp/>]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[<sp/>TEST_ONLY<sp/>]<sp/>)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">DECLARE_ZORBA_SCHEMA<sp/>(FILE<sp/>&lt;.xq<sp/>filename&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>URI<sp/>&lt;module<sp/>URI&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[<sp/>TEST_ONLY<sp/>]<sp/>)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ADD_TEST_DIRECTORY<sp/>(&lt;test<sp/><ref refid="namespacezorba_1_1fs_1a33bc6a07dd3ac39c5107606fc21bea22af89a5bc95208c01b9f59b3193d67a3f2" kindref="member">directory</ref>&gt;)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">DONE_DECLARING_ZORBA_URIS<sp/>()</highlight></codeline>
</programlisting> </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
