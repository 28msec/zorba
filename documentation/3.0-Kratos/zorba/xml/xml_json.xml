<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="xml_json" kind="page">
    <compoundname>xml_json</compoundname>
    <title>XQuery &amp; JSONiq (XML &amp; JSON)</title>
    <detaileddescription>
<sect1 id="xml_json_1two_syntaxes">
<title>One VM, two syntaxes</title>
<para>In Zorba 2.6, we introduced JSON support with the new <ulink url="http://www.jsoniq.org/">JSONiq</ulink> language. <ulink url="http://www.jsoniq.org/">JSONiq</ulink> extends XQuery with JSON support while leaving its XML functionality (almost) intact. This came at the cost of either circumvoluted syntax for JSON (like empty objects, or object lookup), or for breaking some XML corner-case functionality (like true, false and null that are recognized as literals rather than as XPath name tests).</para><para>We have received a lot of feedback since then, and realized that, for those of you who would like to work primarily with JSON, it made sense to let the <ulink url="http://www.jsoniq.org/">JSONiq</ulink> syntax live its own life.</para><para>Concretely, this means that: 1. The &quot;virtual machine&quot; (abstract query language, compiler and runtime) stays the same and fully support both XML and JSON. 2. But Zorba supports two syntaxes for it: XQuery and <ulink url="http://www.jsoniq.org/">JSONiq</ulink>, which are each tailored to the aesthetics preferences of each community.</para></sect1>
<sect1 id="xml_json_1share">
<title>What they share</title>
<para>XQuery and <ulink url="http://www.jsoniq.org/">JSONiq</ulink> share:<itemizedlist>
<listitem><para>the same type system: values are sequences of items, which can be XML nodes, JSON objects or arrays, atomic items or functions.</para></listitem><listitem><para>the same operations on atomic types.</para></listitem><listitem><para>the same semantics of core expressions such that if-then-else expressions, FLWOR expressions.</para></listitem><listitem><para>the same abstract navigation mechanism for both XML (XPath) and JSON (object and array lookup).</para></listitem></itemizedlist>
</para></sect1>
<sect1 id="xml_json_1two_faces">
<title>Two faces of the same language</title>
<para>To put it boldly, in terms of syntax, XQuery and <ulink url="http://www.jsoniq.org/">JSONiq</ulink> can be seen as two faces of the same language.</para><para>The XQuery syntax provides first-class XML support (full W3C conformance), as well as second-class JSON support (&quot;JSONiq extension to XQuery&quot; : everything <ulink url="http://www.jsoniq.org/">JSONiq</ulink> that does not collide with XQuery).</para><para>The <ulink url="http://www.jsoniq.org/">JSONiq</ulink> syntax provides first-class JSON support (nice JavaScript-like dot-based object lookup, full JSON copy-and-paste support, etc) and second-class XML support (&quot;XQuery extension to JSONiq&quot; : everything XQuery that does not collide with <ulink url="http://www.jsoniq.org/">JSONiq</ulink>).</para></sect1>
<sect1 id="xml_json_1contentious_points">
<title>Syntactic contentious points</title>
<para><image type="html" name="xquery_jsoniq_venn.png"></image>
</para><para>Here is a more detailed description of the collisions between XML and JSON support.</para><para>A. <bold>Dots in NCNames vs. Dot-based object lookup.</bold> XML names can contain dots, but dots are also used for object lookup. In particular, $var.key can be interpreted as a variable named &quot;var.key&quot; or as a lookup in the object $var for the key &quot;key&quot;.</para><para>B. <bold>Context item syntax.</bold> XQuery uses dots for the context item syntax. But combined with object lookup, it becomes hard to read: ..key for looking up the key &quot;key&quot; in the context item.</para><para>C. <bold>String literals.</bold> XQuery supports both single-quoted and double-quoted literals. JSON only supports double-quoted literals.</para><para>D. <bold>Character escaping.</bold> XML uses apersand-based escaping, like &amp;#a; or &amp;. JSON uses backslash-based escaping, like  or \.</para><para>E. <bold>Object keys.</bold> In some JSON languages, simple object keys (containing no spaces, etc) may be unquoted. This collides with XPath name tests.</para><para>F. <bold>true, false and null literals vs. XPath name tests.</bold> In XQuery, booleans can be constructed with the functions true() and false(), because true and false would be recognized as name tests. In JSON data, true and false appear as literals.</para><para>G. <bold>Empty object vs. empty block syntax.</bold> In JSON, the empty object is denoted {}. In Zorba&apos;s scripting extension to XQuery, {} is used for the empty block.</para><para>H. <bold>Type syntax.</bold> XQuery supports user-defined atomic types. To avoid collisions, XML node types use parentheses: node(), element(), etc as well as namespaces: xs:integer, xs:string, etc. <ulink url="http://www.jsoniq.org/">JSONiq</ulink> aims at a simpler syntax, with no parentheses: integer, string, object, array.</para><para>I. <bold>Update syntax.</bold> The XQuery update syntax collides with the JSON update syntax (insert, delete, replace, rename).</para></sect1>
<sect1 id="xml_json_1xquery_syntax">
<title>The XQuery Syntax</title>
<para>This syntax is fully conformant and backwards compatible with <ulink url="http://www.w3.org/TR/xquery-30/">XQuery 3.0</ulink>.</para><para>It is a superset of XQuery. It is not a superset of JSON.</para><para>A. No dot-based object lookup - use $object(&quot;key&quot;) instead.</para><para>B. No $$ for the context item - use . instead.</para><para>D. XML, ampersand-based escaping in string literals (you can switch with an option).</para><para>E. Object keys must be quoted.</para><para>F. No true/false/null literals - use fn:true(), fn:false() and jn:null() instead.</para><para>G. {} is the empty block. Use {| |} for the empty object.</para><para>H. XQuery-style type syntax: (a) builtin atomic types must be prefixed with xs:, (b) Non-atomic types must be followed by parentheses : object()... (c) The empty-sequence() type must be written as such.</para><para>I. &quot;json&quot; is mandatory in the JSON update syntax.</para></sect1>
<sect1 id="xml_json_1jsoniq_syntax">
<title>The JSONiq syntax</title>
<para>This syntax fully supports <ulink url="http://www.jsoniq.org/">JSONiq</ulink>, as well as some aspects of the XQuery syntax.</para><para>It is a superset of JSON (yes, you can copy-and-paste JSON data in a <ulink url="http://www.jsoniq.org/">JSONiq</ulink> query). It is not a superset of XQuery.</para><para>A. No names containing dots.</para><para>B. No . for the context item - use $$ instead.</para><para>C. No single-quoted literals. Use double-quoted literals instead.</para><para>D. JSON, baskslash-based escaping in string literals (you can switch with an option).</para><para>F. No axis step allowed at the beginning of a relative path expression. Instead of using foo:bar, you must use $$/foo:bar.</para><para>G. {} is for empty objects. Use {;} for empty blocks.</para></sect1>
<sect1 id="xml_json_1how_to_specify">
<title>How to specify which syntax your query is using</title>
<para>In order to pick a parser, you can add a version declaration on top of your module:</para><para><programlisting><codeline><highlight class="normal">xquery<sp/>version<sp/></highlight><highlight class="stringliteral">&quot;3.0&quot;</highlight><highlight class="normal">;</highlight></codeline>
</programlisting></para><para>will pick the XQuery parser.</para><para><programlisting><codeline><highlight class="normal">jsoniq<sp/>version<sp/></highlight><highlight class="stringliteral">&quot;1.0&quot;</highlight><highlight class="normal">;</highlight></codeline>
</programlisting></para><para>will pick the <ulink url="http://www.jsoniq.org/">JSONiq</ulink> parser.</para><para>In the absence of any version declaration, the XQuery parser is taken by default.</para></sect1>
<sect1 id="xml_json_1interlanguage">
<title>Interlanguage Module Imports</title>
<para>It is possible for a module written in XQuery syntax (xquery version declaration or no version declaration), to import another module written in <ulink url="http://www.jsoniq.org/">JSONiq</ulink> syntax (jsoniq version declaration), and vice-versa.</para></sect1>
<sect1 id="xml_json_1legacy_jsoniq">
<title>Legacy JSONiq queries can still be parsed with the XQuery parser.</title>
<para>If you wrote <ulink url="http://www.jsoniq.org/">JSONiq</ulink> queries with a preceding version of Zorba, they should work with the XQuery parser. Since it is the default, you do not need to add any version declaration. In order to restore full W3C conformance though, true/false/null literals are deprecated in the XQuery parser. While they will still work in Zorba 2.9, a warning will be issued. They will be obsolete in Zorba 3.0 and considered XPath name tests again. Of course, the <ulink url="http://www.jsoniq.org/">JSONiq</ulink> syntax still fully supports these literals. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
