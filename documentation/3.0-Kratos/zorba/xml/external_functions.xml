<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="external_functions" kind="page">
    <compoundname>external_functions</compoundname>
    <title>Writing Your Own External Functions</title>
    <detaileddescription>
<sect1 id="external_functions_1external">
<title>External Functions</title>
<para>In XQuery, a module may declare both user-defined and external functions (see <ulink url=" http://www.w3.org/TR/xquery-30/#FunctionDeclns">http://www.w3.org/TR/xquery-30/#FunctionDeclns</ulink>). User-defined functions are implemented as XQuery expressions and their implementation is provided together with their declaration. In contrast, external functions are typically implemented in a host language other than XQuery, and their implementation is not inside the declaring module. As a result, to support external functions, XQuery processors must provide mechanisms by which (1) the implementation of an external function can be located, (2) values for function parameters are passed from the XQuery runtime environment to the host language, and (3) the result of the function is passed back from the host language to the XQuery runtime environment. We call step (1) <bold>external function resolution</bold>. Steps (2) and (3) are part of <bold>external function invocation</bold>.</para><para>In Zorba, the C++ API provides the &quot;glue&quot; between the XQuery processor and the hosting environment into which external functions are implemented. Related code examples can be found <ulink url="/pages/latest/cxx/external_functions_8cpp-example">here</ulink>.</para><sect2 id="external_functions_1Implementation">
<title>Implementation</title>
<para>In Zorba, external functions must be implemented as instances of the <ulink url="/pages/latest/cxx/classzorba_1_1ExternalFunction">ExternalFunction</ulink> class. We refer to such instances as <bold>external function objects</bold>. During its evaluation, an external function may or may not need to access the static or dynamic contexts of the invoking XQuery module. If the function implementation does need to access either context, the function is referred to as <bold>contextual</bold>; otherwise, it is <bold>non-contextual</bold>. Zorba provides classes <ulink url="/pages/latest/cxx/classzorba_1_1ContextualExternalFunction">ContextualExternalFunction</ulink> and <ulink url="/pages/latest/cxx/classzorba_1_1NonContextualExternalFunction">NonContextualExternalFunction</ulink> to differentiate between contextual and non-contextual external functions, respectively. Both are abstract subclasses of ExternalFunction and provide a (virtual) evaluate() method that serves as the implementation of an external function. For each external function, an application must provide a concrete subclass of either of these classes.</para></sect2>
<sect2 id="external_functions_1Invocation">
<title>Invocation</title>
<para>Invoking an external function boils down to invoking the evaluate() method on the associated function object. The first parameter of evaluate() is a vector of pointers to <ulink url="/pages/latest/cxx/classzorba_1_1ItemSequence">ItemSequence</ulink> objects. During invocation, the given vector will contain one entry for each parameter listed in the external function declaration. The Zorba XQuery processor makes sure that the types of the item sequences given to evaluate() match the types of the formal parameters. Similarly, evaluate() returns the result of the function as an ItemSequence. Again, Zorba makes sure that the type of the returned ItemSequence matches the declared return type of the function. If the function is contextual, its evaluate() method has two additional parameters; they are pointers to the static and dynamic contextes of the module declaring the function.</para></sect2>
<sect2 id="external_functions_1Resolution">
<title>Resolution</title>
<para>Before it can invoke an external function, Zorba must locate its function object. For this, Zorba looks-up the function object in the static context, using the function QName as the key. However, it is the responsibility of the application to register the function objects to the static context. For this, Zorba provides the <ulink url="/pages/latest/cxx/classzorba_1_1ExternalModule">ExternalModule</ulink> abstract class. ExternalModule represents a group of external functions, all belonging to the same XQuery module (and thus having the same target namespace). It provides the interface for retrieving the function object of each contained external function given the function&apos;s QName. Applications are responsible for implementing concrete subclasses of ExternalModule and for registering instances of such subclasses into the static context. Registration can be done in either of the two following ways.</para><para>1. An ExternalModule object can be registered explicitly using the registerModule() method of <ulink url="/pages/latest/cxx/classzorba_1_1StaticContext">StaticContext</ulink>. In this case, the application retains memory ownership of the ExternalModul object, and must free it when it is no longer needed.</para><para>2. An implementation of ExternalModule and its associated ExternalFunctions can be packaged into a dynamic library (dll, so, or dylib). The dynamic library must have a global function named <computeroutput>createModule()</computeroutput> as an entry point, and createModule() must return a pointer to an ExternalModule object. Assuming a library has been named and placed appropriately, Zorba will automatically load it when it compiles the XQuery module with the same target namespace. It will call getModule() to create an ExternalModule object, and register it into the static context. In this case, Zorba assumes ownership of the ExternalModule object, and will destroy it when the containing static context is destroyed.</para><para>Under most circumstances, a module author using this second technique will use the CMake-based <computeroutput>DECLARE_ZORBA_MODULE()</computeroutput> framework to build the external module code and install it appropriately. Details of this mechanism can be found here: <ref refid="modules_authoring_2_1mod_author_cpp" kindref="member">External Functions in C++</ref>. Thus, you do not need to worry about how to build, name, or locate the shared object, as Zorba&apos;s process will take care of that for you.</para></sect2>
<sect2 id="external_functions_1external_manual">
<title>Manual Shared Object Resolution</title>
<para>For reference, included below is the process that Zorba will use internally to located the shared object when compiling a module with external functions. If for some reason you do not wish to use the <computeroutput>DECLARE_ZORBA_MODULE()</computeroutput> framework, the below information will be necessary for you to place the shared object such that Zorba can load it at runtime.</para><para>To locate a dynamic library, Zorba first transforms its target namespace URI to a relative file path and then uses the &quot;Library Path&quot; mechanism (described in <ref refid="uriresolvers_1libpath" kindref="member">Zorba&apos;s Library Path</ref>) to turn this relative path to the absolute path name of the dynamic library file. The transformation of the URI to a relative path is done using the following steps. In describing the steps, we will use the URI &quot;http://www.example.com/modules/utils&quot; as an example and assume we are working with a Linux system.</para><para><orderedlist>
<listitem>
<para>The domain component of the URI is extracted and transformed into a path notation by replacing its &quot;.&quot; characters (if any) into forward slashes and reversing the order of the path steps. The result of this step on the example URI is &quot;com/example/www&quot;. </para><para></para></listitem>
<listitem>
<para>The path component of the URI is extracted and separated into a branch name and a file name: (a) if the path component does not contain any &quot;/&quot; characters, the branch name is empty and the file name is the full path component, else (b) if the path component ends with a &quot;/&quot;, the branch name is the full path component and the file name is empty, else (c) the file name is set to the last step of the path component (the substring after the last &quot;/&quot;) and the branch name is set to the path component minus the last step. The branch name is then appended to the result of the previous step. The result of this step on the example URI is &quot;com/example/www/modules/&quot;. </para><para></para></listitem>
<listitem>
<para>On Unix or Mac systems, the string &quot;lib&quot; is appended to the result of the previous step. The result of this step on the example URI is &quot;com/example/www/modules/lib&quot;. </para><para></para></listitem>
<listitem>
<para>The file name is appended to the result of the previous step. The result of this step on the example URI is &quot;com/example/www/modules/libutils&quot;. </para><para></para></listitem>
<listitem>
<para>If the XQuery module being imported contains a version option, the character &quot;_&quot; followed by the version string are appended. Assuming that the module being imported via the example URI has a version option with the value &quot;1.2&quot;, the result of this step on the example URI is &quot;com/example/www/modules/libutils_1.2&quot;. </para><para></para></listitem>
<listitem>
<para>Finally, the appropriate suffix is appended to the file name: &quot;.so&quot; for Unix, &quot;.dll&quot; for Windows, or &quot;.dylib&quot; for MacOS. The result of this step on the example URI is &quot;com/example/www/modules/libutils_1.2.so&quot;. </para><para></para></listitem>
</orderedlist>
</para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
