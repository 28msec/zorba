<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="xqddf" kind="page">
    <compoundname>xqddf</compoundname>
    <title>Data Definition Facility</title>
    <detaileddescription>
<para>Zorba has support for collections, indexes, and integrity constraints.</para><para>This is accomplished via a combination of new prolog declarations, new kinds of expressions or extensions to existing expressions, and new built-in functions. Furthermore, both the static and the dynamic contexts are extended with new components that store information about collections, indexes, and integrity constraints. Collectively, all these extensions are called the <bold>Data Definition Facility</bold></para><para><linebreak/>
 <linebreak/>
 As part of the implementation, Zorba includes new &quot;built-in&quot; modules that contain the declarations of all the new built-in functions to manage (ddl) and manipulate (dml) collections, indexes, and integrity constraints.</para><para><itemizedlist>
<listitem>
<para><ulink url="/modules/latest/zorba.io/modules/store/static/collections/dml">http://zorba.io/modules/store/static/collections/dml</ulink> (prefix: cdml) </para></listitem>
<listitem>
<para><ulink url="/modules/latest/zorba.io/modules/store/static/collections/ddl">http://zorba.io/modules/store/static/collections/ddl</ulink> (prefix: cddl) </para></listitem>
<listitem>
<para><ulink url="/modules/latest/zorba.io/modules/store/static/indexes/dml">http://zorba.io/modules/store/static/indexes/dml</ulink> (prefix: idml) </para></listitem>
<listitem>
<para><ulink url="/modules/latest/zorba.io/modules/store/static/indexes/ddl">http://zorba.io/modules/store/static/indexes/ddl</ulink> (prefix: iddl) </para></listitem>
<listitem>
<para><ulink url="/modules/latest/zorba.io/modules/store/static/integrity/constraints/dml">http://zorba.io/modules/store/static/integrity_constraints/dml</ulink> (prefix: icdml) </para></listitem>
<listitem>
<para><ulink url="/modules/latest/zorba.io/modules/store/static/integrity/constraints/ddl">http://zorba.io/modules/store/static/integrity_constraints/ddl</ulink> (prefix: icddl) </para></listitem>
</itemizedlist>
</para><para>As usual, these modules must be imported by any other module that wants to invoke any of the functions.</para><sect1 id="xqddf_1collections">
<title>Collections</title>
<para><heading level="3"><anchor id="_1collection"/>Collections</heading>
</para><para>A collection is defined as an ordered set of documents that is disjoint from any other collection and is uniquely identified by a QName. Furthermore, with respect to document order, the relative order of two nodes belonging to different documents within the same collection is defined to be the same as the relative position of their containing documents within the collection. We will say that a node belongs to a collection if it is inside a document that belongs to that collection.</para><para><linebreak/>
 <linebreak/>
 Like a W3C collection, an <ulink url="#collection">collection</ulink> can be viewed as a sequence of nodes: it is the sequence containing the root nodes of the documents that belong to the collection (and as we will see later, the function <ulink url="#cdml_collection">cdml:collection</ulink> returns exactly this sequence of nodes). However, even when viewed as sequences of nodes, <ulink url="#collection">collections</ulink> differ from W3C collections in the following ways:</para><para><itemizedlist>
<listitem>
<para>They contain parent-less nodes only. </para></listitem>
<listitem>
<para>They can not contain any duplicate nodes. </para></listitem>
<listitem>
<para>Their nodes are in document order. </para></listitem>
<listitem>
<para>A node can not be contained in more than one <ulink url="#collection">collection</ulink>. </para></listitem>
<listitem>
<para>collections are identified by QNames, whereas W3C collections are identified by URIs. </para></listitem>
</itemizedlist>
</para><para>For brevity, in the remaining of this document we will use the term &quot;collection&quot; to mean <ulink url="#collection">collection</ulink>. For backward compatibility with the W3C XQuery specification, Zorba retains some basic support for W3C collections (see <ulink url="../modules/latest/zorba.io/modules/store/dynamic/collections/w3c/dml">http://zorba.io/modules/store/dynamic/collections/w3c/dml</ulink> and <ulink url="/modules/latest/zorba.io/modules/store/dynamic/collections/w3c/ddl">http://zorba.io/modules/store/dynamic/collections/w3c/ddl</ulink>). However, users are encouraged to use <ulink url="#collection">collections</ulink> instead.</para><para>Zorba supports five kinds of operations on collections: <ulink url="#collection_declaration">collection declaration</ulink>, <ulink url="#creating_collections">collection creation</ulink>, <ulink url="#destroying_collections">collection deletion</ulink>, <ulink url="#updating_collections">collection update</ulink>, and <ulink url="#accessing_collections">node retrieval</ulink>. These are explained briefly in the following simple example. Full details for each operation are provided in the subsequent chapters.</para><sect2 id="xqddf_1collections_in_action">
<title>Collections in action - A simple example</title>
<para><linebreak/>
 Let us assume an application that models a news organization. The application models its data as XML documents grouped into collections of logically related entities. In this example, we show how three such collections may be created and used; the first collection contains employee data, the second contains news articles, and the third contains information about the months of the year (e.g., the name, number of days, and fixed holidays for each month).</para><para><linebreak/>
 <linebreak/>
 Before a collection can be created, it must be declared. A <bold>collection declaration</bold> describes the collection by providing a unique name for it and specifying certain properties (using XQuery Annotations) for the collection itself and for the documents in the collection. As explained in <ref refid="xqddf_1collection_declaration" kindref="member">Collection Declaration</ref>, collections must be declared inside library modules. In terms of the XQuery language, collection declarations become part of a module&apos;s static context.</para><para><linebreak/>
 <linebreak/>
 In this example, the declarations are placed inside the <ulink url="#lib_module_news_data_collections">&quot;news-data&quot;</ulink> library module (shown below). The declarations assign the names news-data:employees, news-data:articles, and news-data:months to the three collections, respectively. Documents in both the employees and the months collections are assumed to have a well-known structure, which is reflected in an XML schema (&quot;news-schema&quot;). The schema declares two global elements for employees and months respectively. Accordingly, the collection declarations for employees and months specify that their root nodes are elements whose name and type matches the name and type of the corresponding global element declarations in &quot;news-schema&quot;. In contrast, articles may come from various sources (including external ones), and as a result, article documents do not have any particular schema. Therefore, the declaration for the articles collection specifies node() as the type of the root nodes. Both employee and article documents may be updated during their lifetime. Instead, the months-related information is fixed (can not change), so the nodes of the months collection are declared as &apos;an:read-only-nodes&apos;. Furthermore, the collection itself is declared &apos;an:const&apos;, meaning that no months may be added to or deleted from this collection after it is created and initialized. Finally, we want the order of the month documents within their containing collection to be the same as the actual order of the months within the year. To achieve this, we have to declare the collection as &quot;ordered&quot;, so that when we later insert the month documents in the collection, the system will store and return them in the same order as their insertion order. In contrast, the position of employees or articles inside their respective collections does not have any special meaning for the application, so the corresponding declarations do not specify any ordering property. This allows the system to store and access the contents of these collections in what it considers as the most optimal order.</para><para><anchor id="_1lib_module_news_data_collections"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/>The<sp/></highlight><highlight class="stringliteral">&quot;news-data&quot;</highlight><highlight class="normal"><sp/>Library<sp/>Module<sp/>:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>schema<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-schemas<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/schemas&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal"><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref><sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/annotations&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>collection<sp/>news-data:employees<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>schema-element(news-schema:employee)*;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>collection<sp/>news-data:articles<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:<ref refid="namespacezorba_1acf239253638cf017b2a8e29f47be25d3ac9eb30d96464f101853e7daea626bd98" kindref="member">ordered</ref><sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:read-only-nodes<sp/>collection<sp/>news-data:months</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>schema-element(news-schema:month)*;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>variable<sp/>$news-data:employees<sp/>:=<sp/>xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:employees&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>variable<sp/>$news-data:articles<sp/>:=<sp/>xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:articles&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>variable<sp/>$news-data:months<sp/>:=<sp/>xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:months&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para><para>Having been declared, the collections can now be created. <bold>Collection creation</bold> is illustrated by the &quot;admin-script-1&quot; script shown below. First, the collection descriptions must be made visible to the script. This is done by importing the <ulink url="#lib_module_news_data_collections">&quot;news-data&quot;</ulink> library module that contains the collection declarations. Then, the collections are created by calling the cddl:create function. There are two versions of this function: the first takes a QName as input and the second takes both a QName and a node-producing expression. In the first version, an empty document container is created by Zorba&apos;s storage system and registered inside a <bold>collections table</bold> that maps collection names to document containers. In the second version, the given expression is evaluated first, and (deep) copies are made of the nodes in the result sequence. This way, a sequence of distinct documents is produced. This is called the &quot;insertion sequence&quot;. Then, as in the first version of the function, the document container is created and registered. Finally, the container is populated with the documents in the insertion sequence. In &quot;admin-script-1&quot;, this second version is used to create and initialize the months collection. In fact, months must be initialized during creation because it is a constant collection, so no documents can be added to it later. The months are inserted in the collection in the order from January to December, and since the collection was declared as &apos;an:ordered&apos;, this order is preserved by the associated document container.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/></highlight><highlight class="stringliteral">&quot;admin-script-1&quot;</highlight><highlight class="normal"><sp/>:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>cddl<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/collections/ddl&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cddl:create($news-data:employees);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cddl:create($news-data:articles);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cddl:create($news-data:months,<sp/>(&lt;month<sp/>name=</highlight><highlight class="stringliteral">&quot;Jan&quot;</highlight><highlight class="normal">&gt;...&lt;/month&gt;,<sp/>...,<sp/>&lt;month<sp/>name=</highlight><highlight class="stringliteral">&quot;Dec&quot;</highlight><highlight class="normal">&gt;...&lt;/month&gt;));</highlight></codeline>
</programlisting></para><para>The next script (&quot;user-script-1&quot;) shows how collections may be used. First the necessary modules and schemas are imported. Next, the employees collection is populated using the cdml:insert-nodes function. The first argument to this function is the QName of a collection, and the second is a node-producing expression (called the source expression). The QName is used to lookup the collection declaration and the collection itself (i.e., its document container). Then, the nodes produced by the source expression (source nodes) are copied and the copies are added to the document container, making sure that the actual type of each node matches the static type found in the collection declaration. Copying the source nodes (and their sub-trees) guarantees that the nodes in the insertion sequence are indeed parent-less nodes that do not belong to any other collection already and are distinct from each other. Notice that the need to validate the root nodes against the type specified in the collection declaration is the reason why the &quot;news-schema&quot; must be imported, even though no type defined by the schema is referenced explicitly in the query.</para><para><linebreak/>
 <linebreak/>
 In this example, the employees collection is populated by a single call to the cdml:insert-nodes function, whose source expression is a concatenation of explicitly constructed documents. The articles collection is populated using the cdml:insert-nodes function as well, but in a slightly different fashion: The article documents are assumed to exist already, either as text files in the local filesystem, or at various web sites. As a result, the articles collection is populated via a concatenation of cdml:insert-function calls, each reading and parsing a single XML document and inserting the generated XML tree in the collection. Although there is one function call per article, the articles will be inserted all together in an atomic (all-or-nothing) operation, when the &quot;;&quot; at line 16 is processed. This is because, as explained in <ref refid="xqddf_1updating_collections" kindref="member">Updating Collections</ref>, the cdml:insert-nodes function (and all other functions that create, delete, or update collections) is an //updating function//, that is, rather than applying the insertion immediately, it produces an updating primitive that becomes part of a pending updates list (PUL), which is applied atomically when the next &quot;;&quot; appears in the program.</para><para><linebreak/>
 <linebreak/>
 After populating the two collections, &quot;user-script-1&quot; runs a query expression that uses the <ulink url="#cdml_collection">cdmlcdml:collection</ulink> function to access their root nodes. The expression returns, for each journalist, the articles authored by that journalist ordered by their date.</para><para><linebreak/>
 <linebreak/>
 Finally, &quot;user-script-1&quot; uses the cdml:remove-nodes function to remove from the articles collection all articles that were published before 2000. Like cdml:insert-nodes, cdml:remove-nodes takes as input the QName of a collection and a node-producing source expression. The source nodes must be parent-less nodes that belong to the collection. The function looks up the collection declaration and the collection container, and removes the source nodes from the collection container.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/></highlight><highlight class="stringliteral">&quot;user-script-1&quot;</highlight><highlight class="normal">:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>cdml<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/collections/dml&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">http<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.zorba-xquery.com/modules/http-client&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>schema<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-schemas<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/schemas&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cdml:insert-nodes($news-data:employees,<sp/>(&lt;employee<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">=</highlight><highlight class="stringliteral">&quot;100&quot;</highlight><highlight class="normal">&gt;...&lt;/employee&gt;,<sp/>...,<sp/>&lt;employee<sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal">=</highlight><highlight class="stringliteral">&quot;500&quot;</highlight><highlight class="normal">&gt;...&lt;/employee&gt;));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cdml:insert-nodes($news-data:articles,<sp/>doc(</highlight><highlight class="stringliteral">&quot;article1.xml&quot;</highlight><highlight class="normal">)/article),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cdml:insert-nodes($news-data:articles,<sp/>http:</highlight><highlight class="keyword">get</highlight><highlight class="normal">(</highlight><highlight class="stringliteral">&quot;http://www.reuters.com/article234.xhtml&quot;</highlight><highlight class="normal">)</highlight><highlight class="comment">//article),</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>....,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>cdml:insert-nodes($news-data:articles,<sp/>doc(</highlight><highlight class="stringliteral">&quot;article100.xml&quot;</highlight><highlight class="normal">)/article)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>$emp<sp/>in<sp/>cdml:collection($news-data:employees)[./position/@<ref refid="namespacezorba_1_1diagnostic_1a5709afb398f65a318160aa7613abfa9e" kindref="member" tooltip="An diagnostic::kind is the kind of error.">kind</ref><sp/>eq<sp/></highlight><highlight class="stringliteral">&quot;journalist&quot;</highlight><highlight class="normal">]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>let<sp/>$articles<sp/>:=<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>$art<sp/>in<sp/>cdml:collection($news-data:articles)[.</highlight><highlight class="comment">//author//name<sp/>eq<sp/>$emp/name]</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>order<sp/>by<sp/>$art</highlight><highlight class="comment">//date</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>$art</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>&lt;result&gt;{$emp}&lt;articles&gt;{$articles</highlight><highlight class="comment">//title}&lt;/articles&gt;&lt;/result&gt;;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cdml:</highlight><highlight class="keyword">delete</highlight><highlight class="normal">-nodes(cdml:collection($news-data:articles)[.</highlight><highlight class="comment">//date<sp/>lt<sp/>xs:date(&quot;01/01/2000&quot;)]);</highlight></codeline>
</programlisting></para><para>We conclude this example with the &quot;admin-script-2&quot; script, which simply destroys the collections using the cddl:delete function. The function de-registers the collection from the collections table, destroys all the documents in the collection and all the indexes and integrity constraints associated the collection, and finally destroys the document container itself.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/>admin-script2<sp/>:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>cddl<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/collections/ddl&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cddl:</highlight><highlight class="keyword">delete</highlight><highlight class="normal">($news-data:employees);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cddl:</highlight><highlight class="keyword">delete</highlight><highlight class="normal">($news-data:articles);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cddl:</highlight><highlight class="keyword">delete</highlight><highlight class="normal">($news-data:months);</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="xqddf_1collection_declaration">
<title>Collection Declaration</title>
<para><programlisting><codeline><highlight class="normal"><sp/><sp/>AnnotatedDecl</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>::=<sp/></highlight><highlight class="stringliteral">&apos;declare&apos;</highlight><highlight class="normal"><sp/>(<sp/>CompatibilityAnnotation<sp/>|<sp/>Annotation<sp/>)*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(<sp/>VarDecl<sp/>|<sp/>FunctionDecl<sp/>|<sp/>CollectionDecl<sp/>|<sp/>IndexDecl<sp/>|<sp/>ICDecl<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CollectionDecl<sp/>::=<sp/></highlight><highlight class="stringliteral">&apos;collection&apos;</highlight><highlight class="normal"><sp/>EQName<sp/>CollectionTypeDecl?</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CollectionTypeDecl<sp/>::=<sp/></highlight><highlight class="stringliteral">&apos;as&apos;</highlight><highlight class="normal"><sp/>KindTest<sp/>OccurrenceIndicator?</highlight></codeline>
</programlisting></para><para>Collections are defined by <bold>collection declaration statements</bold>, which specify a unique name for a collection as a QName, a set of collection annotations (see <ref refid="options_and_annotations_1collection_index_annotations" kindref="member">Annotations on Collections and Indexes</ref>), the collection&apos;s static type. Syntactically, collection declarations are placed inside module prologs. The Prolog syntax is extended accordingly, as shown above. An additional constraint (not expressible syntactically) is that only library modules may contain collection declarations [<ulink url="#ERRZDST0003">zerr:ZDST0003</ulink>]. This is because library modules can be shared among queries, whereas if a collection was declared inside a main module, then every other query that would like to use this collection would have to redeclared it in its main module. Worse, allowing collection declarations in &quot;user&quot; queries can lead to &quot;data leaks&quot;: a collection declared and created by a user query and not destroyed by the same query will be unknown to the rest of the application, and may stay in the database indefinitely. In contrast, library modules containing declarations are expected to be under the jurisdiction of a system administrator who makes sure that queries see the data that they must see, and no data inconsistencies or leaks can arise.</para><para><linebreak/>
 <linebreak/>
 To accommodate collection declarations, Zorba extends the static context with a component called the <bold>statically known collections</bold>. This is a map whose entries associate an expanded QName with an implementation-dependent representation of the information contained in a collection declaration with the same QName. The effect of a collection declaration is to add an entry to the statically known collections of the module containing the declaration. If the expanded QName of the collection is equal (as defined by the eq operator) to the expanded QName of another collection in the statically known collections of the same module, a static error is raised [<ulink url="#ERRZDST0001">zerr:ZDST0001</ulink>]. Like variables and functions, the statically known collections of a module that is imported by another module are copied into the statically known collections of the importing module. It is a static error [<ulink url="#ERRZDST0002">zerr:ZDST0002</ulink>] if the expanded QName of a collection declared in an imported module is equal (as defined by the eq operator) to the expanded QName of a collection declared in the importing module or in another imported module (even if the declarations are consistent).</para><para>Zorba defines three categories of collection annotations:</para><para><bold>update mode</bold> (with possible values &apos;an:const&apos;, &apos;an:mutable&apos;, &apos;an:append-only&apos;, or &apos;an:queue&apos;), <bold>ordering mode</bold> (with possible values &apos;an:ordered&apos; or &apos;an:unordered&apos;), and <bold>document update mode</bold> (with possible values &apos;an:read-only-nodes&apos; and &apos;an:mutable-nodes&apos;).</para><para>If not specified, the default values for update and ordering mode are &apos;an:mutable&apos; and &apos;an:unordered&apos;, respectively. The default value for the document update mode is &apos;an:mutable-nodes&apos;.</para><para><linebreak/>
 <linebreak/>
 It is a static error [err::XQST0106] if a collection declaration contains more than one value for the same property. An <bold>ordered collection</bold> is a collection into which the ordering of documents is assumed to be meaningful for the application, and as a result, programmers can explicitly control the placement of documents via appropriate updating functions. In contrast, the ordering of documents inside <bold>unordered collections</bold> is implementation dependent, but stable (see <ref refid="xqddf_1accessing_collections" kindref="member">Accessing Collections</ref> for details). A <bold>constant collection</bold> is one that is created with an initial set of documents and does not allow any subsequent insertions to or deletions from this initial set.</para><para><linebreak/>
 <linebreak/>
 An &apos;an:append-only&apos; collection does not allow any deletions at all and restricts insertions to take place at the &quot;end&quot; only, i.e., all new documents must be inserted after all existing ones. This implies a user-visible document ordering, and as a result, an &apos;an:append-only&apos; collection must also be declared as &apos;an:ordered&apos; [err:XQST0106]. A &apos;an:queue&apos; collection forbids both insertions and deletions in/from the &quot;middle&quot;; only documents at the front of the collection may be deleted, and new documents can be inserted only at the end of a collection. Like &apos;an:append-only&apos;, &apos;an:queue&apos; collections must be declared as &apos;an:ordered&apos; [err:XQST0106]. If the document update mode of a collection is &apos;an:read-only-nodes&apos; then an error is raised [<ulink url="#ERRZDDY0010">zerr:ZDDY0010</ulink>] every time a node of the collection appears as the target node of an updating expression; otherwise no such error is raised.</para><para>In addition to the annotations described above, a collection declaration also specifies the <bold>collection static type</bold>, i.e., the static type for the result of the <ulink url="#cdml_collection">cdml:collection</ulink> function. This is specified as a sequence type that adheres to the syntax and semantics of a KindTest plus an (optional) occurrence indicator. If no static type is specified, it is assumed to be document-node(element(*, xs:untyped))*. The static type without the occurrence indicator is the static type of the collection&apos;s root nodes.</para></sect2>
<sect2 id="xqddf_1creating_collections">
<title>Creating Collections</title>
<para><linebreak/>
 As explained already, collections are just sets of parent-less XML trees (called &quot;documents&quot;). In terms of the language, these sets &quot;live&quot; in the dynamic context. In particular, the dynamic context is extended with a component called the <bold>available collections</bold>. This is a map whose entries associate the expanded QName of a collection with the collection&apos;s document set. If an entry for a collection appears in the available collections of a module, the collection is said to be available to that module.</para><para><linebreak/>
 <linebreak/>
 In practice, the available collections component is implemented by the storage system of Zorba. To begin with, each document set is implemented by some appropriate data structure that acts as a document container. The description of potential data structures is beyond the scope of this document, but the choice will, in general, depend on the properties of the collection and the contained documents. In addition to managing the document containers, the store maintains a <bold>collections table</bold>, which maps collection names to document containers. The collections table is accessible by all queries, so once an entry is added to the table, the associated collection is assumed to be available to every query and every module that participates in the execution of that query.</para><para><linebreak/>
 <linebreak/>
 Creation of a collection involves creating an initially empty document container and &quot;registering&quot; that container in the collections table. We provide two functions for creating collections. Both are updating functions, so instead of actually performing the updates, they generate pending update primitives that become part of a pending update list (PUL) to be applied at a later time (see <ref refid="xqddf_1extensions_xquf_updates_routines" kindref="member">Extensions to the XQUF updates</ref>). The functions and their associated update primitives are described below:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:create_collection($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>upd:createCollection($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName)</highlight></codeline>
</programlisting></para><para>The function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>If the given expanded QName does not identify a collection among the statically known collections in the static context of the invoking module, an error is raised [<ulink url="#ERRZDDY0001">zerr:ZDDY0001</ulink>]. </para></listitem>
<listitem>
<para>If the given expanded QName identifies a collection that is available already, an error is raised [<ulink url="#ERRZDDY0002">zerr:ZDDY0002</ulink>]. </para></listitem>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of a single update primitive: upd:createCollection($collectionName). </para></listitem>
</itemizedlist>
</para><para>The update primitive is applied as follows:</para><para><itemizedlist>
<listitem>
<para>An empty document container is created. </para></listitem>
<listitem>
<para>A entry is added to the collections table. The entry maps the collection&apos;s expanded QName to the document container. </para></listitem>
</itemizedlist>
</para><para>The second create function creates the collection and populates it with an initial set of trees.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:create_collection($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,<sp/>$nodes<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*)</highlight></codeline>
</programlisting></para><para>The function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>If the given expanded QName does not identify a collection among the statically known collections in the static context of the invoking module, an error is raised [<ulink url="#ERRZDDY0001">zerr:ZDDY0001</ulink>]. </para></listitem>
<listitem>
<para>If the given expanded QName identifies a collection that is available already, an error is raised [<ulink url="#ERRZDDY0002">zerr:ZDDY0002</ulink>]. </para></listitem>
<listitem>
<para>The expression that is given as the second argument to the function call is evaluated. The result of the evaluation is called the source sequence. If the source sequence contains an item that is not a node, or a node whose actual type does not match the root static type specified in the collection declaration, a type error is raised [<ulink url="#ERRXDTY0001">zerr:XDTY0001</ulink>]. </para></listitem>
<listitem>
<para>Each of the nodes in the source sequence is copied as if it was a node returned by an enclosed expression in a direct element constructor (see <ulink url="http://www.w3.org/TR/xquery/#id-content">http://www.w3.org/TR/xquery/#id-content</ulink>). The construction and copy-namespaces modes used during the copy operation are the ones in the static context of the invoking module. Let $nodes be the sequence containing the copied nodes. Every node in $nodes is a root (parent-less) node that does not belong to any collection and is distinct from any other node in $nodes. </para></listitem>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of the following update primitives: upd:createCollection($collectionName) and upd:insertNodesFirst($collectionName, $nodes) </para></listitem>
</itemizedlist>
</para><para>The upd:createCollection primitive was described above. The upd:insertNodesFirst will be described in <ref refid="xqddf_1updating_collections" kindref="member">Updating Collections</ref>, in the context of the cdml:insert-nodes-first function.</para></sect2>
<sect2 id="xqddf_1accessing_collections">
<title>Accessing Collections</title>
<para>To access the root nodes of a collection, the <bold><anchor id="_1cdml_collection"/>cdml:collection</bold> function is provided.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:collection($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName)<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*</highlight></codeline>
</programlisting></para><para>The function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>If the given expanded QName does not identify a collection among the statically known collections in the static context of the invoking module, an error is raised [<ulink url="#ERRZDDY0001">zerr:ZDDY0001</ulink>]. </para></listitem>
<listitem>
<para>If the given expanded QName does not identify a collection among the available collections in the dynamic context of the invoking module, an error is raised [<ulink url="#ERRZDDY0003">zerr:ZDDY0003</ulink>]. </para></listitem>
<listitem>
<para>The result of the function is a sequence consisting of the root nodes in the collection. If the collection is declared as &apos;an:ordered&apos;, the ordering of the nodes in the result will reflect the order into which nodes were inserted in the collection by the node insertion functions (see <ref refid="xqddf_1updating_collections" kindref="member">Updating Collections</ref>). If the collection is declared as &apos;an:unordered&apos;, the ordering of the nodes in the result is implementation-dependent. In both cases, the nodes in the sequence are, by definition, in document order. For unordered collections, this document ordering is guaranteed to be stable within a query snapshot (i.e., until the next time updates are applied). For ordered collections, the document ordering is stable &quot;forever&quot; (i.e., two root nodes in the collection will compare the same as long as the collection (and the nodes) exist). </para></listitem>
</itemizedlist>
</para><para>Another non-updating function that accesses a collection implicitly, is the index-of function:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:index_of($node<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node())<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:integer</highlight></codeline>
</programlisting></para><para>The function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>If the given node is not a root node of a collection, an error is raised [<ulink url="#ERRZDDY0011">zerr:ZDDY0011</ulink>]. </para></listitem>
<listitem>
<para>The result of this function is the position as xs:integer of the given node within its collection. </para></listitem>
</itemizedlist>
</para></sect2>
<sect2 id="xqddf_1updating_collections">
<title>Updating Collections</title>
<para>A <bold>collection update</bold> is an operation that either inserts or deletes a number of root nodes (and their subtrees) to/from a collection. Zorba provides five updating functions that insert root nodes, and another five updating functions that delete root nodes. All of these functions are //updating functions// (in the terminology of the XQUF). As a result, rather than applying the update immediately, they produce an updating primitive that becomes part of a pending updates list (PUL), which is applied atomically when the next &quot;;&quot; appears in a script. The signature and semantics of each function and its associated update primitive are described in this section. The order in which the various update primitives are applied and constraints in how update primitives may be combined in a PUL are described in <ref refid="xqddf_1extensions_xquf_updates_routines" kindref="member">Extensions to the XQUF updates</ref>.</para><para><linebreak/>
 <linebreak/>
 In addition to the updating insert functions, Zorba also provides five sequential insert functions (i.e. cdml:apply-insert-nodes, cdml:apply-insert-nodes-first, cdml:apply-insert-nodes-last, cdml:apply-insert-nodes-before, cdml:apply-insert-nodes-after) . These sequential counterparts apply the update primitive implicitly and return the node that was inserted into the collection. This is especially useful because nodes are copied before they are inserted into a collection.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:insert-nodes($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,<sp/>$nodes<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>upd:insertIntoCollection($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,<sp/>$nodes<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*)</highlight></codeline>
</programlisting></para><para>The insert-nodes function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>If the given expanded QName does not identify a collection among the statically known collections in the static context of the invoking module, an error is raised [<ulink url="#ERRZDDY0001">zerr:ZDDY0001</ulink>]. </para></listitem>
<listitem>
<para>If the given expanded QName does not identify a collection among the available collections in the dynamic context of the invoking module, an error is raised [<ulink url="#ERRZDDY0003">zerr:ZDDY0003</ulink>]. </para></listitem>
<listitem>
<para>If the update mode of the collection is const, append-only, or queue, an error is raised [<ulink url="#ERRZDDY0004">zerr:ZDDY0004</ulink>], [<ulink url="#ERRZDDY0005">zerr:ZDDY0005</ulink>], or [<ulink url="#ERRZDDY0006">zerr:ZDDY0006</ulink>], respectively. </para></listitem>
<listitem>
<para>The expression that is given as the second argument to the function call is evaluated. The result of the evaluation is called the source sequence. If the source sequence contains an item that is not a node, or a node whose actual type does not match the KindTest specified in the collection declaration, a type error is raised [<ulink url="#ERRXDTY0001">zerr:XDTY0001</ulink>]. </para></listitem>
<listitem>
<para>Each of the nodes in the source sequence is copied as if it was a node returned by an enclosed expression in a direct element constructor (see <ulink url="http://www.w3.org/TR/xquery/#id-content">http://www.w3.org/TR/xquery/#id-content</ulink>). The construction and copy-namespaces modes used during the copy operation are the ones in the static context of the invoking module. Let $nodes be the sequence containing the copied nodes. Every node in $nodes is a parent-less root node that does not belong to any collection and is distinct from any other node in $nodes. </para></listitem>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of a single update primitive: upd:insertIntoCollection($collectionName, $nodes). </para></listitem>
</itemizedlist>
</para><para>The update primitive is applied as follows:</para><para><itemizedlist>
<listitem>
<para>The document container for the collection is found via the collections table. </para></listitem>
<listitem>
<para>The root nodes in $nodes are inserted into the container. If the collection is an ordered one, then all the nodes are inserted next to each other and in the same order as they appear in $nodes. The position of the first node to be inserted is implementation-dependent. The relative positions of pre-existing root nodes do not change as a result of the insertions. If the collection is an unordered one, each node is inserted in some implementation-dependent position. Furthermore, the relative positions of pre-existing root nodes may change as a result of the insertions. </para></listitem>
</itemizedlist>
</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:insert-nodes-first($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,<sp/>$nodes<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>upd:insertFirstIntoCollection($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,<sp/>$nodes<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*)</highlight></codeline>
</programlisting></para><para>The insert-nodes-first function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>If the given expanded QName does not identify a collection among the statically known collections in the static context of the invoking module, an error is raised [<ulink url="#ERRZDDY0001">zerr:ZDDY0001</ulink>]. </para></listitem>
<listitem>
<para>If the given expanded QName does not identify a collection among the available collections in the dynamic context of the invoking module, an error is raised [<ulink url="#ERRZDDY0003">zerr:ZDDY0003</ulink>]. </para></listitem>
<listitem>
<para>If the update mode of the collection is &apos;an:const&apos;, &apos;an:append-only&apos;, or &apos;an:queue&apos;, an error is raised [<ulink url="#ERRZDDY0004">zerr:ZDDY0004</ulink>], [<ulink url="#ERRZDDY0005">zerr:ZDDY0005</ulink>], or [<ulink url="#ERRZDDY0006">zerr:ZDDY0006</ulink>], respectively. </para></listitem>
<listitem>
<para>If the collection is &apos;an:unordered&apos;, an error is raised [<ulink url="#ERRZDDY0012">zerr:ZDDY0012</ulink>]. </para></listitem>
<listitem>
<para>The expression that is given as the second argument to the function call is evaluated. The result of the evaluation is called the source sequence. If the source sequence contains an item that is not a node, or a node whose actual type does not match the KindTest specified in the collection declaration, a type error is raised [<ulink url="#ERRXDTY0001">zerr:XDTY0001</ulink>]. </para></listitem>
<listitem>
<para>Each of the nodes in the source sequence is copied as if it was a node returned by an enclosed expression in a direct element constructor (see <ulink url="http://www.w3.org/TR/xquery/#id-content">http://www.w3.org/TR/xquery/#id-content</ulink>). The construction and copy-namespaces modes used during the copy operation are the ones in the static context of the invoking module. Let $nodes be the sequence containing the copied nodes. Every node in $nodes is a parent-less root node that does not belong to any collection and is distinct from any other node in $nodes. </para></listitem>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of a single update primitive: upd:insertFirstIntoCollection($collectionName, $nodes). </para></listitem>
</itemizedlist>
</para><para>The update primitive is applied as follows:</para><para><itemizedlist>
<listitem>
<para>The document container for the collection is found via the collections table.  </para></listitem>
<listitem>
<para>The root nodes in $nodes are inserted at the &quot;beginning&quot; of the container. Specifically, the first node is inserted at the first position, and the rest of the nodes are inserted after the first one and in the same order as they appear in $nodes. </para></listitem>
</itemizedlist>
</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:insert-nodes-last($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,<sp/>$nodes<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>upd:insertLastIntoCollection($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,<sp/>$nodes<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*)</highlight></codeline>
</programlisting></para><para>The insert-nodes-last function is evaluated the same way as the insert-nodes-first function except:</para><para><itemizedlist>
<listitem>
<para>If the collection is &apos;an:append-only&apos; or &apos;an:queue&apos;, the insertion is allowed (i.e., the errors ZDDY0005 or ZDDY0006 are not raised). </para></listitem>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of a single update primitive: upd:insertLastIntoCollection($collectionName, $nodes). </para></listitem>
</itemizedlist>
</para><para>The update primitive is applied as follows:</para><para><itemizedlist>
<listitem>
<para>The document container for the collection is found via the collections table. </para></listitem>
<listitem>
<para>The root nodes in $nodes are inserted at the &quot;end&quot; of the container. Specifically, the first node is inserted after the last existing node, and rest of the nodes are inserted after the first one and in the same order as they appear in $nodes. </para></listitem>
</itemizedlist>
</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:insert-nodes-before($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,<sp/>$target<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node(),<sp/>$nodes<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>upd:insertBeforeIntoCollection($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,<sp/>$target<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node(),<sp/>$nodes<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*)</highlight></codeline>
</programlisting></para><para>The insert-nodes-before function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>If the given expanded QName does not identify a collection among the statically known collections in the static context of the invoking module, an error is raised [<ulink url="#ERRZDDY0001">zerr:ZDDY0001</ulink>]. </para></listitem>
<listitem>
<para>If the given expanded QName does not identify a collection among the available collections in the dynamic context of the invoking module, an error is raised [<ulink url="#ERRZDDY0003">zerr:ZDDY0003</ulink>]. </para></listitem>
<listitem>
<para>If the update mode of the collection is &apos;an:const&apos;, &apos;an:append-only&apos;, or &apos;an:queue&apos;, an error is raised [<ulink url="#ERRZDDY0004">zerr:ZDDY0004</ulink>], [<ulink url="#ERRZDDY0005">zerr:ZDDY0005</ulink>], or [<ulink url="#ERRZDDY0006">zerr:ZDDY0006</ulink>], respectively. </para></listitem>
<listitem>
<para>If the collection is &apos;an:unordered&apos;, an error is raised [<ulink url="#ERRZDDY0012">zerr:ZDDY0012</ulink>]. </para></listitem>
<listitem>
<para>The expression that appears as the second argument to the function call is evaluated. The expression must return a single node, called the target node. If the target node is not a root node that belongs to the collection, an error is raised [<ulink url="#ERRZDDY0011">zerr:ZDDY0011</ulink>]. </para></listitem>
<listitem>
<para>The expression that is given as the third argument to the function call is evaluated. The result of the evaluation is called the source sequence. If the source sequence contains an item that is not a node, or a node whose actual type does not match the KindTest specified in the collection declaration, a type error is raised [<ulink url="#ERRXDTY0001">zerr:XDTY0001</ulink>]. </para></listitem>
<listitem>
<para>Each of the nodes in the source sequence is copied as if it was a node returned by an enclosed expression in a direct element constructor (see <ulink url="http://www.w3.org/TR/xquery/#id-content">http://www.w3.org/TR/xquery/#id-content</ulink>). The construction and copy-namespaces modes used during the copy operation are the ones in the static context of the invoking module. Let $nodes be the sequence containing the copied nodes. Every node in $nodes is a parent-less root node that does not belong to any collection and is distinct from any other node in $nodes. </para></listitem>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of a single update primitive: upd:insertBeforeIntoCollection($collectionName, $target, $nodes). </para></listitem>
</itemizedlist>
</para><para>The update primitive is applied as follows:</para><para><itemizedlist>
<listitem>
<para>The document container for the collection is found via the collections table. </para></listitem>
<listitem>
<para>The root nodes in $nodes are inserted into the container before the given target node. Specifically, if the target node is at position K, the first node is inserted at position K, and rest of the nodes are inserted after the first one and in the same order as they appear in $nodes. After the insertion, the target node will at position K+N, where N is the number of nodes in $nodes. </para></listitem>
</itemizedlist>
</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:insert-nodes-after($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,<sp/>$target<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node(),<sp/>$nodes<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>upd:insertAfterIntoCollection($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,<sp/>$target<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node(),<sp/>$nodes<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*)</highlight></codeline>
</programlisting></para><para>The insert-nodes-after function is evaluated the same way as the insert-nodes-before function except:</para><para><itemizedlist>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of a single update primitive: upd:insertAfterIntoCollection($collectionName, $target, $nodes). </para></listitem>
</itemizedlist>
</para><para>The update primitive is applied as follows:</para><para><itemizedlist>
<listitem>
<para>The document container for the collection is found via the collections table. </para></listitem>
<listitem>
<para>The root nodes in $nodes are inserted into the container after the given target node. Specifically, if the target node is at position K, the first node is inserted at position K+1, and rest of the nodes are inserted after the first one and in the same order as they appear in $nodes. </para></listitem>
</itemizedlist>
</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:</highlight><highlight class="keyword">delete</highlight><highlight class="normal">-nodes($nodes<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:node()*)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>upd:deleteFromCollection($nodes<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:node()*)</highlight></codeline>
</programlisting></para><para>The delete-nodes function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>The expression that appears as the first argument to the function call is evaluated. The result of this evaluation is called the deletion sequence. If there is any node in the deletion sequence that is not a root node belonging to a collection, an error is raised [<ulink url="#ERRZDDY0011">zerr:ZDDY0011</ulink>]. Let $nodes be the deletion sequence. </para></listitem>
<listitem>
<para>If the update mode of a collection of any node is &apos;an:const&apos;, &apos;an:append-only&apos;, or &apos;an:queue&apos;, an error is raised [<ulink url="#ERRZDDY0004">zerr:ZDDY0004</ulink>], [<ulink url="#ERRZDDY0007">zerr:ZDDY0007</ulink>], or [<ulink url="#ERRZDDY009">zerr:ZDDY009</ulink>], respectively. </para></listitem>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of a single update primitive: upd:deleteFromCollection($nodes). </para></listitem>
</itemizedlist>
</para><para>The update primitive is applied as follows:</para><para><itemizedlist>
<listitem>
<para>The document container for the collection is found via the collections table.  </para></listitem>
<listitem>
<para>Each document that is rooted at a node in $nodes is removed from the container, if it is still there (earlier delete primitives in the same PUL may have deleted the tree already). If there are no variables that are bound to any of the document&apos;s nodes, the document is destroyed. Otherwise, the document will be destroyed as soon as there are no variables bound to any of its nodes.  </para></listitem>
</itemizedlist>
</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:</highlight><highlight class="keyword">delete</highlight><highlight class="normal">-nodes-first($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,<sp/>$number<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:unsignedLong)</highlight></codeline>
</programlisting></para><para>The delete-nodes-first function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>If the given expanded QName does not identify a collection among the statically known collections in the static context of the invoking module, an error is raised [<ulink url="#ERRZDDY0001">zerr:ZDDY0001</ulink>]. </para></listitem>
<listitem>
<para>If the given expanded QName does not identify a collection among the available collections in the dynamic context of the invoking module, an error is raised [<ulink url="#ERRZDDY0003">zerr:ZDDY0003</ulink>]. </para></listitem>
<listitem>
<para>If the update mode of the collection is const, or append-only, an error is raised [<ulink url="#ERRZDDY0004">zerr:ZDDY0004</ulink>] or [<ulink url="#ERRZDDY0007">zerr:ZDDY0007</ulink>] respectively. </para></listitem>
<listitem>
<para>The expression that appears as the second argument to the function call is evaluated, producing a single positive integer. Let $number be that integer. </para></listitem>
<listitem>
<para>If the collection has fewer than $number nodes, an error is raised [<ulink url="#ERRZDDY0011">zerr:ZDDY0011</ulink>]. </para></listitem>
<listitem>
<para>Let $nodes be the sequence consisting of the first $number root nodes in the collection. </para></listitem>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of a single update primitive: upd:deleteFromCollection($collectionName, $nodes). </para></listitem>
</itemizedlist>
</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:</highlight><highlight class="keyword">delete</highlight><highlight class="normal">-node-first($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName)</highlight></codeline>
</programlisting></para><para>The delete-node-first function is a special case of the delete-nodes-first function. Specifically, delete-node-first($collectionName) is equivalent to delete-nodes-first($collectionName, 1).</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:</highlight><highlight class="keyword">delete</highlight><highlight class="normal">-nodes-last($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,<sp/>$number<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:unsignedLong)</highlight></codeline>
</programlisting></para><para>The delete-nodes-last function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>If the given expanded QName does not identify a collection among the statically known collections in the static context of the invoking module, an error is raised [<ulink url="#ERRZDDY0001">zerr:ZDDY0001</ulink>]. </para></listitem>
<listitem>
<para>If the given expanded QName does not identify a collection among the available collections in the dynamic context of the invoking module, an error is raised [<ulink url="#ERRZDDY0003">zerr:ZDDY0003</ulink>]. </para></listitem>
<listitem>
<para>If the update mode of the collection is const, append-only, or queue, an error is raised [<ulink url="#ERRZDDY0004">zerr:ZDDY0004</ulink>], [<ulink url="#ERRZDDY0007">zerr:ZDDY0007</ulink>], or [<ulink url="#ERRZDDY009">zerr:ZDDY009</ulink>], respectively. </para></listitem>
<listitem>
<para>The expression that appears as the second argument to the function call is evaluated, producing a single positive integer. Let $number be that integer. </para></listitem>
<listitem>
<para>If the collection has fewer than $number nodes, an error is raised [<ulink url="#ERRZDDY0011">zerr:ZDDY0011</ulink>]. </para></listitem>
<listitem>
<para>Let $nodes be the sequence consisting of the last $number root nodes in the collection. </para></listitem>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of a single update primitive: upd:deleteFromCollection($collectionName, $nodes). </para></listitem>
</itemizedlist>
</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cdml:</highlight><highlight class="keyword">delete</highlight><highlight class="normal">-node-last($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName)</highlight></codeline>
</programlisting></para><para>The delete-node-last function is a special case of the delete-nodes-lasst function. Specifically, delete-node-last($collectionName) is equivalent to delete-nodes-last($collectionName, 1).</para></sect2>
<sect2 id="xqddf_1destroying_collections">
<title>Destroying Collections</title>
<para>To destroy a collection, Zorba provides the <computeroutput>delete</computeroutput> updating function. The function itself and its associated update primitive are described below.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>cddl:</highlight><highlight class="keyword">delete</highlight><highlight class="normal">($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>upd:deleteCollection($collectionName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs<sp/>:QName)</highlight></codeline>
</programlisting></para><para>The delete function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>If the given expanded QName does not identify a collection among the statically known collections in the static context of the invoking module, an error is raised [<ulink url="#ERRZDDY0001">zerr:ZDDY0001</ulink>]. </para></listitem>
<listitem>
<para>If the given expanded QName does not identify a collection among the available collections in the dynamic context of the invoking module, an error is raised [<ulink url="#ERRZDDY0003">zerr:ZDDY0003</ulink>]. </para></listitem>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of a single update primitive: upd:deleteCollection($collectionName). </para></listitem>
</itemizedlist>
</para><para>The update primitive is applied as follows:</para><para><itemizedlist>
<listitem>
<para>If there is any available index whose domain expression or any of its key expressions reference the collection, an error is raised [<ulink url="#ERRZDDY0013">zerr:ZDDY0013</ulink>]. </para></listitem>
<listitem>
<para>If there is any active integrity constraint on the collection, an error is raised [<ulink url="#ERRZDDY0014">zerr:ZDDY0014</ulink>]. </para></listitem>
<listitem>
<para>If there is any in-scope variable that references any node in the collection, an error is raised [<ulink url="#ERRZDDY0015">zerr:ZDDY0015</ulink>]. </para></listitem>
<listitem>
<para>The document container for the collection is found via the collections table. </para></listitem>
<listitem>
<para>All documents in the container are destroyed. </para></listitem>
<listitem>
<para>The container itself is destroyed. </para></listitem>
<listitem>
<para>The entry mapping the collection name to its container is removed from the collections table. </para></listitem>
</itemizedlist>
</para></sect2>
</sect1>
<sect1 id="xqddf_1indexes">
<title>Indexes</title>
<para><linebreak/>
 Zorba supports two kinds of indexes, <bold>value indexes</bold> and <bold>general indexes</bold>. As shown in <ref refid="xqddf_1indexes_in_action" kindref="member">Indexes in action - A simple example</ref>, value indexes can be used to optimize queries involving value comparisons, whereas general indexes can be used to optimize queries involving value and/or general comparisons. Although general indexes can handle both kinds of comparisons, value indexes are more compact and efficient, and as a result, they should be preferred over general indexes for data on which no general comparisons are expected.</para><para><linebreak/>
 <linebreak/>
 A value index is a set whose contents (called <bold>index entries</bold>) are defined by a &quot;domain&quot; expression and a number of &quot;key&quot; expressions. Informally, a value index is created by evaluating its domain expression first, resulting in a sequence of nodes (called the index <bold>domain sequence</bold>). Then, for each node D in the domain sequence, the key expressions are evaluated with node D serving as their context node. A key expression must not return more than one value. If a value returned by a key expression is not atomic, it is converted to an atomic value via atomization. Thus, if N is the number of key expressions, then for each domain node, an associated <bold>key tuple</bold> of N atomic values is constructed. The purpose of the index is to map key tuples to domain nodes. In general, several domain nodes may produce the same key tuple. As a result, each index entry is a pair consisting of a key tuple and the set of domain nodes that produced the key tuple.</para><para><linebreak/>
 <linebreak/>
 General comparison operators accept operands that are sequences potentially containing more than one item. As a result, the main difference between value and general indexes is the the later allow a key expression to return multiple values with potentially different data types. On the other hand, for simplicity, the current Zorba implementation restricts the number of key expressions for general indexes to one expression only.</para><para><linebreak/>
 <linebreak/>
 Like value indexes, general indexes are sets of index entries, where each index entry is a pair consisting of an atomic key value and the set of associated domain nodes. Informally, the set of entries for a general index is created by evaluating its domain expression first, resulting in a sequence of domain nodes. Then, for each node D in the domain sequence, the key expression is evaluated with node D serving as its context node. A key expression may return a sequence of arbitrary number of items, called the <bold>key sequence</bold>. Items in the key sequence may have different data types. If an item in the key sequence is a node, it is converted to one or more atomic values via atomization, and the atomic values replace the node in the key sequence. If an item in the key sequence has type xs:untypedAtomic, it is removed from the key sequence and is cast to every other atomic built-in type. Then, for each successful cast, the resulting atomic value is put into the key sequence. Thus, for each domain node D, a key sequence is constructed that contains atomic values none of which has type xs:untypedAtomic. For each value K in this key sequence, the pair [K, D] is inserted in the index. If an entry for K exists already, D is inserted in the associated set of domain nodes; otherwise a new index entry is created, mapping K to the set { D }.</para><para><linebreak/>
 Zorba supports the following five operations on indexes: <ulink url="#index_declaration">declaration</ulink>, <ulink url="#index_creation">creation</ulink>, <ulink url="#index_deletion">deletion</ulink>, <ulink url="#index_probing">probing</ulink> and <ulink url="#index_maintenance">maintenance</ulink>. These are explained briefly in the following simple example. Full details for each operation are provided in the subsections after the example.</para><sect2 id="xqddf_1indexes_in_action">
<title>Indexes in action - A simple example</title>
<para><linebreak/>
 Let us consider the same news application we used in <ref refid="xqddf_1collections_in_action" kindref="member">Collections in action - A simple example</ref>. In this example, we will show how to create and use indexes on the collections of the news organization. First, let us assume that each employee has a city where he/she is currently stationed at. We want to create an index that maps city names to the employees that are stationed in those cities. The index will contain one entry for each city where at least one employee is stationed in. Let us also assume that we want to search for journalists based on the number of articles they have written. For this, we will create an index that maps article counts to the employees who are journalists and have produced that number of articles. Finally, we want to be able to quickly find the manager of any given employee. For this, we will create an index that maps employee ids to the manager of the associated employee.</para><para><linebreak/>
 <linebreak/>
 Before an index can be created, it must be declared. An <ulink url="#index_declaration">index declaration</ulink> describes the index by providing its domain expression, its key expressions, and certain index properties (declared as annotations); it also specifies a name for referencing the index in subsequent operations. Like collections, indexes must be declared inside the prolog of library modules. In terms of the XQuery language, index declarations become part of a module&apos;s static context.</para><para><linebreak/>
 <linebreak/>
 In this example, the index declarations are placed inside the <ulink url="#lib_module_news_data_indexes">&quot;news-data&quot;</ulink> library module shown below (same as the module we saw in <ref refid="xqddf_1collections_in_action" kindref="member">Collections in action - A simple example</ref>, except for the additional index declarations). The first index declaration assigns the name news-data:CityEmp to the index. It uses the &quot;on nodes&quot; and &quot;by&quot; keywords to specify the domain and key expressions respectively. The &quot;as&quot; keyword specifies a target atomic data type which the result of the key expression must match with (after atomization). The index is declared as a &apos;an:value-equality&apos; index. This means that it can be used to find the employees in a particular city, but not in a &quot;range&quot; of cities. In other words, the index is not aware of any ordering among city names. Finally, the maintenance property of the index is set to &quot;automatically maintained&quot; (&apos;an:automatic&apos;). Briefly, an automatically maintained index is one whose maintenance is the responsibility of Zorba rather than the XQuery programmers.</para><para><linebreak/>
 <linebreak/>
 The second index declaration assigns the name news-data:ArtCountEmp to the index. Its domain expression selects all employees who are journalists. Its key expression computes the number of articles written by the &quot;current&quot; journalist. This index is declared as a &quot;value range&quot; (&apos;an:value-range&apos;) index, which means that it can be used to find journalists whose article count is within a given range. Finally, the index is also declared as &quot;manually
maintained&quot; (&apos;an:manual&apos;), which means that programmers must explicitly request that the index be synchronized with the underlying data.</para><para><linebreak/>
 <linebreak/>
 The last index declaration assigns the name news-data:EmpMgr to the index. The index is declared as a &apos;an:general-equality&apos; index, which, like &apos;an:value-equality&apos; means that the index does not maintain its keys in any order. The index key expression selects, for each employee E, the ids of the employees managed by E. Notice that this set of ids may be empty. The index will contain an entry mapping the empty sequence to the employees who do not manage anybody. Notice also that no type declaration is required for the key expression. Typically, the employee ids will all be integers or strings or untypedAtomic. All of these cases can be handled by the news-data:EmpMgr index, as well as the not very likely scenario where different kinds of employees have ids of different data types.</para><para><anchor id="_1lib_module_news_data_indexes"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/>The<sp/></highlight><highlight class="stringliteral">&quot;news-data&quot;</highlight><highlight class="normal"><sp/>Library<sp/>Module<sp/>:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">cdml<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/collections/dml&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>schema<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-schemas<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/schemas&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal"><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref><sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/annotations&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>collection<sp/>news-data:employees<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>schema-element(news-schema:employee)*;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>collection<sp/>news-data:articles<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:<ref refid="namespacezorba_1acf239253638cf017b2a8e29f47be25d3ac9eb30d96464f101853e7daea626bd98" kindref="member">ordered</ref><sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:read-only-nodes<sp/>collection<sp/>news-data:months</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>schema-element(news-schema:month)*;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:automatic<sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:value-equality<sp/>index<sp/>news-data:CityEmp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>on<sp/>nodes<sp/>cdml:collection(xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:employees&quot;</highlight><highlight class="normal">))/employee</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>by<sp/>.</highlight><highlight class="comment">//station/city<sp/>as<sp/>xs:string;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:manual<sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:value-range<sp/>index<sp/>news-data:ArtCountEmp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>on<sp/>nodes<sp/>cdml:collection(xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:employees&quot;</highlight><highlight class="normal">))/employee[./position/@<ref refid="namespacezorba_1_1diagnostic_1a5709afb398f65a318160aa7613abfa9e" kindref="member" tooltip="An diagnostic::kind is the kind of error.">kind</ref><sp/>eq<sp/></highlight><highlight class="stringliteral">&quot;journalist&quot;</highlight><highlight class="normal">]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>by<sp/>count(</highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>$art<sp/>in<sp/>cdml:collection(xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:articles&quot;</highlight><highlight class="normal">))</highlight><highlight class="comment">//article</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>where<sp/>$art/empid<sp/>=<sp/>./</highlight><highlight class="keywordtype">id</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>$art)<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:integer;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:automatic<sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:general-equality<sp/>index<sp/>news-data:EmpMgr</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>on<sp/>nodes<sp/>cdml:collection(xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:employees&quot;</highlight><highlight class="normal">))/employee</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>by<sp/>./manages</highlight><highlight class="comment">//@empid;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>variable<sp/>$news-data:employees<sp/>:=<sp/>xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:employees&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>variable<sp/>$news-data:articles<sp/>:=<sp/>xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:articles&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>variable<sp/>$news-data:months<sp/>:=<sp/>xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:months&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>variable<sp/>$news-data:CityEmp<sp/>:=<sp/>xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:CityEmp&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>variable<sp/>$news-data:ArtCountEmp<sp/>:=<sp/>xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:ArtCountEmp&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>variable<sp/>$news-data:EmpMgr<sp/>:=<sp/>xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:EmpMgr&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para><para>Having declared the indexes in a library module, they can now be created. This is done by the <ulink url="#admin_script_3">&quot;admin-script-3&quot;</ulink> script shown below. The script must first import the <ulink url="#lib_module_news_data_indexes">&quot;news-data&quot;</ulink> module. As far as indexes are concerned, the effect of this import is to create three entries in the static context of the main module, mapping the index names to the index definitions (domain expression, key specification, and properties). Then, the query creates the indexes by invoking the <ulink url="#create_index">iddl:create</ulink> function, passing the name of the index as input.</para><para><linebreak/>
 <linebreak/>
 Let us consider the creation of the CityEmp index (the process is the similar for the ArtCountEmp and EmpMgr indexes). <ulink url="#index_creation">Index Creation</ulink> starts with retrieving the index definition from the static context, using the index name. Then, an index container is created, whose entries will be pairs associating a city name with a set of employees. Next, the index container is populated using the process outlined earlier: The domain expression is evaluated, and for each employee node E in the domain sequence, the name of the city C where the employee is currently stationed in is retrieved by evaluating the key expression, atomizing its result, and checking that the atomic value matches the specified target type. Finally, the pair [E, C] is inserted in the index: if an entry for C exists already, E is inserted in the set associated with C; otherwise, an new entry is created mapping C to the set { E }. The last step in index creation involves registering the index inside an <bold>indexes table</bold> that maps index names to index containers. The index container will remain registered until it is destroyed by a call to the <ulink url="#delete_index">iddl:delete</ulink> function (see the <ulink url="#admin_script_4">&quot;admin-script-4&quot;</ulink> script below).</para><para><anchor id="_1admin_script_3"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/>The<sp/></highlight><highlight class="stringliteral">&quot;admin-script-3&quot;</highlight><highlight class="normal"><sp/>script<sp/>:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>iddf<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/indexes/ddl&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal"><sp/>at<sp/></highlight><highlight class="stringliteral">&quot;news_data.xqlib&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>iddf:create($news-data:CityEmp);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>iddf:create($news-data:ArtCountEmp);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>iddf:create($news-data:EmpMgr);</highlight></codeline>
</programlisting></para><para>The next step in this example is to show how the index can be used to to optimize query performance, which of course, is the primary motivation for supporting indexes in any data-processing system. Zorba provides four functions for <ulink url="#index_probing">index probing</ulink>: <ulink url="#probe_index_point_value">idml:probe-index-point-value</ulink>, <ulink url="#probe_index_range_value">idml:probe-index-range-value</ulink>, <ulink url="#probe_index_point_general">idml:probe-index-point-general</ulink>, and <ulink url="#probe_index_range_general">idml:probe-index-range-general</ulink>. idml:probe-index-point-value is supported by all kind of indexes, idml:probe-index-point-general is supported by general indexes (equality and range), idml:probe-index-range-value is supported by value and general range indexes, and idml:probe-index-range-general is supported by general range indexes only.</para><para><linebreak/>
 <linebreak/>
 The <ulink url="#query_probe_1">&quot;probe-1&quot;</ulink> query illustrates the use of idml:probe-index-point-value. The query returns the names of all employees stationed in Paris. As shown, the idml:probe-index-point-value function takes the index name and the keyword &quot;Paris&quot; as inputs. It uses the index name to find the index container via the indexes tables, looks-up the entry for &quot;Paris&quot; inside this container, and returns all the associated employee nodes.</para><para><linebreak/>
 <linebreak/>
 The <ulink url="#query_probe_2">&quot;probe-2&quot;</ulink> query illustrates index probing via the idml:probe-index-range-value function. The query returns all journalists who have written at least 100 articles. As shown, the first parameter of the idml:probe-index-range-value function is the index name, followed by 6 parameters per key expression. The 6 parameters specify a range of value for the key values: the first 2 are the lower and upper values of the range, the next two are booleans that specify whether the range does indeed have a lower and/or upper bound, and the last 2 are also booleans that specify whether the range is open or closed from below or above (i.e., whether the lower/upper bound are included in the range or not).</para><para><linebreak/>
 <linebreak/>
 The <ulink url="#query_probe_3">&quot;probe-3&quot;</ulink> query illustrates the use of idml:probe-index-point-general. The query returns the managers of the employees whose id is of type string (or subtype) and its value is &quot;100&quot; or &quot;200&quot;. It will also return the managers of the employees whose id is of type untypedAtomic and its value, when cast to string, is &quot;100&quot; or &quot;200&quot;.</para><para><linebreak/>
 <linebreak/>
 The <ulink url="#query_no_probe_1">&quot;no-probe-1&quot;</ulink>, <ulink url="#query_no_probe_2">&quot;no-probe-2&quot;</ulink>, <ulink url="#query_no_probe_3">&quot;no-probe-3&quot;</ulink> queries return the same results as <ulink url="#query_probe_1">&quot;probe-1&quot;</ulink>, <ulink url="#query_probe_2">&quot;probe-2&quot;</ulink>, and <ulink url="#query_probe_3">&quot;probe-3&quot;</ulink>, respectively, but without using any index. Normally, the performance of the probe queries will be much better than that of the corresponding no-probe queries. This is because, in general, indexes organize their entries in ways that make the execution of the probe functions very efficient. Typically, some kind of a hash table (for value equality indexes) or ordered tree (for value range indexes) data structure is employed, and as we will see, Zorba support both kinds of indexes. So, for example, the <ulink url="#query_probe_1">&quot;probe-1&quot;</ulink> query does not have to access every entry in the index until it finds the one for Paris, whereas the <ulink url="#query_no_probe_1">&quot;no-probe-1&quot;</ulink> query has to access every employee in the collection and check his/her city.</para><para><linebreak/>
 <linebreak/>
 People familiar with SQL and modern relational DBMSs would probably expect the query optimizer to be able to automatically rewrite queries like <ulink url="#query_no_probe_1">&quot;no-probe-1&quot;</ulink> to queries like <ulink url="#query_probe_1">&quot;probe-1&quot;</ulink>. The Zorba query optimizer does not yet detect index-related rewrites automatically. Although, we do plan to offer automatic index-related rewrites in the near future, we also expect the probing functions to remain useful for manual rewrites because both the XQuery language and the kind of indexes that are allowed in Zorba can be much more complex than their relational counterparts.</para><para><anchor id="_1query_probe_1"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/>The<sp/></highlight><highlight class="stringliteral">&quot;probe-1&quot;</highlight><highlight class="normal"><sp/>query<sp/>:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>idml<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/indexes/dml&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal"><sp/>at<sp/></highlight><highlight class="stringliteral">&quot;news_data.xqlib&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>idml:probe-index-point-value($news-data:CityEmp,<sp/></highlight><highlight class="stringliteral">&quot;Paris&quot;</highlight><highlight class="normal">)</highlight></codeline>
</programlisting></para><para><anchor id="_1query_probe_2"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/>The<sp/></highlight><highlight class="stringliteral">&quot;probe-2&quot;</highlight><highlight class="normal"><sp/>query<sp/>:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>idml<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/indexes/dml&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal"><sp/>at<sp/></highlight><highlight class="stringliteral">&quot;news_data.xqlib&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>idml:probe-index-range-value($news-data:ArtCountEmp,<sp/>100,<sp/>(),<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">)</highlight></codeline>
</programlisting></para><para><anchor id="_1query_probe_3"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/>The<sp/></highlight><highlight class="stringliteral">&quot;probe-3&quot;</highlight><highlight class="normal"><sp/>query<sp/>:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>idml<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/indexes/dml&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal"><sp/>at<sp/></highlight><highlight class="stringliteral">&quot;news_data.xqlib&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>idml:probe-index-point-general($news-data:EmpMgr,<sp/>(</highlight><highlight class="stringliteral">&quot;100&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;200&quot;</highlight><highlight class="normal">))</highlight></codeline>
</programlisting></para><para><anchor id="_1query_no_probe_1"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/>The<sp/></highlight><highlight class="stringliteral">&quot;no-probe-1&quot;</highlight><highlight class="normal"><sp/>query<sp/>:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>cdml<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/collections/dml&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal"><sp/>at<sp/></highlight><highlight class="stringliteral">&quot;news_data.xqlib&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cdml:collection($news-data:employees)/employee[.</highlight><highlight class="comment">//station/city<sp/>eq<sp/>&quot;Paris&quot;]</highlight></codeline>
</programlisting></para><para><anchor id="_1query_no_probe_2"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/>The<sp/></highlight><highlight class="stringliteral">&quot;no-probe-2&quot;</highlight><highlight class="normal"><sp/>query<sp/>:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>cdml<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/collections/dml&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal"><sp/>at<sp/></highlight><highlight class="stringliteral">&quot;news_data.xqlib&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>$emp<sp/>in<sp/>cdml:collection($news-data:employees)/employee[./position/@<ref refid="namespacezorba_1_1diagnostic_1a5709afb398f65a318160aa7613abfa9e" kindref="member" tooltip="An diagnostic::kind is the kind of error.">kind</ref><sp/>eq<sp/></highlight><highlight class="stringliteral">&quot;journalist&quot;</highlight><highlight class="normal">]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>where<sp/>100<sp/>le<sp/>count(</highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>$art<sp/>in<sp/>cdml:collection(xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:articles&quot;</highlight><highlight class="normal">))</highlight><highlight class="comment">//article</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>where<sp/>$art/empid<sp/>eq<sp/>$emp/</highlight><highlight class="keywordtype">id</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>$art)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>$emp</highlight></codeline>
</programlisting></para><para><anchor id="_1query_no_probe_3"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/>The<sp/></highlight><highlight class="stringliteral">&quot;probe-3&quot;</highlight><highlight class="normal"><sp/>query<sp/>:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>cdml<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/collections/dml&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal"><sp/>at<sp/></highlight><highlight class="stringliteral">&quot;news_data.xqlib&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>$mgr<sp/>in<sp/>cdml:collection($news-data:employees)/employee</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>where<sp/>$mgr/manages</highlight><highlight class="comment">//@empid<sp/>=<sp/>(&quot;100&quot;,<sp/>&quot;200&quot;)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>$mgr</highlight></codeline>
</programlisting></para><para><linebreak/>
 <linebreak/>
 Now, let us consider what happens when the data on which an index is built gets updated. In general, <ulink url="#index_maintenance">index maintenance</ulink> is the operation where the index contents are updated so that they reflect the index definition with respect to the current snapshot of the data. Zorba offers two maintenance modes: manual and automatic. If an index is declared as &apos;an:manual&apos;, index maintenance is done only when the function <ulink url="#refresh_index">idml:refresh-index</ulink> is invoked inside a query. Essentially, in manual mode maintenance is in the control of the query programmers, and the index may become stale between two consecutive calls to the <ulink url="#refresh_index">idml:refresh-index</ulink> function. In contrast, if an index is declared as &apos;an:automatic&apos;, Zorba guarantees that the index stays up-to-date at any given time.</para><para><linebreak/>
 <linebreak/>
 In this example, the CityEmp index was declared as automatic. The <ulink url="#query_index_maintenance">&quot;index-maintenance&quot;</ulink> query shown below transfers the employee with id &quot;007&quot; from his current city, say Paris, to Beijing. Since index CityEmp is automatic, after the update is applied, Zorba will initiate a maintenance operation on the index, whereby the employee node will be removed from the node set associated with Paris and inserted into the node set associated with Beijing (if there is no other employee stationed in Beijing already, an entry for it will be created first). Notice that although the index is not explicitly referenced anywhere in this query, its definition must still be available to the query because it is needed to perform the index maintenance. In this example, the query imports the <ulink url="#lib_module_news_data_indexes">&quot;news-data&quot;</ulink> module because it contains the declaration for the employees collection, which is referenced by the query. But the <ulink url="#lib_module_news_data_indexes">&quot;news-data&quot;</ulink> module contains the index declaration as well, so index maintenance can find the index definition. In general, it is a best practice to declare an index in the same module as the collections that are referenced by the index.</para><para><linebreak/>
 <linebreak/>
 The ArtCountEmp index is more complex than the CityEmp index, so the system may not be able to maintain it in an efficient way. Furthermore, the index contains &quot;statistical&quot; information, so it may be acceptable if its contents are not always in sync with the underlying data. For these reasons, the ArtCountEmp index was declared as &apos;an:manual&apos;.</para><para><anchor id="_1query_index_maintenance"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/>The<sp/></highlight><highlight class="stringliteral">&quot;index-maintenance&quot;</highlight><highlight class="normal"><sp/>query<sp/>:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>cdml<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/collections/dml&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal"><sp/>at<sp/></highlight><highlight class="stringliteral">&quot;news_data.xqlib&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>replace<sp/>node<sp/>value<sp/>cdml:collection($news-data:employees)/employee[@</highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>eq<sp/></highlight><highlight class="stringliteral">&quot;007&quot;</highlight><highlight class="normal">]</highlight><highlight class="comment">//station/city</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>with<sp/></highlight><highlight class="stringliteral">&quot;Beijing&quot;</highlight></codeline>
</programlisting></para><para>Finally, we conclude this example with a query that shows how to destroy an index. As shown in <ulink url="#admin_script_4">&quot;admin-script-4&quot;</ulink> below, <ulink url="#index_deletion">index deletion</ulink> is done via the <ulink url="#delete_index">iddl:delete</ulink> function. The function simply destroys the index container and removes the mapping between the index name and the index container from the indexes table. After the index is deleted, any query that tries to access the index will receive an error.</para><para><anchor id="_1admin_script_4"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>(:<sp/>The<sp/></highlight><highlight class="stringliteral">&quot;admin-script-4&quot;</highlight><highlight class="normal"><sp/>query<sp/>:)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace</highlight><highlight class="normal"><sp/>iddl<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/indexes/ddl&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">import</highlight><highlight class="normal"><sp/>module<sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">news-data<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;http://www.news.org/data&quot;</highlight><highlight class="normal"><sp/>at<sp/></highlight><highlight class="stringliteral">&quot;news_data.xqlib&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>iddl:</highlight><highlight class="keyword">delete</highlight><highlight class="normal">($news-data:CityEmp);</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="xqddf_1index_declaration">
<title>Index Declaration</title>
<para><programlisting><codeline><highlight class="normal"><sp/><sp/>IndexDecl<sp/>::=<sp/></highlight><highlight class="stringliteral">&apos;index&apos;</highlight><highlight class="normal"><sp/>IndexName</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&apos;on&apos;</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&apos;nodes&apos;</highlight><highlight class="normal"><sp/>IndexDomainExpr</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&apos;by&apos;</highlight><highlight class="normal"><sp/>IndexKeySpec<sp/>(</highlight><highlight class="charliteral">&apos;,&apos;</highlight><highlight class="normal"><sp/>IndexKeySpec)*</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexName<sp/>::=<sp/>EQName</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexDomainExpr<sp/>::=<sp/>PathExpr</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexKeySpec<sp/>::=<sp/>IndexKeyExpr<sp/>IndexKeyTypeDecl?<sp/>IndexKeyCollation?</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexKeyExpr<sp/>::=<sp/>PathExpr</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexKeyTypeDecl<sp/>::=<sp/></highlight><highlight class="stringliteral">&apos;as&apos;</highlight><highlight class="normal"><sp/>AtomicType<sp/>OccurrenceIndicator?</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>AtomicType<sp/>::=<sp/>EQName</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IndexKeyCollation<sp/>::=<sp/></highlight><highlight class="stringliteral">&apos;collation&apos;</highlight><highlight class="normal"><sp/>URILiteral</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Note:<sp/>the<sp/>following<sp/>annotations<sp/>are<sp/>accepted<sp/>within<sp/>the<sp/>context<sp/>of<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref><sp/>index<sp/>declaration:</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:unique,<sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:nonunique,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:value-range,<sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:value-equality,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:general-range,<sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:general-equality,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:manual<sp/>or<sp/>%<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781abdd3c2de1222fd3167e2675969aa694c" kindref="member" tooltip="Aragonese.">an</ref>:automatic</highlight></codeline>
</programlisting></para><para>Syntactically, each index is defined by an <ulink url="#index_declaration">index declaration</ulink>, which specifies a unique name for the index as a QName, the index domain expression, a number of key specifications, and a set of index properties (given as annotations; see <ref refid="options_and_annotations_1collection_index_annotations" kindref="member">Annotations on Collections and Indexes</ref>). The IndexDecl syntax shown above is common to both value indexes and general indexes. Whether an index is a value or a general index is determined by the value of the usage property, which is explained below.</para><para><linebreak/>
 <linebreak/>
 Index declarations (for both value and general indexes) must be placed inside module prologs. The Prolog syntax is extended accordingly, as shown above. An additional constraint (not expressible syntactically) is that only library modules may contain index declarations [<ulink url="#ERRZDST0023">zerr:ZDST0023</ulink>]. The reasons for this rule are the same as those for collections (see <ref refid="xqddf_1collection_declaration" kindref="member">Collection Declaration</ref>). Furthermore, the qname of an index must have the same namespace URI as the target namespace URI of the declaring library module [<ulink url="#ERRZDST0036">zerr:ZDST0036</ulink>].</para><para><linebreak/>
 <linebreak/>
 To accommodate index declarations, Zorba extends the static context with a component called the <bold>statically known indexes</bold>. This is a map whose entries associate an expanded QName with an implementation-dependent representation of the information contained in an index declaration with the same QName. Each index declaration adds an entry to the statically known indexes of the module containing the declaration. If the expanded QName of the index is equal to the expanded QName of another index in the statically known indexes of the same module, a static error is raised [<ulink url="#ERRZDST0021">zerr:ZDST0021</ulink>]. Like the statically known collections, the statically known indexes of a module that is imported by another module are copied into the statically known indexes of the importing module. It is a static error [<ulink url="#ERRZDST0022">zerr:ZDST0022</ulink>] if the expanded QName of an index declared in an imported module is equal to the expanded QName of an index declared in the importing module or in another imported module (even if the declarations are consistent).</para><para><linebreak/>
 <linebreak/>
 Zorba defines three index properties which are syntactically expressed as annotations: <bold>uniqueness</bold> (with possible values &apos;an:unique&apos; or &apos;an:nonunique&apos;), <bold>usage</bold> (with possible values &apos;an:value-range&apos;, &apos;an:value-equality&apos;, &apos;an:general-range&apos;, or &apos;an:general-equality&apos;), and <bold>maintenance mode</bold> (with possible values &apos;an:manual&apos; or &apos;an:automatic&apos;). The syntax allows the values for these properties to be listed in any order or not be specified at all. If not specified, the default values for uniqueness, usage, and maintenance mode are &apos;an:nonunique&apos;, &apos;an:value-equality&apos;, and &apos;an:automatic&apos;, respectively. It is a static error [zerr::XQST0106] if more than one value is listed in an index declaration for any of these properties.</para><para><linebreak/>
 <linebreak/>
 The uniqueness property determines the kind of relationship between keys and domain nodes: if the index is declared as &apos;an:unique&apos;, Zorba makes sure that the relationship is one-to-one, that is, each index entry associates a key value (or key tuple in the case of value indexs) with exactly one domain node. Otherwise, if the index is &apos;an:nonunique&apos;, multiple domain nodes may have the same key value, and as a result, each index entry associates a key with a set of domain nodes. In the current implementation, it is not allowed to declare an index as unique if it is a general index whose IndexKeyTypeDecl is either absent or specifies xs:anyAtomicType or xs:untypedAtomic as its atomic type [<ulink url="#ERRZDST0025">zerr:ZDST0025</ulink>].</para><para><linebreak/>
 <linebreak/>
 The usage property specifies the kind of the index based on the query expressions that may be optimized by using the index. A <bold>value equality index</bold> can optimize expressions involving value equality predicates only. The <ulink url="#query_probe_1">&quot;probe-1&quot;</ulink> and <ulink url="#query_no_probe_1">&quot;no-probe-1&quot;</ulink> queries in <ref refid="xqddf_1indexes_in_action" kindref="member">Indexes in action - A simple example</ref> are an example of such usage. As shown there, a value equality index supports the <ulink url="#probe_index_point_value">idml:probe-index-point-value</ulink> function. A <bold>value range index</bold> can optimize expressions involving any kind of value comparison. The <ulink url="#query_probe_2">&quot;probe-2&quot;</ulink> and <ulink url="#query_no_probe_2">&quot;no-probe-2&quot;</ulink> queries in <ref refid="xqddf_1indexes_in_action" kindref="member">Indexes in action - A simple example</ref> are an example of such usage. A value range index supports both the <ulink url="#probe_index_point_value">idml:probe-index-point-value</ulink> and the <ulink url="#probe_index_range_value">idml:probe-index-range-value</ulink> functions. A <bold>general equality index</bold> can optimize expressions involving either value equality or general equality predicates. Finally, a <bold>general range index</bold> can optimize expressions involving any kind of value or general comparison predicates.</para><para><linebreak/>
 <linebreak/>
 The maintenance mode specifies how index maintenance is done. The current Zorba implementation offers two maintenance modes: &apos;an:manual&apos; and &apos;an:automatic&apos;. For a <bold>manual index</bold>, maintenance is done only when the function <ulink url="#refresh_index">idml:refresh-index</ulink> (described in <ref refid="xqddf_1index_maintenance" kindref="member">Index Maintenance</ref>) is invoked inside a query. Essentially, in manual mode maintenance is in the control of the query programmers, and the index may become stale between two consecutive calls to the <ulink url="#refresh_index">idml:refresh-index</ulink> function. In contrast, for an <bold>automatic index</bold>, Zorba guarantees that the index stays up-to-date at any given time.</para><para>The index declaration syntax is very liberal with respect to the expressions that can appear as domain or key expressions. However, the following semantic restrictions are imposed on the domain expression and each of the key expressions:</para><para><itemizedlist>
<listitem>
<para>They must be deterministic expressions [<ulink url="#ERRZDST0028">zerr:ZDST0028</ulink>].</para><para></para></listitem>
<listitem>
<para>They must be simple expressions (i.e., not updating or sequential) [<ulink url="#ERRZDST0033">zerr:ZDST0033</ulink>].</para><para></para></listitem>
<listitem>
<para>They must not invoke any input functions other than <ulink url="#cdml_collection">cdml:collection</ulink> [<ulink url="#ERRZDST0029">zerr:ZDST0029</ulink>]. Moreover, the argument to each <ulink url="#cdml_collection">cdml:collection</ulink> call must be a constant expression returning a QName value [<ulink url="#ERRZDST0030">zerr:ZDST0030</ulink>]. (A constant expression is an expression that doesn&apos;t access the dynamic context).</para><para></para></listitem>
<listitem>
<para>They must not reference and variables other than the ones defined inside the expressions themselves [<ulink url="#ERRZDST0031">zerr:ZDST0031</ulink>].</para><para></para></listitem>
<listitem>
<para>If the index is declared as &apos;an:automatic&apos;, an error is raised [<ulink url="#ERRZDST0034">zerr:ZDST0034</ulink>] if the domain and/or the key expressions are too complex for Zorba to perform index maintenance in an efficient manner (see <ref refid="xqddf_1index_maintenance" kindref="member">Index Maintenance</ref> for details) </para></listitem>
</itemizedlist>
</para><para>Furthermore, the domain expression must satisfy the following additional semantic restrictions:</para><para><itemizedlist>
<listitem>
<para>Its context item, context position, and context size are considered undefined, and as a result they must not be referenced [<ulink url="#ERRZDST0032">zerr:ZDST0032</ulink>].</para><para></para></listitem>
<listitem>
<para>It must generate a sequence of nodes [<ulink url="#ERRXDTY0010">zerr:XDTY0010</ulink>].</para><para></para></listitem>
<listitem>
<para>Each node in the domain sequence must belong to a collection that appears in the available collections of the module that contains the index declaration [<ulink url="#ERRZDDY0020">zerr:ZDDY0020</ulink>].</para><para></para></listitem>
<listitem>
<para>For general indexes only, the domain expression should not return any duplicate nodes [<ulink url="#ERRZDDY0028">zerr:ZDDY0028</ulink>] </para></listitem>
</itemizedlist>
</para><para>With each key expression, an index declaration associates a key type and a key collation. The triplet IndexKeyExpr, IndexKeyTypeDecl, IndexKeyCollation is called a <bold>keyspec</bold>. For general indexes, the number of keyspecs must be exectly one [<ulink url="#ERRZDST0035">zerr:ZDST0035</ulink>]. The IndexKeyTypeDecl is optional for general indexes (in which case it is assumed to be xs:anyAtomicItem*), but is required for value indexes [<ulink url="#ERRZDST0027">zerr:ZDST0027</ulink>]. The IndexKeyTypeDecl provides a sequence type that the atomized result of the associated key expression (for each domain node) must match with according to the rules of sequence type matching. For value indexes, the atomic type specified in IndexKeyTypeDecl must not be xs:anyAtomicType or xs:untypedAtomic [<ulink url="#ERRZDST0027">zerr:ZDST0027</ulink>]. Furthermore, for value indexes, the occurrence indicator must be either absent or equal to &apos;?&apos; [<ulink url="#ERRZDST0027">zerr:ZDST0027</ulink>]. Finally, if the index is a value range or general range index, an ordering must exist among the values in the type domain [<ulink url="#ERRZDST0027">zerr:ZDST0027</ulink>] (this rules excludes the following atomic types and their subtypes: QName, NOTATION, hexBinary, hex64Binary, gYearMonth, gYear, gMonthDay, gMonth, and gDay).</para><para><linebreak/>
 <linebreak/>
 If the key type in a keyspec is xs:string (or subtype of), the IndexKeyCollation specifies the collation to use when comparing key values from this keyspec. If no collation is specified, the default collation from the static context of the declaring module is used.</para></sect2>
<sect2 id="xqddf_1index_creation">
<title>Index Creation</title>
<para><linebreak/>
 As explained already, indexes are just sets of index entries, where an index entry maps a key item or a key tuple to a set of domain nodes (to be more precise, an index entry contains some kind of &quot;pointers&quot; to nodes, not the nodes themselves). In terms of the XQuery language, indexes &quot;live&quot; in the dynamic context. In particular, Zorba extends the dynamic context with a component called the <bold>available indexes</bold>. This is a map whose entries associate the expanded QName of an index with the entry set for that index.</para><para><linebreak/>
 <linebreak/>
 In practice, the available indexes component is implemented by Zorba&apos;s storage system. To begin with, each index is implemented by some appropriate data structure that acts as an index entry container. The description of potential data structures is beyond the scope of this document, but the typical choices are either some sort of hash table(s) (for equality indexes) or some kind of ordered tree(s) (for range indexes). To manage these containers, the store maintains an <bold>indexes table</bold>, which maps index names to index entry containers. The indexes table is accessible by all queries, so once an entry is added to the table, the associated index is assumed to be available to every query and every module that participates in the execution of that query.</para><para>Creation of an index involves creating an initially empty index entry container, populating that container with the entries computed by the domain and key expressions of the index, and &quot;registering&quot; that container in the indexes table. All this is done by the <ulink url="#create_index">iddl:create</ulink> function that is described below. In fact, iddl:create is an updating function, so instead of actually creating the index, it generates a pending update primitive that becomes part of a pending update list (PUL) to be applied at a later time. The update primitive is also described below.</para><para><anchor id="_1create_index"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>iddl:create($indexName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>upd:createIndex($indexName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName).</highlight></codeline>
</programlisting></para><para>The create function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>If the given expanded QName does not identify an index among the statically known indexes in the static context of the invoking module, an error is raised [<ulink url="#ERRZDDY0021">zerr:ZDDY0021</ulink>].</para><para></para></listitem>
<listitem>
<para>If the given expanded QName identifies an index that is available already, an error is raised [<ulink url="#ERRZDDY0022">zerr:ZDDY0022</ulink>].</para><para></para></listitem>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of a single update primitive: upd:createIndex($indexName). </para></listitem>
</itemizedlist>
</para><para>The update primitive is applied as follows:</para><para><itemizedlist>
<listitem>
<para>An empty index entry container is created. </para><para></para></listitem>
<listitem>
<para>The domain expression is evaluated first. If the result of the domain expression contains an item that is not a node, an error is raised [<ulink url="#ERRXDTY0010">zerr:XDTY0010</ulink>]. If the result of the domain expression contains any duplicate nodes, then for value indexes, the duplicate nodes are removed, but for general indexes, an error is raised [<ulink url="#ERRZDDY0028">zerr:ZDDY0028</ulink>]. The result of the domain expression after duplicate elimination is called the <bold>domain sequence</bold>. If the domain sequence contains a node that does not belong to a collection, an error is raised [<ulink url="#ERRZDDY0020">zerr:ZDDY0020</ulink>].</para><para></para></listitem>
<listitem>
<para>For each node D in the domain sequence, the IndexKeySpecs are evaluated in some implementation dependent order. An IndexKeySpec is evaluated as follows: </para><para><itemizedlist>
<listitem>
<para>The key expression in the IndexKeySpec is evaluated, with D serving as its context item. </para><para></para></listitem>
<listitem>
<para>Atomization is applied to the result of the key expression.</para><para></para></listitem>
<listitem>
<para>The result of atomization is matched against the associated IndexKeyTypeDecl, according to the rules of sequence type matching. If the type match fails, an error is raised [<ulink url="#ERRXDTY0011">zerr:XDTY0011</ulink>]. </para><para></para></listitem>
<listitem>
<para>Duplicate values (which may arise in the case of general indexes only) are eliminated from the atomized sequence.  </para></listitem>
</itemizedlist>
</para><para></para></listitem>
<listitem>
<para>If the index is a value index: </para><para><itemizedlist>
<listitem>
<para>The result of each IndexKeySpec is a single atomic item or the empty sequence. We call this result a <bold>key value</bold>. </para><para></para></listitem>
<listitem>
<para>Let D<subscript>i</subscript> be the i-th domain node, and K<subscript>ij</subscript> be the key value computed for D<subscript>i</subscript> by the j-th IndexKeySpec (where the numbering of the IndexKeySpecs is done using their order of appearance in the index declaration). Let K<subscript>i</subscript> be the tuple [K<subscript>i1</subscript>, ..., K<subscript>iM</subscript>], where M is the number of IndexKeySpecs. The next step is to insert in the index a mapping from K<subscript>i</subscript> to D<subscript>i</subscript>. This step is performed for each node in the domain sequence. The order in which the domain sequence is processed is implementation dependent. </para><para></para></listitem>
<listitem>
<para>If the index is declared as unique, the relationship between key tuples and domain nodes is one-to-one. In this case, if the index already contains an entry whose key tuple is equal to K<subscript>i</subscript>, an error is raised [<ulink url="#ERRZDDY0024">zerr:ZDDY0024</ulink>]. Otherwise, the entry [K<subscript>i</subscript>, D<subscript>i</subscript>] is inserted in the index container. </para><para></para></listitem>
<listitem>
<para>If the index is non-unique, then if it already contains an entry whose key tuple is equal to K<subscript>i</subscript>, D<subscript>i</subscript> is added to the set associated with K<subscript>i</subscript>. Otherwise, the entry [K<subscript>i</subscript>, { D<subscript>i</subscript> }] is inserted in the index.  </para></listitem>
</itemizedlist>
</para><para></para></listitem>
<listitem>
<para>If the index is a general index: </para><para><itemizedlist>
<listitem>
<para>In the current implementation, there can be only one IndexKeySpec, but contrary to value indexes, the result of this IndexKeySpec may be a sequence of any number of atomic items, and the items may have different data types. We call this sequence a <bold>key sequence</bold>, and each atomic item in it a <bold>key item</bold> (the key sequence may also be the empty sequence). </para><para></para></listitem>
<listitem>
<para>An error is raised [<ulink url="#ERRXDTY0012">zerr:XDTY0012</ulink>] if the index is a range index and any of the key items has a type that is not xs:untypedAtomic and for which no ordering relationship exists. </para><para></para></listitem>
<listitem>
<para>In this step, an <bold>expanded key sequence</bold> is constructed for each domain node. If the atomic type specified in the IndexKeyTypeDecl is neither xs:untypedAtomic nor xs:anyAtomicType, the expanded key sequence is the same as the original key sequence. Otherwise, let D<subscript>i</subscript> be the i-th domain node, and K<subscript>i</subscript> be the key sequence computed for D<subscript>i</subscript>. If any key item in K<subscript>i</subscript> has type xs:untypedAtomic, the item is removed from K<subscript>i</subscript> and is cast to every primitive builtin data type. For each successful cast, the resulting item is inserted back into K<subscript>i</subscript>. </para><para></para></listitem>
<listitem>
<para>The next step is to insert in the index a mapping from K<subscript>ij</subscript> to D<subscript>i</subscript>, for each key item K<subscript>ij</subscript> in the expanded key sequence K<subscript>i</subscript>. This step is performed for each node in the domain sequence. The order in which the domain sequence is processed is implementation dependent. </para><para></para></listitem>
<listitem>
<para>If the index is declared as unique, the relationship between key items and domain nodes is one-to-one. In this case, if the index already contains an entry whose key item is equal to K<subscript>ij</subscript>, an error is raised [<ulink url="#ERRZDDY0024">zerr:ZDDY0024</ulink>]. Otherwise, the entry [K<subscript>ij</subscript>, D<subscript>i</subscript>] is inserted in the index container. </para><para></para></listitem>
<listitem>
<para>If the index is non-unique, then if it already contains an entry whose key K is equal to K<subscript>ij</subscript>, D<subscript>i</subscript> is added to the node set associated with K. Otherwise, the entry [K<subscript>ij</subscript>, { D<subscript>i</subscript> }] is inserted into the index. </para><para></para></listitem>
<listitem>
<para>The index maintains a &quot;special&quot; entry for all domain nodes whose key sequence is empty. All such nodes are inserted in the node set associated with this entry. </para><para></para></listitem>
</itemizedlist>
</para><para></para></listitem>
<listitem>
<para>A entry is added to the indexes table. The entry maps the expanded QName of the index to the index entry container.  </para></listitem>
</itemizedlist>
</para></sect2>
<sect2 id="xqddf_1index_deletion">
<title>Index Deletion</title>
<para>To destroy an index, Zorba provides the delete updating function. The function itself and its associated update primitive are described below.</para><para><anchor id="_1delete_index"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>iddl:</highlight><highlight class="keyword">delete</highlight><highlight class="normal">($indexName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs<sp/>:QName)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>upd:deleteIndex($indexName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName)</highlight></codeline>
</programlisting></para><para>The delete function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>If the given expanded QName does not identify an index among the statically known indexes in the static context of the invoking module, an error is raised [<ulink url="#ERRZDDY0021">zerr:ZDDY0021</ulink>].  </para></listitem>
<listitem>
<para>If the given expanded QName does not identify an index among the available indexes in the dynamic context of the invoking module, an error is raised [<ulink url="#ERRZDDY0023">zerr:ZDDY0023</ulink>].  </para></listitem>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of a single update primitive: upd:deleteIndex($indexName).  </para></listitem>
</itemizedlist>
</para><para>The update primitive is applied as follows:</para><para><itemizedlist>
<listitem>
<para>The index entry container for the index is found via the indexes table. </para></listitem>
<listitem>
<para>All entries in the container are destroyed. </para></listitem>
<listitem>
<para>The container itself is destroyed. </para></listitem>
<listitem>
<para>The entry mapping the index name to the index entry container is removed from the indexes table. </para></listitem>
</itemizedlist>
</para></sect2>
<sect2 id="xqddf_1index_probing">
<title>Index Probing</title>
<para><linebreak/>
 Probing an index means retrieving the domain nodes associated with a particular search condition. Probing can be done via the xqddf functions idml:probe-index-point-value, idml:probe-index-point-general, idml:probe-index-range-value, or idml:probe-index-range-general. For each of these functions, the first argument is a QName identifying an index. The rest of the arguments specify the search condition. For all functions, the index must exist in both the statically known indexes and the available indexes of the invoking module; otherwise error <ulink url="#ERRZDDY0021">zerr:ZDDY0021</ulink> or <ulink url="#ERRZDDY0023">zerr:ZDDY0023</ulink> is raised, respectively. All of the functions return their result sorted in document order and without duplicate nodes.</para><para><bold>idml:probe-index-point-value</bold></para><para><anchor id="_1probe_index_point_value"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>idml:probe-index-point-value($indexUri<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$key1<sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:anyAtomicType?,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$keyM<sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:anyAtomicType?)<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*</highlight></codeline>
</programlisting></para><para>The probe-index-point-value function retrieves the domain nodes associated by value equality with a given <bold>search tuple</bold>. The search tuple consists of a number of <bold>search keys</bold>, where each search key is either an atomic item or the empty sequence. The result of this function is either an error or the set of domain nodes for which the following xquery expression returns true:</para><para><programlisting><codeline><highlight class="normal">$key1<sp/>eq<sp/>$node/keyExpr1<sp/>and<sp/>...<sp/>and<sp/>$keyM<sp/>eq<sp/>$node/keyExprN</highlight></codeline>
</programlisting></para><para>where keyExpr-i is the expression specified in the i<superscript>th</superscript> keyspec of the index and N is the number of keyspecs for the index. Notice that this definition implies that if any of search keys is the empty sequence, the result of the probe is also the empty sequence.</para><para>In addition to the errors that may be raised by the above expression, the probe-index-point-value function may raise the following errors:</para><para><itemizedlist>
<listitem>
<para><ulink url="#ERRZDDY0021">zerr:ZDDY0021</ulink> or <ulink url="#ERRZDDY0023">zerr:ZDDY0023</ulink>, if the index is not among the statically known indexes or the available indexes.  </para></listitem>
<listitem>
<para>[<ulink url="#ERRZDDY0025">zerr:ZDDY0025</ulink>], if the number of search keys is not equal to the number of keyspecs found in the index declaration.  </para></listitem>
<listitem>
<para>[err:XPTY0004], if a non-empty search key is given, whose type does not match the sequence type specified in the corresponding keyspec.  </para></listitem>
</itemizedlist>
</para><para><bold>idml:probe-index-point-general</bold></para><para><anchor id="_1probe_index_point_general"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>idml:probe-index-point-general($indexUri<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$keys<sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:anyAtomicType*)<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*</highlight></codeline>
</programlisting></para><para><linebreak/>
 The probe-index-point-general function retrieves the domain nodes associated by general equality with a given <bold>search sequence</bold>. The search sequence consists of an arbitrary number of <bold>search keys</bold>, where each search key is an atomic item. The function is supported by general indexes only [<ulink url="#ERRZDDY0029">zerr:ZDDY0029</ulink>]. Its result is either an error or the set of domain nodes for which the following xquery expression returns true:</para><para><programlisting><codeline><highlight class="normal">$keys<sp/>=<sp/>$node/keyExpr</highlight></codeline>
</programlisting></para><para>where keyExpr is the expression specified in the keyspec of the index (remember that for general indexes, there can be only one keyspec).</para><para>In addition to the errors that may be raised by the above expression, the probe-index-point-value function may raise the following errors:</para><para><itemizedlist>
<listitem>
<para><ulink url="#ERRZDDY0021">zerr:ZDDY0021</ulink> or <ulink url="#ERRZDDY0023">zerr:ZDDY0023</ulink>, if the index is not among the statically known indexes or the available indexes.  </para></listitem>
<listitem>
<para>[<ulink url="#ERRZDDY0029">zerr:ZDDY0029</ulink>], if the index is not general.  </para></listitem>
<listitem>
<para>[err:XPTY0004], if the search sequence contains a search key, whose type does not match the sequence type specified in the keyspec of the index.  </para></listitem>
</itemizedlist>
</para><para><bold>idml:probe-index-range-value</bold></para><para><anchor id="_1probe_index_range_value"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>probe-index-range-value($indexUri<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$lowerBound1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:anyAtomicType?,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$upperBound1<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:anyAtomicType?,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$haveLowerBound1<sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">boolean</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$haveUpperBound1<sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">boolean</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$lowerBoundIncluded1<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">boolean</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$upperBoundIncluded1<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">boolean</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>....,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$lowerBoundM<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:anyAtomicType?,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$upperBoundM<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:anyAtomicType?,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$haveLowerBoundM<sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">boolean</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$haveUpperBoundM<sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">boolean</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$lowerBoundIncludedM<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">boolean</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$upperBoundIncludedM<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">boolean</highlight><highlight class="normal">)<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*</highlight></codeline>
</programlisting></para><para>The probe-index-range-value function retrieves the domain nodes associated by value order-comparison (operators le, lt, ge, gt) with a given <bold>search box</bold>. The search box is specified as a number M of <bold>rangespecs </bold>, where each rangespec consists of six values. The number M must be greater than 0 and less than or equal to the number N of keyspecs found in the index declaration [<ulink url="#ERRZDDY0025">zerr:ZDDY0025</ulink>]. If M is less than N, then the &quot;missing&quot; rangespecs are assumed to have the following value: [(), (), false, false, false, false]. As a result, from now on, we can assume that M is equal to N (Remember that for general indexes, there can be only one IndexKeySpec, and as a result, for general indexes, M = N = 1).</para><para>The i<superscript>th</superscript> rangespec corresponds to the i<superscript>th</superscript> keyspec, and specifies a search condition on the key values that are produced by evaluating that keyspec for every domain node. Specifically, we define the i<superscript>th</superscript> <bold>rangespec result</bold> as the set of domain nodes for which the following xquery expression returns true:</para><para><programlisting><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>($haveLowerBound-i<sp/>and<sp/>$haveUpperBound-i)<sp/>then</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>$lowerBound-i<sp/>lop<sp/>$node/keyExpr-i<sp/>and<sp/>$node/keyExpr-i<sp/>uop<sp/>$upperBound-i</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>($haveLowerBound-i)<sp/>then</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>$lowerBound-i<sp/>lop<sp/>$node/keyExpr-i</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>($haveUpperBound-i)<sp/>then</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>$node/keyExpr-i<sp/>uop<sp/>$upperBound-i</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fn:</highlight><highlight class="keyword">true</highlight><highlight class="normal">()</highlight></codeline>
</programlisting></para><para>where keyExpr-i is the expression specified by the i<superscript>th</superscript> keyspec of the index, lop is either the le or the lt operator depending on whether $lowerBoundsIncluded-i is true or false, and uop is either the le or the lt operator depending on whether $upperBoundsIncluded-i is true or false.</para><para>The result of the probe-index-range-value function is either an error, or the intersection of all the rangespec results. In addition to the errors that may be raised by a rangespec expression, the function may raise the following errors:</para><para><itemizedlist>
<listitem>
<para><ulink url="#ERRZDDY0021">zerr:ZDDY0021</ulink> or <ulink url="#ERRZDDY0023">zerr:ZDDY0023</ulink>, if the index is not among the statically known indexes or the available indexes.  </para></listitem>
<listitem>
<para>[<ulink url="#ERRZDDY0026">zerr:ZDDY0026</ulink>], if the index is not a range index.  </para></listitem>
<listitem>
<para>[<ulink url="#ERRZDDY0025">zerr:ZDDY0025</ulink>], if the number of rangespecs passed as arguments is zero or greater than the number of keys declared for the index.  </para></listitem>
<listitem>
<para>[err:XPTY0004], if $haveLowerBound-i is true and $lowerBound-i is an atomic item whose type does not match the sequence type specified by the i<superscript>th</superscript> keyspec, or $haveUpperBound-i is true and $upperBound-i is an atomic item whose type does not match the sequence type specified by the i<superscript>th</superscript> keyspec.  </para></listitem>
<listitem>
<para>[<ulink url="#ERRZDDY0034">zerr:ZDDY0034</ulink>], if (a) the index is general (in which case there is only one rangespac), (b) the index is untyped, (c) there is both a lower and an upper bound, and (d) if T1 and T2 are the types of the lower and upper bound, neither T1 is a subtype of T2 nor T2 is a subtype of T1.  </para></listitem>
</itemizedlist>
</para><para><bold>idml:probe-index-range-general</bold></para><para><anchor id="_1probe_index_range_general"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>probe-index-range-general($indexUri<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$lowerBoundKeys<sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:anyAtomicType*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$upperBoundKeys<sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:anyAtomicType*,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$haveLowerBound<sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">boolean</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$haveUpperBound<sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">boolean</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$lowerBoundIncluded<sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">boolean</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>$upperBoundIncluded<sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:</highlight><highlight class="keywordtype">boolean</highlight><highlight class="normal">)<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>node()*</highlight></codeline>
</programlisting></para><para>The probe-index-range-general function retrieves the domain nodes associated by general order-comparison (operators &lt;=, &lt;, &gt;=, &gt;) with one or two <bold>search sequences</bold>. Each search sequence consists of an arbitrary number of <bold>search keys</bold>, where each search key is an atomic item. This method is supported by general range indexes only [<ulink url="#ERRZDDY0030">zerr:ZDDY0030</ulink>]. Its result is either an error or the set of domain nodes for which the following xquery expression returns true:</para><para><programlisting><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>($haveLowerBound<sp/>and<sp/>$haveUpperBound)<sp/>then</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>$lowerBoundKeys<sp/>lop<sp/>$node/keyExpr<sp/>and<sp/>$node/keyExpr<sp/>uop<sp/>$upperBoundKeys</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>($haveLowerBound)<sp/>then</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>$lowerBoundKeys<sp/>lop<sp/>$node/keyExpr</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>($haveUpperBound)<sp/>then</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>$node/keyExpr<sp/>uop<sp/>$upperBoundKeys</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fn:</highlight><highlight class="keyword">true</highlight><highlight class="normal">()</highlight></codeline>
</programlisting></para><para>where keyExpr is the expression specified in the keyspec of the index, lop is either the &lt;= or the &lt; operator depending on whether $lowerBoundsIncluded is true or false, and uop is either the &lt;= or the &lt; operator depending on whether $upperBoundsIncluded is true or false.</para><para>In addition to the errors that may be raised by the above expression, the probe-index-point-value function may raise the following errors:</para><para><itemizedlist>
<listitem>
<para><ulink url="#ERRZDDY0021">zerr:ZDDY0021</ulink> or <ulink url="#ERRZDDY0023">zerr:ZDDY0023</ulink>, if the index is not among the statically known indexes or the available indexes.  </para></listitem>
<listitem>
<para>[<ulink url="#ERRZDDY0030">zerr:ZDDY0030</ulink>], if the index is not a general range index.  </para></listitem>
<listitem>
<para>[err:XPTY0004], if $haveLowerBound is true and $lowerBoundKeys constains an atomic item whose type does not match the sequence type specified by the index keyspec, or $haveUpperBound is true and $upperBoundKeys contains an atomic item whose type does not match the sequence type specified by the index keyspec.  </para></listitem>
</itemizedlist>
</para></sect2>
<sect2 id="xqddf_1index_keys">
<title>Retrieving Index Keys</title>
<para>In addition to probing an index, the <computeroutput>idml</computeroutput> module also provides a function that allows listing all the keys contained in an index.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>idml:keys($indexName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName)<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>item()*</highlight></codeline>
</programlisting></para><para>This function returns a sequence of element nodes. Each node in the sequence represents one key contained in the index and has the following structure:</para><para><programlisting><codeline><highlight class="normal"><sp/>&lt;key<sp/>xmlns=</highlight><highlight class="stringliteral">&quot;http://zorba.io/modules/store/static/indexes/dml&quot;</highlight><highlight class="normal">&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>&lt;attribute<sp/>value=</highlight><highlight class="stringliteral">&quot;key_1&quot;</highlight><highlight class="normal">/&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>&lt;attribute<sp/>value=</highlight><highlight class="stringliteral">&quot;key_n&quot;</highlight><highlight class="normal">/&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/>&lt;/key&gt;</highlight></codeline>
</programlisting></para><para>The order of the attribute elements reflects the order of the key specifications in the declaration of the index. Also, the types of the values of the attributes are the types of the keys as they are declared. If a value attribute is not present, this means that the value of the corresponding key in the index is the empty sequence.</para></sect2>
<sect2 id="xqddf_1index_maintenance">
<title>Index Maintenance</title>
<para><linebreak/>
 An index is said to be up-to-date if its content reflects the index definition on the current data snapshot, i.e., the contents are the same as those that would be produced if the <ulink url="#create_index">iddl:create</ulink> function was invoked on the same index and with the same underlying data. An index is said to be stale if it is not up-to-date. Indexes become stale when documents in collections are updated or when documents are inserted/removed in/from collections. <bold>Index Maintenance</bold> is the operation by which stale index contents are updated so that the index becomes up-to-date. Zorba offers two maintenance modes: manual and automatic.</para><para><linebreak/>
 <linebreak/>
 If an index is declared as &quot;automatically maintained&quot; (i.e. &apos;an:automatic&apos;), Zorba guarantees that every time a PUL is applied, the index is made up-to-date before the upd:apply-updates function returns. Ideally, all indexes should be automatically maintained, but in general, index maintenance can be a very expensive operation performance-wise. As a result, Zorba will reject a declaration for an automatic index if it determines that it cannot maintain the index in an &quot;efficient&quot; way. The definition of efficiency with respect to index maintenance is implementation dependent, but in general, it means that the index can be maintained in some incremental way that is faster than simply re-creating the whole index from scratch. However, even incremental maintenance can have a high cost, which may make the manual mode described below the preferred choice.</para><para><linebreak/>
 <linebreak/>
 If an index is declared as &quot;manually maintained&quot; (i.e. &apos;an:manual&apos;), it is the responsibility of the programmers to keep the index up-to-date. This can be done using the idml:refresh-index updating function described below. Since Zorba does not take any maintenance action during PUL applications, manually maintained indexes may become stale in between calls to the idml:refresh-index function. Obviously, the manual mode must be used if an index cannot be maintained automatically. However, even for automatically maintainable indexes, the manual mode may be preferable if users can tolerate a stale index in return for better performance during updates.</para><para><anchor id="_1refresh_index"/> <programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>updating<sp/></highlight><highlight class="keyword">function</highlight><highlight class="normal"><sp/>idml:refresh-index($indexName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>upd:refreshIndex($indexName<sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a1dea282b8d50cca16d5e6f8faef7d9d0" kindref="member" tooltip="Assamese.">as</ref><sp/>xs:QName)</highlight></codeline>
</programlisting></para><para>The refresh-index function is evaluated as follows:</para><para><itemizedlist>
<listitem>
<para>If the given expanded QName does not identify an index among the statically known indexes in the static context of the invoking module, an error is raised [<ulink url="#ERRZDDY0021">zerr:ZDDY0021</ulink>]. </para></listitem>
<listitem>
<para>If the given expanded QName does not identify an index among the available indexes in the dynamic context of the invoking module, an error is raised [<ulink url="#ERRZDDY0023">zerr:ZDDY0023</ulink>]. </para></listitem>
<listitem>
<para>The result of the function is an empty XDM instance and a pending update list that consists of a single update primitive: upd:refreshIndex($indexName). </para></listitem>
</itemizedlist>
</para><para>The update primitive is applied as follows:</para><para><itemizedlist>
<listitem>
<para>The index entry container for the index is found via the indexes table. </para></listitem>
<listitem>
<para>The container is made up-to-date in some implementation dependent way. In Zorba this is done by discarding the current contents and rebuilding the index from scratch (the same way as the <ulink url="#create_index">iddl:create</ulink> function populates an empty index container). </para></listitem>
</itemizedlist>
</para></sect2>
</sect1>
<sect1 id="xqddf_1integrity_constraints">
<title>Integrity Constraints in Zorba</title>
<para><programlisting><codeline><highlight class="normal"><sp/><sp/>ICDecl<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>::=<sp/><sp/></highlight><highlight class="stringliteral">&apos;integrity&apos;</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&apos;constraint&apos;</highlight><highlight class="normal"><sp/>EQName<sp/>(ICCollection<sp/>|<sp/>ICForeignKey)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ICCollection<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>::=<sp/><sp/>&apos;on&apos;<sp/>&apos;collection&apos;<sp/>EQName</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(<sp/>ICCollSequence<sp/>|<sp/>ICCollSequenceUnique<sp/>|<sp/>ICCollNode<sp/>)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ICCollSequence<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>::=<sp/><sp/>&apos;\$&apos;<sp/>EQName<sp/>&apos;check&apos;<sp/>ExprSingle</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ICCollSequenceUnique<sp/><sp/>::=<sp/><sp/>&apos;node&apos;<sp/>&apos;\$&apos;<sp/>EQName<sp/>&apos;check&apos;<sp/>&apos;unique&apos;<sp/>&apos;key&apos;<sp/>PathExpr</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ICCollNode<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>::=<sp/><sp/>&apos;foreach&apos;<sp/>&apos;node&apos;<sp/>&apos;\$&apos;<sp/>EQName<sp/>&apos;check&apos;<sp/>ExprSingle</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ICForeignKey<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>::=<sp/><sp/>&apos;foreign&apos;<sp/>&apos;key&apos;<sp/>ICForeignKeySource<sp/>ICForeignKeyTarget</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ICForeignKeySource<sp/><sp/><sp/><sp/>::=<sp/><sp/>&apos;from&apos;<sp/>ICForeignKeyValues</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ICForeignKeyTarget<sp/><sp/><sp/><sp/>::=<sp/><sp/>&apos;<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a0f4527a84781e2e19c9796b2b7fcacba" kindref="member" tooltip="Tonga.">to</ref>&apos;<sp/>ICForeignKeyValues</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ICForeignKeyValues<sp/><sp/><sp/><sp/>::=<sp/><sp/>&apos;collection&apos;<sp/>EQName<sp/>&apos;node&apos;<sp/>&apos;\$&apos;<sp/>QName<sp/>&apos;key&apos;<sp/>PathExpr</highlight></codeline>
</programlisting></para><para>Analogously to collections and indexes, Zorba defines an additional extension to XQuery library modules which allows the declaration of (static) integrity constraints (ICs). Static ICs can be used to ensure that, in every moment in time, all data which is stored in collections is accurate and consistent according to the semantics of an application. Note that Zorba doesn&apos;t define any dynamic integrity constraints which check the validity of a particular update. As in the relational world, Zorba defines several types of ICs: <ulink url="#ic_entity_integrity">Entity</ulink>, <ulink url="#ic_domain_integrity">Domain</ulink> and <ulink url="#ic_referential_integrity">Referential</ulink> ICs.</para><para><linebreak/>
 <linebreak/>
 <ulink url="#ic_entity_integrity">Entity</ulink> ICs check for the accuracy and consistency of all nodes in a collection. For instance, a special case of the Entity IC is the IC that checks for unique keys among all nodes in a collection. The <ulink url="#ic_domain_integrity">Domain</ulink> IC validates that each node in a collection satisfies a given expression. The <ulink url="#ic_referential_integrity">Referential</ulink> IC is used to ensure a foreign key relationship between the nodes in two collections.</para><para><linebreak/>
 <linebreak/>
 In this section, we describe how such ICs are declared in a library module and how a particular IC can be (de-)activated. All ICs are described using examples for the news application. Specifically, we declare ICs for the data stored in the news-data:employees and the news-data:articles collections.</para><sect2 id="xqddf_1ic_declaration">
<title>Declaration</title>
<para><linebreak/>
 As for collections and indexes, ICs must be declared before the user can activate them. An IC declaration specifies (1) the name of the IC for being used by function call to (de-)activate it (see next section), (2) the name of the collection(s) whose data should be validated, and (3) the expression(s) that guarantee the accuracy and consistency of the data. Analogously to indexes, ICs are declared inside the prolog of the library module that declares the collection(s) which is/are referenced by the IC.</para><para><anchor id="_1ic_entity_integrity"/> </para><sect3 id="xqddf_1ic_entity_integrity">
<title>Entity Integrity</title>
<para>An Entity IC is used to state the uniqueness of a key among all nodes of a collection. For example, the IC (named news-data:UniqueId) in the example below states that the value of the id attribute of each employee is unique among all other nodes in the news-data:employees collection.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>integrity<sp/>constraint<sp/>news-data:UniqueId</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>on<sp/>collection<sp/>news-data:employees</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>node<sp/>$id<sp/>check<sp/>unique<sp/>key<sp/>$id/@<ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a36d6b16ade33b5f43df326111285b4e5" kindref="member" tooltip="Indonesian (formerly in)">id</ref>;</highlight></codeline>
</programlisting></para><para>The name of the collection is specified after the &quot;on collection&quot; keyword. The path expression following the &quot;check unique key&quot; keyword returns the value to be checked for uniqueness. The result of this path expression must not be empty and is wrapped to return an atomic value. The variable $id is successively bound to each node of the news-data:employees collection and available in the check expression.</para><para><anchor id="_1ic_domain_integrity"/> </para></sect3>
<sect3 id="xqddf_1ic_domain_integrity">
<title>Domain Integrity</title>
<para>The Domain IC allows the user to specify constraints that a particular node in a collection must satisfy. Domain ICs can be use in addition to XML Schema types or if no XML schema is available.</para><para>With the following example, we want to make sure that the name of each author of an article is not the zero length string. This can be particularly useful since there is no XML schema for articles.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>integrity<sp/>constraint<sp/>news-data:AuthorNames</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>on<sp/>collection<sp/>news-data:article</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">foreach</highlight><highlight class="normal"><sp/>node<sp/>$article<sp/>check<sp/>fn:</highlight><highlight class="keywordtype">string</highlight><highlight class="normal">-length($article/author/name)<sp/>!=<sp/>0;</highlight></codeline>
</programlisting></para><para>The name of the IC is news-data:AuthorNames and it is defined on nodes belonging to the news-data:articles collection. The &quot;foreach node&quot; expression specifies a variable (using a QName) which is bound to each node in the collection. For each such node, the check expression is executed. For each node, the boolean effective value of the result of this expression must be equal to true.</para><para><anchor id="_1ic_referential_integrity"/> </para></sect3>
<sect3 id="xqddf_1ic_referential_integrity">
<title>Referential Integrity</title>
<para><linebreak/>
 The Referential IC requires every value of a node in a collection to exist as a value of another node in another collection. For example, in the database of the news organization, we want to make sure that each article is maintained by an (existing) employee. This can be done by declaring a so called foreign key IC. In the following example, this IC is given the name news-data:ArticleEmployees.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>integrity<sp/>constraint<sp/>news-data:ArticleEmployees</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>foreign<sp/>key</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>from<sp/>collection<sp/>news-data:articles<sp/>node<sp/>$x<sp/>key<sp/>$x/empid</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacezorba_1_1locale_1_1iso639__1_1aafd6e55905dc8efe50a3f9fd38616781a0f4527a84781e2e19c9796b2b7fcacba" kindref="member" tooltip="Tonga.">to</ref><sp/><sp/><sp/>collection<sp/>news-data:employees<sp/>node<sp/>$y<sp/>key<sp/>fn:data($y/@</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para><para>The QName following the &quot;from collection&quot; and &quot;to collection&quot; keywords specify the source and destination collections, respectively. Each result of the key expressions are wrapped to return an atomic value. For each atomic value in the source collection, an atomic value in the sequence returned by the key expression on the destination collection must exist. The IC is violated if this is not the case for any node in the source collection. This semantics is equivalent to the following XQuery expression.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>every<sp/>$x<sp/>in<sp/>idml:collection(xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:articles&quot;</highlight><highlight class="normal">))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>satisfies</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>some<sp/>$y<sp/>in<sp/>idml:collection(xs:QName(&quot;news-data:employees&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>satisfies<sp/>$y/</highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>eq<sp/>$x</highlight><highlight class="comment">//sale/empid</highlight></codeline>
</programlisting></para></sect3>
</sect2>
<sect2 id="xqddf_1ic_life_cycle">
<title>Lifecycle Management</title>
<para><linebreak/>
 ICs can be checked manually (if requested by the user) or automatically on updates apply time, after validation and indexes are computed. In order to be checked automatically, an IC needs to be active. ICs can be (de-)activated using the two updating functions icddl:activate and icddl:deactivate, respectively. Each function takes the name of the IC to (de-)activate as parameter. The flag indicating whether an IC is active or not is stored in the dynamic context.</para><para><linebreak/>
 <linebreak/>
 Deactivating an IC might be useful if the corresponding check is expensive and, hence, inconsistency of the data might be acceptable and only checked (and fixed manually) from time to time. To check an IC manually, the Zorba defines an updating function called check-integrity-constraint which triggers the IC, identified by a QName passed as parameter, to be checked.</para><para><linebreak/>
 <linebreak/>
 Similar to collections and indexes, the module declaring the integrity constraints (i.e. with namespace http://www.news.org/data) can also declare variables whose values are the QNames of the ICs. This allows their names to be easily referenced by subsequent expressions. For example, such a variable can be passed as a parameter to the activate in the importing admin-script module (see above). For the ICs from the section above, those variables are declared as follows:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>declare<sp/>variable<sp/>$news-data:UniqueId<sp/>:=<sp/>xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:UniqueId&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>variable<sp/>$news-data:AuthorName<sp/>:=<sp/>xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:AuthorNames&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>declare<sp/>variable<sp/>$news-data:ArticleEmployees<sp/>:=<sp/>xs:QName(</highlight><highlight class="stringliteral">&quot;news-data:ArticleEmployees&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="xqddf_1extensions_xquf_updates_routines">
<title>Extensions to the XQUF updates</title>
<para>routines</para><sect2 id="xqddf_1upd_merge_updates">
<title>upd:mergeUpdates</title>
<para><linebreak/>
 The XQuery Update Facility specification lists a number of errors that may be raised by the upd:mergeUpdates routine. Zorba adds the following error conditions to this list:</para><para><itemizedlist>
<listitem>
<para>An error is raised [<ulink url="#ERRZDDY0016">zerr:ZDDY0016</ulink>] if two or more upd:createCollection primitives having the same QName as argument appear in the merged list. </para></listitem>
<listitem>
<para>An error is raised [<ulink url="#ERRZDDY0027">zerr:ZDDY0027</ulink>] if two or more upd:createIndex primitives having the same QName as argument appear in the merged list. </para></listitem>
</itemizedlist>
</para></sect2>
<sect2 id="xqddf_1upr_apply_updates">
<title>upd:applyUpdates</title>
</sect2>
</sect1>
<sect1 id="xqddf_1error_summary">
<title>Appendix Error Summary</title>
<para>The prefix &quot;zerr&quot; is bound to the error namespace of Zorba, i.e. http://zorba.io/errors . The prefix &quot;err&quot; is bound to the general XQuery error namespace, i.e. <ulink url="http://www.w3.org/2005/xqt-errors">http://www.w3.org/2005/xqt-errors</ulink> .</para><para>XQuery Data Definition Facility - Static Errors:</para><para><bold> <linebreak/>
 <anchor id="_1ERRZDST0001"/>zerr:ZDST0001, A collection with name is already declared in the same module.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0002"/>zerr:ZDST0002, A collection with name that is imported from module is already declared in the importing module.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0003"/>zerr:ZDST0003, A collection declaration cannot appear in a main module.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0004"/>zerr:ZDST0004, The declaration for collection specifies multiple values for the same property.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0005"/>zerr:ZDST0005, The declaration for collection specifies conflicting property values.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0006"/>zerr:ZDST0006, The declaration for collection contains an invalid property value.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0021"/>zerr:ZDST0021, An index with name is already declared in the same module.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0022"/>zerr:ZDST0022, An index with name that is imported from module /s is already declared in the importing module.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0023"/>zerr:ZDST0023, An index declaration cannot appear in a main module.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0024"/>zerr:ZDST0024, The declaration for index specifies multiple values for the same property.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0025"/>zerr:ZDST0025, The index cannot be declared as unique.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0026"/>zerr:ZDST0026, The declaration for index contains an invalid property value.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0027"/>zerr:ZDST0027, The index has an invalid key type declaration.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0028"/>zerr:ZDST0028, The index has a non deterministic definition.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0029"/>zerr:ZDST0029, The index references a data source that is not a collection.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0030"/>zerr:ZDST0030, The index references a collection with a non-const QName.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0031"/>zerr:ZDST0031, The index has free variables in its definition.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0032"/>zerr:ZDST0032, The domain expression of index references the context item.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0033"/>zerr:ZDST0033, The declaration of index contains a non-simple expression.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0034"/>zerr:ZDST0034, Index cannot be automatically maintained.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0036"/>zerr:ZDST0036, Index qname does not have the same namespace URI as the target namespace of the declaring module.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0041"/>zerr:ZDST0041, An integrity constraint with URI is declared already.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0042"/>zerr:ZDST0042, An integrity constraint key has multiple values.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0043"/>zerr:ZDST0043, An integrity constraint key has a non-atomic value.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0045"/>zerr:ZDST0045, The integrity constraint cannot be declared in a main module.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0046"/>zerr:ZDST0046, The integrity constraint with URI has free variables in its definition.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0047"/>zerr:ZDST0047, The integrity constraint with URI references a data source that is not a collection among the statically known collections.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDST0048"/>zerr:ZDST0048,The integrity constraint with URI has a non deterministic definition. </bold></para><para>XQuery Data Definition Facility - Type Errors:</para><para><bold> <linebreak/>
 <anchor id="_1ERRXDTY0001"/>zerr:XDTY0001, Collection cannot contain a node of certain type.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRXDTY0010"/>zerr:XDTY0010, The domain expression of index produces an item that is not a node.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRXDTY0011"/>zerr:XDTY0011, The result of some key expression of index does not match its declared type. </bold></para><para>XQuery Data Definition Facility - Dynamic Errors:</para><para><bold> <linebreak/>
 <anchor id="_1ERRZDDY0001"/>zerr:ZDDY0001, Collection is not declared in the static context.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0002"/>zerr:ZDDY0002, Collection exists already.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0003"/>zerr:ZDDY0003, Collection does not exist.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0004"/>zerr:ZDDY0004, Cannot update const collection.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0005"/>zerr:ZDDY0005, Illegal insert in append-only collection.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0006"/>zerr:ZDDY0006, Illegal insert in queue collection.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0007"/>zerr:ZDDY0007, Illegal delete from append-only collection.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0008"/>zerr:ZDDY0008, Illegal delete from queue collection.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0009"/>zerr:ZDDY0009, Not all the nodes to delete are at the beginning of queue collection.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0010"/>zerr:ZDDY0010, Illegal update of node in collection, whose nodes are read-only.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0011"/>zerr:ZDDY0011, Node is not contained in collection.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0012"/>zerr:ZDDY0012, Illegal insert in unordered collection.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0013"/>zerr:ZDDY0013, Cannot delete collection because there are indexes that reference it.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0014"/>zerr:ZDDY0014, Cannot delete collection because there are integrity constraints that reference it.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0015"/>zerr:ZDDY0015, Cannot delete collection because there are references on its nodes.</bold></para><para><bold><anchor id="_1ERRZDDY0016"/>zerr:ZDDY0016, Cannot invoke the create function multiple times with the same QName in the same snapshot.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0020"/>zerr:ZDDY0020, The domain expression of index produces nodes that are not in collection.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0021"/>zerr:ZDDY0021, Index is not declared in the static context.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0022"/>zerr:ZDDY0022, Index exists already.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0023"/>zerr:ZDDY0023, Index does not exist.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0024"/>zerr:ZDDY0024, The uniqueness property of index is violated.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0025"/>zerr:ZDDY0025, Invalid number of arguments in probe of index.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0026"/>zerr:ZDDY0026, Index does not support range probes.</bold></para><para><bold><anchor id="_1ERRZDDY0027"/>zerr:ZDDY0027, Cannot invoke the create function multiple times with the same QName in the same snapshot.</bold></para><para><bold><anchor id="_1ERRZDDY0030"/>zerr:ZDDY0030, Index does not support general range probes.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0031"/>zerr:ZDDY0031, An integrity constraint with URI is not declared.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0032"/>zerr:ZDDY0032, An integrity constraint with URI is not declared.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0033"/>zerr:ZDDY0033, Conditions for integrity constraint were not met on collection.</bold></para><para><bold><linebreak/>
 <anchor id="_1ERRZDDY0034"/>zerr:ZDDY0034, Index range-value probe has search keys with incompatible types </bold> </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
