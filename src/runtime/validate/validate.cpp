/*
* Copyright 2006-2008 The FLWOR Foundation.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
#include "system/globalenv.h"
#include "runtime/validate/validate.h"
#include "types/casting.h"
#include "types/delegating_typemanager.h"
#include "types/typeops.h"
#include "runtime/api/runtimecb.h"
#include "runtime/accessors//AccessorsImpl.h"
#include "store/api/temp_seq.h"
#include "runtime/api/plan_iterator_wrapper.h"
#include "store/api/item_factory.h"
#include "store/api/store.h"
#include "context/dynamic_context.h"
#include "context/static_context.h"
#include "context/collation_cache.h"
#include "zorbatypes/duration.h"
#include "zorbatypes/datetime.h"
#include "zorbaerrors/error_messages.h"
#include "zorbaerrors/errors.h"


namespace zorba
{

    /*______________________________________________________________________
    |
    | 3.13 
    | validate [ | lax | strict] {  } 
    |
    | A validate expression returns a new node with its own identity and 
    | with no parent. The new node and its descendants are given type 
    | annotations that are generated by applying a validation process to 
    | the operand node. In some cases, default values may also be generated 
    | by the validation process.
    |_______________________________________________________________________*/
    ValidateIterator::ValidateIterator ( const QueryLoc& loc, PlanIter_t& aIter, bool isLax )
        :
    UnaryBaseIterator<ValidateIterator, PlanIteratorState> ( loc, aIter ) , _isLax(isLax)
    {}

    ValidateIterator::~ValidateIterator() 
    {}

    bool ValidateIterator::effectiveValidationValue ( store::Item_t& result, const QueryLoc& loc, PlanState& planState, 
        const PlanIterator* iter)
    {
        store::Item_t item;
        xqtref_t type;

        bool valid = consumeNext(item, iter, planState);

        if ( !valid )
        {
             ZORBA_ERROR_LOC_DESC( XQDY0061, loc, "Wrong arguments in validate expression.");
        }
        else if ( item->isNode() )
        {
            if ( item->getNodeKind() == store::StoreConsts::documentNode )
            {
                // argument is document start the validation
                static_context* staticContext = planState.sctx();
                //dynamic_context* dynamicContext = planState.dctx();
                TypeManager * typeManager = staticContext->get_typemanager();
                DelegatingTypeManager* delegatingTypeManager= static_cast<DelegatingTypeManager*>(typeManager);
                Schema* schema = delegatingTypeManager->getSchema();
                
                //GENV_ITEMFACTORY->create();


            }
            else
            {
                ZORBA_ERROR_LOC_DESC( XQDY0061, loc, "Argument in validate expression not a document.");
            }
        }
        else
        {
            ZORBA_ERROR_LOC_DESC( XQDY0061, loc, "Argument in validate expression not a document node.");
        }

        result = NULL;
        return false;
    }

    bool
        ValidateIterator::nextImpl(store::Item_t& result, PlanState& planState) const
    {
        PlanIteratorState* aState;
        DEFAULT_STACK_INIT(PlanIteratorState, aState, planState);
        STACK_PUSH (
            ValidateIterator::effectiveValidationValue ( result, this->loc, planState, theChild ),
            aState
            );
        STACK_END (aState);
    }
    /* end class ValidateIterator */
}
