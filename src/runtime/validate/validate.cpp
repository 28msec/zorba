
#include "zorbatypes/xqpstring.h"

/*
* Copyright 2006-2008 The FLWOR Foundation.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
#include "validate.h"
#ifndef ZORBA_NO_XMLSCHEMA

#include "system/globalenv.h"

#include "types/casting.h"
#include "types/typeops.h"
#include "types/schema/schema.h"
#include "types/schema/SchemaValidatorFilter.h"
#include "types/schema/EventSchemaValidator.h"
#include "types/schema/StrX.h"

#include "runtime/validate/validate.h"
#include "runtime/api/runtimecb.h"
#include "runtime/accessors/AccessorsImpl.h"
#include "runtime/api/plan_iterator_wrapper.h"
#include "runtime/util/item_iterator.h"

#include "store/api/item.h"
#include "store/api/item_factory.h"
#include "store/api/copymode.h"
#include "store/api/store.h"
#include "store/api/temp_seq.h"

#include "context/dynamic_context.h"
#include "context/static_context.h"
#include "context/collation_cache.h"
#include "context/namespace_context.h"
#include "zorbatypes/duration.h"
#include "zorbatypes/datetime.h"
#include "zorbaerrors/error_messages.h"
#include "zorbaerrors/errors.h"

//using namespace std;

namespace zorba
{
SERIALIZABLE_CLASS_VERSIONS(ValidateIterator)
END_SERIALIZABLE_CLASS_VERSIONS(ValidateIterator)

/*______________________________________________________________________
  
  XQuery 1.1
  
  3.14 Validate Expressions
  [86]        ValidateExpr   ::= "validate" (ValidationMode | ("as" TypeName))? "{" Expr "}"
  [87]        ValidationMode ::= "lax" | "strict"
   
  A validate expression can be used to validate a document node or an element node 
  with respect to the in-scope schema definitions, using the schema validation process 
  defined in [XML Schema]. If the operand of a validate expression does not evaluate 
  to exactly one document or element node, a type error is raised [err:XQTY0030]. 
  In this specification, the node that is the operand of a validate expression is 
  called the operand node.
   
  A validate expression returns a new node with its own identity and with no parent. 
  The new node and its descendants are given type annotations that are generated by 
  applying a validation process to the operand node. In some cases, default values 
  may also be generated by the validation process.
   
  A validate expression may optionally specify a validation mode. The default 
  validation mode is strict.
  
  A validate expression may optionally specify a TypeName. This type name must be 
  found in the in-scope schema definitions; if it is not, a static error is raised 
  [err:XQST0104]. If the type name is unprefixed, it is interpreted as a name in the 
  default namespace for elements and types.
_______________________________________________________________________*/
ValidateIterator::ValidateIterator(
    short sctx,
    const QueryLoc& loc,
    PlanIter_t& aIter,
    TypeManager *typeMgr,
	store::Item_t typeName,
	ParseConstants::validation_mode_t validationMode)
  :
  UnaryBaseIterator<ValidateIterator, PlanIteratorState>( sctx, loc, aIter ),
  _validationMode(validationMode),
  _typemgr (typeMgr),
  _typeName(typeName)
{
}


bool ValidateIterator::nextImpl(store::Item_t& result, PlanState& planState) const 
{
  store::Item_t item;
  store::Item_t tmp;

  PlanIteratorState* aState;
  DEFAULT_STACK_INIT(PlanIteratorState, aState, planState);

  if (consumeNext(item, theChild, planState))
  {
    if (consumeNext(tmp, theChild, planState))
    {
      ZORBA_ERROR_LOC_DESC(XQTY0030, loc, 
                           "Argument in validate expression not a single element node.");
      result = NULL;
      STACK_PUSH(false, aState);
    }
    else
    {
      STACK_PUSH(effectiveValidationValue(result,
                                          item,
                                          _typeName,
                                          _typemgr.getp(),
                                          _validationMode,
                                          getStaticContext(planState),
                                          this->loc),
                 aState);
    }
  }
  else
  {
    ZORBA_ERROR_LOC_DESC( XQTY0030, loc, "Wrong arguments in validate expression.");
    STACK_PUSH(false, aState);
  }

  STACK_END (aState);
}


bool ValidateIterator::effectiveValidationValue (
    store::Item_t& result,
    const store::Item_t& sourceNode,
    const store::Item_t& typeName,
    TypeManager* typeManager,
    ParseConstants::validation_mode_t validationMode,
    static_context* sctx,
    const QueryLoc& loc) 
{
  //cout << "Starting Validation   typeManager: " << typeManager << endl; cout.flush();
        
  xqtref_t type;

  if (!sourceNode->isNode() || 
      !(sourceNode->getNodeKind()==store::StoreConsts::documentNode ||  
        sourceNode->getNodeKind()==store::StoreConsts::elementNode
       ) )
  {
    ZORBA_ERROR_LOC_DESC(XQTY0030, loc,
                         "Argument in validate expression not a document or element node.");
  }

  // verify number of child elements when source is a document node
  if ( sourceNode->getNodeKind()==store::StoreConsts::documentNode )
  {
    //don't allow more than one child element in documents
    store::Iterator_t child_it;
    child_it = sourceNode->getChildren();
    store::Item_t child;
    int nr_child_elements = 0;
    while ( child_it->next(child) )
    {
        if ( child->isNode() &&
           child->getNodeKind() == store::StoreConsts::elementNode)
        { 
            if (nr_child_elements)
            {
                ZORBA_ERROR_LOC_DESC(XQDY0061, loc, 
                               "Document node has more than one element for validation.");
            }
            nr_child_elements++;
        }
    }
  }

  Schema* schema = typeManager->getSchema();

  if ( !schema )
  {
    //cout << "No schema: isNode() " << sourceNode->isNode() << "  nodeKind: " << sourceNode->getNodeKind() << endl;
    // no schema available - items remain the same
    result = sourceNode;
    return true;
  }
  
#ifndef ZORBA_NO_XMLSCHEMA
  xqpStringStore_t baseUri = sctx->final_baseuri().getStore();
                
  EventSchemaValidator schemaValidator = 
  EventSchemaValidator(typeManager,
      schema->getGrammarPool(),
      validationMode == ParseConstants::val_lax,
      loc);  
    
  switch (sourceNode->getNodeKind())
  {
  case store::StoreConsts::documentNode:
  {
    //cout << "Validate document" << "\n"; cout.flush();
    
    if ( validationMode == ParseConstants::val_typename )
    {
      //cout << "Validate type: " << typeName->getLocalName()->c_str()
      //     << " @ " << typeName->getNamespace()->c_str() << "\n"; cout.flush();
      schemaValidator.startType(typeName);                
    }
    else
    {
      schemaValidator.startDoc();

      // ask for the type of the root element to populate the cache with anonymous types
      store::Iterator_t children = sourceNode->getChildren();
      store::Item_t child;
      while ( children->next(child) )
      {
        if ( child->isNode() && child->getNodeKind()==store::StoreConsts::elementNode )
        {
           typeManager->getSchema()->createXQTypeFromElementName(typeManager, child->getNodeName(), false);
           break;
        }
      }
    }
    
    xqpStringStore_t docBaseUri = sourceNode->getBaseURI();
    xqpStringStore_t docUri = sourceNode->getDocumentURI();
    store::Item_t newDoc;
    GENV_ITEMFACTORY->createDocumentNode(newDoc, docBaseUri, docUri);
    
    processChildren(sctx,
                    typeManager,
                    schemaValidator,
                    newDoc,
                    sourceNode->getChildren());
    
    if ( validationMode == ParseConstants::val_typename )
    {
      schemaValidator.endType();                
      //cout << "End Validate type: " << typeName->getLocalName()->c_str()
      //     << " @ " << typeName->getNamespace()->c_str() << "\n";
      //cout.flush();
    }
    else
    {
      schemaValidator.endDoc();
    }
    
    //cout << "End Validate doc" << "\n"; cout.flush();
    
    result = newDoc;
    return true;
  }
  case store::StoreConsts::elementNode: 
  {
    if ( validationMode == ParseConstants::val_typename )
    {
      //cout << "Validate type: " << typeName->getLocalName()->c_str() << " @ "
      //     << typeName->getNamespace()->c_str() << "\n"; cout.flush();

      schemaValidator.startType(typeName);                
    }
    else
    {
      //cout << "Validate element" << "\n"; cout.flush();        
      schemaValidator.startDoc();                    

      // ask for the type of the root element to populate the cache with anonymous types
      typeManager->getSchema()->createXQTypeFromElementName(typeManager, sourceNode->getNodeName(), false);
    }

    store::Item_t newElem = processElement(sctx,
                                           typeManager,
                                           schemaValidator,
                                           NULL,
                                           sourceNode);
    
    if ( validationMode == ParseConstants::val_typename )
    {
      schemaValidator.endType();                
      //cout << "End Validate type: " << typeName->getLocalName()->c_str()
      //     << " @ " << typeName->getNamespace()->c_str() << "\n"; cout.flush();
    }
    else
    {
      schemaValidator.endDoc();
      //cout << "End Validate elem" << "\n"; cout.flush();
    }
    
    result = newElem;
    return true;
  }
  default:
  {
    ZORBA_ERROR_LOC_DESC(XQTY0030, loc, 
                         "Argument in validate expression not a document or element node.");
    result = NULL;
    return false;
  }
  }
#endif // ZORBA_NO_XMLSCHEMA
}


#ifndef ZORBA_NO_XMLSCHEMA

store::Item_t ValidateIterator::processElement( 
    static_context* sctx,
    TypeManager* typeManager, 
    EventSchemaValidator& schemaValidator,
    store::Item *parent,
    const store::Item_t& element)
{
  ZORBA_ASSERT(element->isNode());
  ZORBA_ASSERT(element->getNodeKind() == store::StoreConsts::elementNode);

        
  store::Item_t nodeName = element->getNodeName();
  xqpStringStore_t baseUri = element->getBaseURI();

  schemaValidator.startElem(nodeName);

  // namespace declarations must go first
  processNamespaces( schemaValidator, element);

  // since the type of an element is determined only after the validator receives all 
  // of it's attributes, and an attribute node needs it's parent when created 
  // we need to go through the attributes twice: once for validation and once for creation
  validateAttributes(schemaValidator, element->getAttributes());
  
  // not required since getTypeQName will trigger processElement in validator
  //schemaValidator.endAttrs();

  store::Item_t typeName = schemaValidator.getTypeQName();

  bool isSubstitutionGroup = false;
  if ( schemaValidator.getSubstitutedElemQName() )
      isSubstitutionGroup = true;

  store::Item_t newElem;

  store::NsBindings bindings;
  element->getNamespaceBindings(bindings);

  store::Item_t elemName = element->getNodeName();
  GENV_ITEMFACTORY->createElementNode(newElem, parent, -1, elemName,
                                      typeName, true, false, 
                                      bindings, baseUri, isSubstitutionGroup);
  
  processAttributes(sctx,
                    typeManager,
                    schemaValidator,
                    (store::Item *)newElem, 
                    element->getAttributes());
        
  processChildren(sctx,
                  typeManager,
                  schemaValidator,
                  (store::Item *)newElem, 
                  element->getChildren());

  schemaValidator.endElem(nodeName);

  return newElem;
}


void ValidateIterator::validateAttributes(
    EventSchemaValidator& schemaValidator,
    store::Iterator_t attributes)
{
  store::Item_t attribute;
        
  while ( attributes->next(attribute) )
  {
    ZORBA_ASSERT(attribute->isNode());
    ZORBA_ASSERT(attribute->getNodeKind() == store::StoreConsts::attributeNode);
            
    //cout << " v    - attr: " << attribute->getNodeName()->getLocalName()->c_str() << "\n"; cout.flush();
                        
    store::Item_t attName = attribute->getNodeName();
    schemaValidator.attr(attName, attribute->getStringValue());
  }
}


void ValidateIterator::processAttributes(
    static_context* sctx,
    TypeManager* typeManager, 
    EventSchemaValidator& schemaValidator,
    store::Item *parent,
    store::Iterator_t attributes)
{
  std::list<AttributeValidationInfo*>* attList = schemaValidator.getAttributeList();
  std::list<AttributeValidationInfo*>::iterator curAtt;
         
  for( curAtt = attList->begin(); curAtt != attList->end(); ++curAtt )
  {
    AttributeValidationInfo* att = *curAtt;
    //cout << " v    proccessATT2: " << att->_localName << " T: " << att->_typeName << "\n";
    
    store::Item_t attQName;
    GENV_ITEMFACTORY->createQName(attQName,
                                  att->_uri,
                                  att->_prefix,
                                  att->_localName);
          
    std::string typePrefix;
    if ( std::strcmp(Schema::XSD_NAMESPACE, att->_typeURI->c_str())==0) // hack around typeManager bug for comparing QNames
      typePrefix = "xs";
    else
      typePrefix = "";
    
    store::Item_t typeQName;
    GENV_ITEMFACTORY->createQName(typeQName,
                                  att->_typeURI,
                                  new xqpStringStore(typePrefix),
                                  att->_typeName);

    store::NsBindings bindings;
    parent->getNamespaceBindings(bindings);

    std::vector<store::Item_t> typedValues;
    processTextValue(sctx,
                     typeManager,
                     bindings,
                     typeQName,
                     att->_value,
                     typedValues);
    
    store::Item_t validatedAttNode;
    if ( typedValues.size()==1 ) // hack around serialization bug
      GENV_ITEMFACTORY->createAttributeNode(validatedAttNode,
                                            parent,
                                            -1,
                                            attQName, 
                                            typeQName,
                                            typedValues[0]);
    else            
      GENV_ITEMFACTORY->createAttributeNode(validatedAttNode,
                                            parent,
                                            -1,
                                            attQName, 
                                            typeQName,
                                            typedValues);
  }
}


void ValidateIterator::processChildren(
    static_context* sctx,
    TypeManager* typeManager, 
    EventSchemaValidator& schemaValidator,
    store::Item *parent,
    store::Iterator_t children)
{
  store::Item_t child;

  int childIndex = 0;
        
  while ( children->next(child) )
  {
    if ( child->isNode() )
    {
      //cout << "  > child: " << child->getNodeKind() << " " << (child->getType() != NULL ? child->getType()->getLocalName()->c_str() : "type_NULL" ) << "\n"; cout.flush();
      
      switch ( child->getNodeKind() )
      { 
      case store::StoreConsts::elementNode:                                     
        processElement(sctx, typeManager, schemaValidator, parent, child);
        break;
        
      case store::StoreConsts::attributeNode:
        ZORBA_ASSERT(false);
        break;
        
      case store::StoreConsts::documentNode:
        ZORBA_ASSERT(false);                    
        break;
                    
      case store::StoreConsts::textNode:
      {
        xqpStringStore_t childStringValue = child->getStringValue();
        schemaValidator.text(childStringValue);

        store::Item_t typeQName = schemaValidator.getTypeQName();
                        
        store::Item_t validatedTextNode;
                        
        TypeIdentifier_t typeIdentifier = TypeIdentifier::createNamedType(typeQName->getNamespace(), typeQName->getLocalName() );
        //xqType is NULL, create_type can't find it
        xqtref_t xqType = typeManager->create_type(*typeIdentifier);

#if 0        
        if ( typeQName.getp() && xqType.getp() )
        {
          cout << "     - text: " << childStringValue << "  T: " << typeQName->getLocalName()->c_str() << "\n"; cout.flush();
          cout << "        xqT: " << xqType->toString() << "  content_kind: " << xqType->content_kind() << " tKind:" << xqType->type_kind() << " \n"; cout.flush();
        }
        else
          cout << "     - text2: " << childStringValue << "  tQN: " << typeQName.getp() << " xqT:" << xqType.getp() << "\n"; cout.flush();
#endif
        
        if ( xqType!=NULL && xqType->content_kind()==XQType::SIMPLE_CONTENT_KIND )
        {
          store::NsBindings nsBindings;
          parent->getNamespaceBindings(nsBindings);
          std::vector<store::Item_t> typedValues;
          processTextValue(sctx,
                           typeManager,
                           nsBindings,
                           typeQName,
                           childStringValue,
                           typedValues );
          
          if ( typedValues.size()==1 ) // hack around serialization bug
            GENV_ITEMFACTORY->createTextNode(validatedTextNode, parent, typedValues[0]);
          else
            GENV_ITEMFACTORY->createTextNode(validatedTextNode, parent, typedValues);
        }
        else if ( xqType!=NULL && xqType->content_kind()==XQType::MIXED_CONTENT_KIND )
        {
          GENV_ITEMFACTORY->createTextNode(validatedTextNode,
                                           parent,
                                           childIndex,
                                           childStringValue);
        }
      }
      break;
      
      case store::StoreConsts::piNode:
      {
        //cout << "     - pi: " << child->getStringValue() << "\n"; cout.flush();
        store::Item_t piNode;
        xqpStringStore_t piTarget = child->getTarget();
        xqpStringStore_t childStringValue = child->getStringValue();
        xqpStringStore_t childBaseUri = child->getBaseURI();
        GENV_ITEMFACTORY->createPiNode(piNode, parent, -1, piTarget, childStringValue, childBaseUri);                    
      }
      break;
      
      case store::StoreConsts::commentNode:
      {
        //cout << "     - comment: " << child->getStringValue() << "\n"; cout.flush();
        store::Item_t commentNode;
        xqpStringStore_t childStringValue = child->getStringValue();
        GENV_ITEMFACTORY->createCommentNode(commentNode, parent, -1, childStringValue); 
      }
      break;
                
      case store::StoreConsts::anyNode:
        //cout << "     - any: " << child->getStringValue() << "\n"; cout.flush();
        ZORBA_ASSERT(false);                    
        break;
                                    
      default:
        ZORBA_ASSERT(false);
      }
    }
    
    childIndex++;
  }
}


void ValidateIterator::processNamespaces (
    EventSchemaValidator& schemaValidator,
    const store::Item_t& item)
{
  store::NsBindings bindings;
  item->getNamespaceBindings(bindings, store::StoreConsts::ONLY_LOCAL_NAMESPACES);

  for (unsigned long i = 0; i < bindings.size(); i++)
  {
    schemaValidator.ns( bindings[i].first.getStore(), bindings[i].second.getStore() );
  }
}
    

void ValidateIterator::processTextValue (
    static_context* sctx,
    TypeManager* typeManager, 
    store::NsBindings& bindings,
    const store::Item_t& typeQName,
    xqpStringStore_t& textValue, 
    std::vector<store::Item_t>& resultList)
{
  xqtref_t type = typeManager->
                  create_named_type(typeQName.getp(), TypeConstants::QUANT_ONE);
//  cout << "     - processTextValue: " << typeQName->getPrefix()->str()
//       << ":" << typeQName->getLocalName()->str() << "@"
//       << typeQName->getNamespace()->str() ; cout.flush();
//  cout << " type: " << ( type==NULL ? "NULL" : type->toString() ) << "\n";
//  cout.flush();
  
  // TODO: we probably need the ns bindings from the static context
  // surrounding the original validate_expr, not planState.sctx()
  namespace_context nsCtx = namespace_context(sctx, bindings);
  
  store::Item_t result;                    
  if (type != NULL)
  {
    if ( type->type_kind() == XQType::USER_DEFINED_KIND )
    {
      const UserDefinedXQType udt = static_cast<const UserDefinedXQType&>(*type);

      if ( udt.isList() || udt.isUnion() )
      {
        typeManager->getSchema()->parseUserSimpleTypes(textValue, type, resultList);
      }
      else if (udt.isAtomic())
      {
        bool res = typeManager->getSchema()->parseUserAtomicTypes(textValue,
                                                                  type.getp(),
                                                                  result);
        ZORBA_ASSERT(res);
        resultList.push_back(result);
    }
    }
    else if (type->type_kind() == XQType::ATOMIC_TYPE_KIND)
    {
      bool res = GenericCast::castToAtomic(result, textValue, type.getp(), &nsCtx);
      ZORBA_ASSERT(res);
      resultList.push_back(result);
    }
    else
    {
      if ( GENV_ITEMFACTORY->createUntypedAtomic( result, textValue) )
        resultList.push_back(result);
    }
  }
  else
  {
    if ( GENV_ITEMFACTORY->createUntypedAtomic( result, textValue) )
      resultList.push_back(result);
  }
}

#endif//#ifndef ZORBA_NO_XMLSCHEMA
    
    /* end class ValidateIterator */
}


#endif // ifndef ZORBA_NO_XMLSCHEMA
