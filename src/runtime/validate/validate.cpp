/*
* Copyright 2006-2008 The FLWOR Foundation.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
#include "system/globalenv.h"

#include "types/casting.h"
#include "types/delegating_typemanager.h"
#include "types/typeops.h"
#include "types/schema/SchemaValidatorFilter.h"

#include "runtime/validate/validate.h"
#include "runtime/api/runtimecb.h"
#include "runtime/accessors/AccessorsImpl.h"
#include "runtime/api/plan_iterator_wrapper.h"
#include "runtime/util/item_iterator.h"

#include "store/api/item.h"
#include "store/api/item_factory.h"
#include "store/api/copymode.h"
#include "store/api/store.h"
#include "store/api/temp_seq.h"

#include "context/dynamic_context.h"
#include "context/static_context.h"
#include "context/collation_cache.h"
#include "zorbatypes/duration.h"
#include "zorbatypes/datetime.h"
#include "zorbaerrors/error_messages.h"
#include "zorbaerrors/errors.h"

#ifndef ZORBA_NO_XMLSCHEMA

namespace zorba
{

    /*______________________________________________________________________
    |
    | 3.13 
    | validate [ | lax | strict] {  } 
    |
    | A validate expression returns a new node with its own identity and 
    | with no parent. The new node and its descendants are given type 
    | annotations that are generated by applying a validation process to 
    | the operand node. In some cases, default values may also be generated 
    | by the validation process.
    |_______________________________________________________________________*/
    ValidateIterator::ValidateIterator ( const QueryLoc& loc, PlanIter_t& aIter, bool isLax )
        :
    UnaryBaseIterator<ValidateIterator, PlanIteratorState> ( loc, aIter ) , _isLax(isLax)
    {}

    ValidateIterator::~ValidateIterator() 
    {}

    bool ValidateIterator::nextImpl(store::Item_t& result, PlanState& planState) const
    {
        PlanIteratorState* aState;
        DEFAULT_STACK_INIT(PlanIteratorState, aState, planState);
        STACK_PUSH (
            ValidateIterator::effectiveValidationValue ( result, this->loc, planState, theChild, _isLax ),
            aState
            );
        STACK_END (aState);
    }

    bool ValidateIterator::effectiveValidationValue ( store::Item_t& result, const QueryLoc& loc, 
        PlanState& planState, const PlanIterator* iter, bool isLax)
    {
        bool returnVal = false;
        store::Item_t item;
        xqtref_t type;

        bool valid = consumeNext(item, iter, planState);

        if ( !valid )
        {
             ZORBA_ERROR_LOC_DESC( XQDY0061, loc, "Wrong arguments in validate expression.");
        }
        else if ( item->isNode() )
        {
            static_context* staticContext = planState.sctx();
            //dynamic_context* dynamicContext = planState.dctx();
            TypeManager * typeManager = staticContext->get_typemanager();
            DelegatingTypeManager* delegatingTypeManager = 
                static_cast<DelegatingTypeManager*>(typeManager);

            Schema* schema = delegatingTypeManager->getSchema();
            if ( !schema )
            {
                // no schema available - items remain the same
                result = item;
                return true;
            }

            xqpStringStore_t baseUri = planState.theRuntimeCB->theStaticContext->
                final_baseuri().getStore();

            SchemaValidator schemaValidator = SchemaValidator(schema->getGrammarPool(), isLax, loc);
            

            switch ( item->getNodeKind() )
            {
            case store::StoreConsts::documentNode:
            {
                //std::cout << "Validate document" << "\n"; std::cout.flush();

                schemaValidator.startDoc();
                processChildren( schemaValidator, item, item->getAttributes() );
                processChildren( schemaValidator, item, item->getChildren() );

                //GENV_ITEMFACTORY->createDocumentNode(result, (ulong)&planState, baseUri, children);

                schemaValidator.endDoc();

                //std::cout << "End Validate" << "\n"; std::cout.flush();
                //break;
                result = item;
                return true;
            }
            case store::StoreConsts::elementNode: 
            {
                //std::cout << "Validate element" << "\n"; std::cout.flush();

                schemaValidator.startDoc();

                store::Item_t newElem = processElement(schemaValidator, NULL, item);

                schemaValidator.endDoc();
                
                //std::cout << "End Validate" << "\n"; std::cout.flush();
                //break;
                //result = item;
                result = newElem;
                return true;
            }
            default:
                ZORBA_ERROR_LOC_DESC( XQDY0061, loc, 
                    "Argument in validate expression not a document or element node.");
                returnVal = false;
                result = NULL;
            }
        }
        else
        {
            ZORBA_ERROR_LOC_DESC( XQDY0061, loc, "Argument in validate expression not a document node.");
            returnVal = false;
            result = NULL;
        }

        return returnVal;
    }

    store::Item_t ValidateIterator::processElement( SchemaValidator& schemaValidator, store::Item_t parent, 
        store::Item_t element)
    {
        ZORBA_ASSERT(element->isNode());
        ZORBA_ASSERT(element->getNodeKind() == store::StoreConsts::elementNode);

        store::Item_t typeName = element->getType();
        store::Item_t nodeName = element->getNodeName();

        schemaValidator.startElem(nodeName);


        // namespace declarations must go first
        processNamespaces( schemaValidator, element);

        // since the type of an element is determined only after the validator receives all 
        // of it's attributes, and an attribute node needs it's parent when created 
        // we need to go through the attributes twice: once for validation and once for creation
        validateAttributes(schemaValidator, element->getAttributes());

        store::Item_t newElem;

        store::NsBindings bindings;
        element->getNamespaceBindings(bindings);

        store::Item_t elemName = element->getNodeName();
        GENV_ITEMFACTORY->createElementNode(newElem, parent, -1, elemName, typeName, 
            bindings, element->getBaseURI(), true);


        processAttributes( schemaValidator, newElem, element->getAttributes());
        processChildren( schemaValidator, newElem, element->getChildren());


        schemaValidator.endElem(nodeName);

        return newElem;
    }

    void ValidateIterator::validateAttributes( SchemaValidator& schemaValidator, store::Iterator_t attributes)
    {
        store::Item_t attribute;
        
        while ( attributes->next(attribute) )
        {
            ZORBA_ASSERT(attribute->isNode());
            ZORBA_ASSERT(attribute->getNodeKind() == store::StoreConsts::attributeNode);

            //std::cout << "     - attr: " << child->getNodeName()->getLocalName()->c_str() << "\n"; std::cout.flush();
                        
            store::Item_t attName = attribute->getNodeName();
            schemaValidator.attr(attName, attribute->getStringValue());
        }
    }

    void ValidateIterator::processAttributes( SchemaValidator& schemaValidator, store::Item_t parent, 
        store::Iterator_t attributes)
    {
        store::Item_t attribute;
        
        while ( attributes->next(attribute) )
        {
            ZORBA_ASSERT(attribute->isNode());
            ZORBA_ASSERT(attribute->getNodeKind() == store::StoreConsts::attributeNode);
                
            store::Item_t attName = attribute->getNodeName();
            store::Item_t typeName = attribute->getType();
            
            store::Item_t textValue;
            GENV_ITEMFACTORY->createString( textValue, attribute->getStringValue() );                        
            
            store::Item_t validatedAttNode;
            GENV_ITEMFACTORY->createAttributeNode( validatedAttNode, parent, -1, attName,
                typeName, textValue );
        }
    }

    void ValidateIterator::processChildren( SchemaValidator& schemaValidator, store::Item_t parent, 
        store::Iterator_t children)
    {
        store::Item_t child;

        store::Item_t typeName;
        
        while ( children->next(child) )
        {
            if ( child->isNode() )
            {
                //std::cout << "  > child: " << child->getNodeKind() << " " << child->getType()->getLocalName()->c_str() << "\n";
                //std::cout.flush();
                
                switch ( child->getNodeKind() )
                { 
                case store::StoreConsts::elementNode:                                     
                    processElement( schemaValidator, parent, child);
                    break;
                    
                case store::StoreConsts::attributeNode:
                    ZORBA_ASSERT(false);
                    break;
                
                case store::StoreConsts::documentNode:
                    ZORBA_ASSERT(false);                    
                    break;
                
                case store::StoreConsts::textNode:
                    {
                        //std::cout << "     - text: " << child->getStringValue() << "\n"; std::cout.flush();                    
                        schemaValidator.text(child->getStringValue());

                        store::Item_t validatedTextNode;
                        GENV_ITEMFACTORY->createTextNode(validatedTextNode, parent, -1, child->getStringValue());
                    }
                    break;
                
                case store::StoreConsts::piNode:
                    {
                        //std::cout << "     - pi: " << child->getStringValue() << "\n"; std::cout.flush();
                        store::Item_t piNode;
                        xqpStringStore_t piTarget = child->getTarget();
                        GENV_ITEMFACTORY->createPiNode(piNode, parent, -1, piTarget, child->getStringValue(), child->getBaseURI());                    
                    }
                    break;
                
                case store::StoreConsts::commentNode:
                    {
                        //std::cout << "     - comment: " << child->getStringValue() << "\n"; std::cout.flush();
                        store::Item_t commentNode;
                        GENV_ITEMFACTORY->createCommentNode(commentNode, parent, -1, child->getStringValue());                    
                    }
                    break;
                
                case store::StoreConsts::anyNode:
                    //std::cout << "     - any: " << child->getStringValue() << "\n"; std::cout.flush();
                    // todo Cezar: check with Marcos
                    break;
                                    
                default:
                    ZORBA_ASSERT(false);
                }
            }
        }
    }

    void ValidateIterator::processNamespaces ( SchemaValidator& schemaValidator, store::Item_t item)
    {
        store::NsBindings bindings;
        item->getNamespaceBindings(bindings, store::StoreConsts::ONLY_LOCAL_NAMESPACES);

        for (unsigned long i = 0; i < bindings.size(); i++)
        {
            schemaValidator.ns( bindings[i].first.getStore(), bindings[i].second.getStore() );
        }
    }

    /* end class ValidateIterator */
}


#endif//#ifndef ZORBA_NO_XMLSCHEMA
