/*
* Copyright 2006-2008 The FLWOR Foundation.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
#include "system/globalenv.h"

#include "types/casting.h"
#include "types/typeops.h"
#include "types/schema/SchemaValidatorFilter.h"
#include "types/schema/StrX.h"

#include "runtime/validate/validate.h"
#include "runtime/api/runtimecb.h"
#include "runtime/accessors/AccessorsImpl.h"
#include "runtime/api/plan_iterator_wrapper.h"
#include "runtime/util/item_iterator.h"

#include "store/api/item.h"
#include "store/api/item_factory.h"
#include "store/api/copymode.h"
#include "store/api/store.h"
#include "store/api/temp_seq.h"

#include "context/dynamic_context.h"
#include "context/static_context.h"
#include "context/collation_cache.h"
#include "context/namespace_context.h"
#include "zorbatypes/duration.h"
#include "zorbatypes/datetime.h"
#include "zorbaerrors/error_messages.h"
#include "zorbaerrors/errors.h"

#ifndef ZORBA_NO_XMLSCHEMA

namespace zorba
{

    /*______________________________________________________________________
    |
    | 3.13 
    | validate [ | lax | strict] {  } 
    |
    | A validate expression returns a new node with its own identity and 
    | with no parent. The new node and its descendants are given type 
    | annotations that are generated by applying a validation process to 
    | the operand node. In some cases, default values may also be generated 
    | by the validation process.
    |_______________________________________________________________________*/
    ValidateIterator::ValidateIterator ( const QueryLoc& loc, PlanIter_t& aIter, bool isLax )
        :
    UnaryBaseIterator<ValidateIterator, PlanIteratorState> ( loc, aIter ) , _isLax(isLax)
    {}

    ValidateIterator::~ValidateIterator() 
    {}

    bool ValidateIterator::nextImpl(store::Item_t& result, PlanState& planState) const
    {
        PlanIteratorState* aState;
        DEFAULT_STACK_INIT(PlanIteratorState, aState, planState);
        STACK_PUSH (
            ValidateIterator::effectiveValidationValue ( result, this->loc, planState, theChild, _isLax ),
            aState
            );
        STACK_END (aState);
    }

    bool ValidateIterator::effectiveValidationValue ( store::Item_t& result, const QueryLoc& loc, 
        PlanState& planState, const PlanIterator* iter, bool isLax)
    {
        bool returnVal = false;
        store::Item_t item;
        xqtref_t type;

        bool valid = consumeNext(item, iter, planState);

        if ( !valid )
        {
             ZORBA_ERROR_LOC_DESC( XQDY0061, loc, "Wrong arguments in validate expression.");
        }
        else if ( item->isNode() )
        {
            static_context* staticContext = planState.sctx();
            //dynamic_context* dynamicContext = planState.dctx();
            TypeManager * typeManager = staticContext->get_typemanager();
            DelegatingTypeManager* delegatingTypeManager = 
                static_cast<DelegatingTypeManager*>(typeManager);

            Schema* schema = delegatingTypeManager->getSchema();
            if ( !schema )
            {
                // no schema available - items remain the same
                result = item;
                return true;
            }

            xqpStringStore_t baseUri = planState.theRuntimeCB->theStaticContext->
                final_baseuri().getStore();

            
            SchemaValidator schemaValidator = SchemaValidator(typeManager, 
                schema->getGrammarPool(), isLax, loc);
            

            switch ( item->getNodeKind() )
            {
            case store::StoreConsts::documentNode:
            {
                //std::cout << "Validate document" << "\n"; std::cout.flush();

                schemaValidator.startDoc();

                xqpStringStore_t docBaseUri = item->getBaseURI();
                xqpStringStore_t docUri = item->getDocumentURI();
                store::Item_t newDoc;
                GENV_ITEMFACTORY->createDocumentNode(newDoc, docBaseUri, docUri, true);

                processChildren( planState, delegatingTypeManager, schemaValidator, newDoc, item->getChildren() );

                schemaValidator.endDoc();

                //std::cout << "End Validate doc" << "\n"; std::cout.flush();
                //break;
                result = newDoc;
                return true;
            }
            case store::StoreConsts::elementNode: 
            {
                //std::cout << "Validate element" << "\n"; std::cout.flush();

                schemaValidator.startDoc();

                store::Item_t newElem = processElement(planState, delegatingTypeManager, schemaValidator, NULL, item);

                schemaValidator.endDoc();
                
                //std::cout << "End Validate elem" << "\n"; std::cout.flush();

                result = newElem;
                return true;
            }
            default:
                ZORBA_ERROR_LOC_DESC( XQDY0061, loc, 
                    "Argument in validate expression not a document or element node.");
                returnVal = false;
                result = NULL;
            }
        }
        else
        {
            ZORBA_ERROR_LOC_DESC( XQDY0061, loc, "Argument in validate expression not a document node.");
            returnVal = false;
            result = NULL;
        }

        return returnVal;
    }

    store::Item_t ValidateIterator::processElement( PlanState& planState, DelegatingTypeManager* delegatingTypeManager, 
        SchemaValidator& schemaValidator, store::Item *parent, const store::Item_t& element)
    {
        ZORBA_ASSERT(element->isNode());
        ZORBA_ASSERT(element->getNodeKind() == store::StoreConsts::elementNode);

        
        store::Item_t nodeName = element->getNodeName();
        xqpStringStore_t baseUri = element->getBaseURI();

        schemaValidator.startElem(nodeName);


        // namespace declarations must go first
        processNamespaces( schemaValidator, element);

        // since the type of an element is determined only after the validator receives all 
        // of it's attributes, and an attribute node needs it's parent when created 
        // we need to go through the attributes twice: once for validation and once for creation
        validateAttributes(schemaValidator, element->getAttributes());
        
        store::Item_t typeName = schemaValidator.getTypeQName();

        store::Item_t newElem;

        store::NsBindings bindings;
        element->getNamespaceBindings(bindings);

        store::Item_t elemName = element->getNodeName();
        GENV_ITEMFACTORY->createElementNode(newElem, parent, -1, elemName,
                                            typeName, true, false, false, false, 
                                            bindings, baseUri, false);


        processAttributes( planState, delegatingTypeManager, schemaValidator, (store::Item *)newElem, 
            element->getAttributes());
        
        processChildren( planState, delegatingTypeManager, schemaValidator, (store::Item *)newElem, 
            element->getChildren());


        schemaValidator.endElem(nodeName);

        return newElem;
    }

    void ValidateIterator::validateAttributes( SchemaValidator& schemaValidator, store::Iterator_t attributes)
    {
        store::Item_t attribute;
        
        while ( attributes->next(attribute) )
        {
            ZORBA_ASSERT(attribute->isNode());
            ZORBA_ASSERT(attribute->getNodeKind() == store::StoreConsts::attributeNode);

            //std::cout << " v    - attr: " << attribute->getNodeName()->getLocalName()->c_str() << "\n"; std::cout.flush();
                        
            store::Item_t attName = attribute->getNodeName();
            schemaValidator.attr(attName, attribute->getStringValue());
        }
    }

    void ValidateIterator::processAttributes( PlanState& planState, DelegatingTypeManager* delegatingTypeManager, 
        SchemaValidator& schemaValidator, store::Item *parent, store::Iterator_t attributes)
    {
        std::list<AttributeValidationInfo*>* attList = schemaValidator.getAttributeList();
        std::list<AttributeValidationInfo*>::iterator curAtt;
         
        for( curAtt = attList->begin() ; curAtt != attList->end(); ++curAtt )
        {
            AttributeValidationInfo* att = *curAtt;
            //std::cout << " v    proccessATT2: " << att->_localName << " T: " << att->_typeName << "\n";
             
            store::Item_t attQName;
            GENV_ITEMFACTORY->createQName( attQName, att->_uri, att->_prefix, att->_localName);
            
          
            std::string typePrefix;
            if ( std::strcmp(Schema::XSD_NAMESPACE, att->_typeURI->c_str() )==0 ) // hack around typeManager bug for comparing QNames
                typePrefix = "xs";
            else
                typePrefix = "";
            
            store::Item_t typeQName;
            GENV_ITEMFACTORY->createQName(typeQName, att->_typeURI, new xqpStringStore(typePrefix), att->_typeName);

            store::NsBindings bindings;
            parent->getNamespaceBindings(bindings);
            store::Item_t typedValue = processTextValue(planState, delegatingTypeManager, bindings, typeQName, att->_value);
            
            store::Item_t validatedAttNode;
            GENV_ITEMFACTORY->createAttributeNode( validatedAttNode, parent, -1, attQName, 
                typeQName, typedValue, false, false );
        }
    }

    void ValidateIterator::processChildren( PlanState& planState, DelegatingTypeManager* delegatingTypeManager, 
        SchemaValidator& schemaValidator, store::Item *parent, store::Iterator_t children)
    {
        store::Item_t child;

        store::Item_t typeName;
        
        while ( children->next(child) )
        {
            if ( child->isNode() )
            {
                //std::cout << "  > child: " << child->getNodeKind() << " " << child->getType()->getLocalName()->c_str() << "\n";
                //std::cout.flush();
                
                switch ( child->getNodeKind() )
                { 
                case store::StoreConsts::elementNode:                                     
                    processElement( planState, delegatingTypeManager, schemaValidator, parent, child);
                    break;
                    
                case store::StoreConsts::attributeNode:
                    ZORBA_ASSERT(false);
                    break;
                
                case store::StoreConsts::documentNode:
                    ZORBA_ASSERT(false);                    
                    break;
                
                case store::StoreConsts::textNode:
                    {
                        //std::cout << "     - text: " << child->getStringValue() << "\n"; std::cout.flush();                    
                        xqpStringStore_t childStringValue = child->getStringValue();
                        schemaValidator.text(childStringValue);

                        store::Item_t type = schemaValidator.getTypeQName();

                        store::NsBindings nsBindings;
                        parent->getNamespaceBindings(nsBindings);
                        store::Item_t typedValue = processTextValue(planState, delegatingTypeManager, nsBindings, type, childStringValue );
                        
                        store::Item_t validatedTextNode;
                        GENV_ITEMFACTORY->createTextNode(validatedTextNode, parent, typedValue);
                    }
                    break;
                
                case store::StoreConsts::piNode:
                    {
                        //std::cout << "     - pi: " << child->getStringValue() << "\n"; std::cout.flush();
                        store::Item_t piNode;
                        xqpStringStore_t piTarget = child->getTarget();
                        xqpStringStore_t childStringValue = child->getStringValue();
                        xqpStringStore_t childBaseUri = child->getBaseURI();
                        GENV_ITEMFACTORY->createPiNode(piNode, parent, -1, piTarget, childStringValue, childBaseUri);                    
                    }
                    break;
                
                case store::StoreConsts::commentNode:
                    {
                        //std::cout << "     - comment: " << child->getStringValue() << "\n"; std::cout.flush();
                        store::Item_t commentNode;
                        xqpStringStore_t childStringValue = child->getStringValue();
                        GENV_ITEMFACTORY->createCommentNode(commentNode, parent, -1, childStringValue);                    
                    }
                    break;
                
                case store::StoreConsts::anyNode:
                    //std::cout << "     - any: " << child->getStringValue() << "\n"; std::cout.flush();
                    ZORBA_ASSERT(false);                    
                    break;
                                    
                default:
                    ZORBA_ASSERT(false);
                }
            }
        }
    }

    void ValidateIterator::processNamespaces ( SchemaValidator& schemaValidator, const store::Item_t& item)
    {
        store::NsBindings bindings;
        item->getNamespaceBindings(bindings, store::StoreConsts::ONLY_LOCAL_NAMESPACES);

        for (unsigned long i = 0; i < bindings.size(); i++)
        {
            schemaValidator.ns( bindings[i].first.getStore(), bindings[i].second.getStore() );
        }
    }
    
    store::Item_t ValidateIterator::processTextValue (PlanState& planState, DelegatingTypeManager* delegatingTypeManager, 
        store::NsBindings bindings, store::Item_t typeQName, xqpStringStore_t& textValue)
    {
        xqtref_t type = delegatingTypeManager->create_named_atomic_type(typeQName, TypeConstants::QUANT_ONE);
        //std::cout << "     - processTextValue: " << typeQName->getPrefix()->str() << ":" << typeQName->getLocalName()->str() << "@" << 
        //    typeQName->getNamespace()->str() ; std::cout.flush();
        //std::cout << " type: " << ( type==NULL ? "NULL" : type->toString()) << "\n"; std::cout.flush();                    
    
        static_context* staticContext = planState.sctx();
        namespace_context* nsCtx = new namespace_context(staticContext);

        
        store::Item_t result;                    
        if (type!=NULL)
            GenericCast::instance()->cast(result, textValue, type.getp(), nsCtx);
        else
            GENV_ITEMFACTORY->createUntypedAtomic( result, textValue);
                    
        delete nsCtx;

        return result;
    }

    /* end class ValidateIterator */
}


#endif//#ifndef ZORBA_NO_XMLSCHEMA
