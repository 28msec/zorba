<?xml version="1.0" encoding="UTF-8"?>

<!--
/////////////////////////////////////////////////////////////////////////////////
//                                                                             //
//  15.1 General Functions and Operators on Sequences                          //
//                                                                             //
/////////////////////////////////////////////////////////////////////////////////
-->
<zorba:iterators
  xmlns:zorba="http://www.zorba-xquery.com"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.zorba-xquery.com ../runtime.xsd">

<zorba:header>
    <zorba:include form="Quoted">runtime/base/narybase.h</zorba:include>
    <zorba:include form="Quoted">runtime/core/path_iterators.h</zorba:include>
    <zorba:include form="Quoted">zorbatypes/integer.h</zorba:include>
    <zorba:include form="Angle-bracket">zorba/internal/unique_ptr.h</zorba:include>
    <zorba:fwd-decl ns="zorba">StructuredItemHandleHashSet</zorba:fwd-decl>
    <zorba:fwd-decl ns="zorba">AtomicItemHandleHashSet</zorba:fwd-decl>
</zorba:header>

<zorba:source>
    <zorba:include form="Quoted">zorbautils/hashset_atomic_itemh.h</zorba:include>
</zorba:source>

<zorba:codegen>
  <zorba:cpp>
    <zorba:include form="Quoted">system/globalenv.h</zorba:include>
    <zorba:include form="Quoted">types/typeops.h</zorba:include>
    <zorba:include form="Quoted">compiler/expression/expr_base.h</zorba:include>
  </zorba:cpp>
</zorba:codegen>

<!--
/*******************************************************************************
  15.1.2 op:concatenate
********************************************************************************/
-->
<zorba:iterator name="FnConcatIterator"
                generateResetImpl="true"
                generateOpenImpl="true">

  <zorba:description author="Zorba Team">
    op:concatenate
  </zorba:description>

  <zorba:function>

    <zorba:signature variadic="true" localname="concatenate" prefix="op">
      <zorba:param>item()*</zorba:param>
      <zorba:output>item()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getReturnType/>
      <zorba:ignoresSortedNodes/>
      <zorba:ignoresDuplicateNodes/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>

  <zorba:state generateInit="use-default" generateReset="use-default">
    <zorba:member type="std::vector&lt;PlanIter_t&gt;::const_iterator" name="theCurIter"
                  brief="iterator pointing to the child that is currently being processed"/>
    <zorba:member type="std::vector&lt;PlanIter_t&gt;::const_iterator" name="theEndIter" brief=""/>
  </zorba:state>

</zorba:iterator>


<!--
/*******************************************************************************
  15.1.3 fn:index-of($seqParam as xs:anyAtomicType*,
                     $srchParam as xs:anyAtomicType) as xs:integer*

         fn:index-of($seqParam as xs:anyAtomicType*,
                     $srchParam as xs:anyAtomicType,
                     $collation as xs:string) as xs:integer*
********************************************************************************/
-->
<zorba:iterator name="FnIndexOfIterator">

  <zorba:description author="Zorba Team">
  Summary: Returns a sequence of positive integers giving the positions
  within the sequence $seqParam of items that are equal to $srchParam.

  The collation used by the invocation of this function is determined
  according to the rules in 7.3.1 Collations. The collation is used when
  string comparison is required.

  The items in the sequence $seqParam are compared with $srchParam under
  the rules for the 'eq' operator. Values that cannot be compared, i.e.
  the 'eq' operator is not defined for their types, are considered to be
  distinct. If an item compares equal, then the position of that item in
  the sequence $seqParam is included in the result.

  If the value of $seqParam is the empty sequence, or if no item in
  $seqParam matches $srchParam, then the empty sequence is returned.

  The first item in a sequence is at position 1, not position 0.
  The result sequence is in ascending numeric order.
  </zorba:description>

  <zorba:function generateCodegen="false">

    <zorba:signature localname="index-of" prefix="fn">
      <zorba:param>xs:anyAtomicType*</zorba:param>
      <zorba:param>xs:anyAtomicType</zorba:param>
      <zorba:output>xs:integer*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="index-of" prefix="fn">
      <zorba:param>xs:anyAtomicType*</zorba:param>
      <zorba:param>xs:anyAtomicType</zorba:param>
      <zorba:param>xs:string</zorba:param>
      <zorba:output>xs:integer*</zorba:output>
    </zorba:signature>

  </zorba:function>

  <zorba:state>
    <zorba:member type="uint32_t" name="theCurrentPos" defaultValue="0"
                  brief="the current position in the sequence"/>

    <zorba:member type="store::Item_t" name="theSearchItem" defaultValue="NULL"
                  brief="the item to search for"/>

    <zorba:member type="XQPCollator*" name="theCollator" defaultValue="0"
                  brief="the collator"/>
  </zorba:state>

  <zorba:constructor>
    <zorba:parameter type="int" name="fastComp"/>
  </zorba:constructor>

  <zorba:member type="int" name="theFastComp"/>

</zorba:iterator>

<!--
/*******************************************************************************
  15.1.4 fn:empty($arg as item()*) as xs:boolean
********************************************************************************/
-->
<zorba:iterator name="FnEmptyIterator">

  <zorba:description author="Zorba Team">
  If the value of $arg is the empty sequence, the function returns true;
  otherwise, the function returns false.
  </zorba:description>

  <zorba:function>

    <zorba:signature localname="empty" prefix="fn">
      <zorba:param>item()*</zorba:param>
      <zorba:output>xs:boolean</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:ignoresSortedNodes/>
      <zorba:ignoresDuplicateNodes/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
  15.1.5 fn:exists($arg as item()*) as xs:boolean
********************************************************************************/
-->
<zorba:iterator name="FnExistsIterator">

  <zorba:description author="Zorba Team">
  If the value of $arg is not the empty sequence, the function returns true;
  otherwise, the function returns false.
  </zorba:description>

  <zorba:function >
    <zorba:signature localname="exists" prefix="fn">
      <zorba:param>item()*</zorba:param>
      <zorba:output>xs:boolean</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:ignoresSortedNodes/>
      <zorba:ignoresDuplicateNodes/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>
  </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
  15.1.6 fn:distinct-values($arg as xs:anyAtomicType*) as xs:anyAtomicType*

         fn:distinct-values($arg as xs:anyAtomicType*,
                            $collation as xs:string) as xs:anyAtomicType*
********************************************************************************/
-->
<zorba:iterator name="FnDistinctValuesIterator">

  <zorba:description author="Zorba Team">
  Returns the sequence that results from removing from arg all but one of a
  set of values that are eq to one other. Values of type xs:untypedAtomic are
  compared as if they were of type xs:string. Values that cannot be compared,
  i.e. the eq operator is not defined for their types, are considered to be
  distinct. The order in which the sequence of values is returned is implementation
  dependent. In zorba, we return the first item that is not a duplicate and
  throw away the remaining ones.
  </zorba:description>

  <zorba:function>

   <zorba:signature localname="distinct-values" prefix="fn">
      <zorba:param>xs:anyAtomicType*</zorba:param>
      <zorba:param>xs:string</zorba:param>
      <zorba:output>xs:anyAtomicType*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="distinct-values" prefix="fn">
      <zorba:param>xs:anyAtomicType*</zorba:param>
      <zorba:output>xs:anyAtomicType*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getReturnType/>
      <zorba:ignoresSortedNodes/>
      <zorba:ignoresDuplicateNodes/>
    </zorba:methods>

  </zorba:function>

  <zorba:state generateInit="true" generateReset="false">
    <zorba:member type="bool" name="theHasNaN"
                  defaultValue="false"
                  brief="indicates whether NaN was found in the sequence"/>

    <zorba:member name="theAlreadySeenMap"
                  type="std::unique_ptr&lt;AtomicItemHandleHashSet>"
                  brief="hashmap for doing the duplicate elimination"/>

  </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
  15.1.7 fn:insert-before($target as item()*,
                          $position as xs:integer,
                          $inserts as item()*) as item()*
********************************************************************************/
-->
<zorba:iterator name="FnInsertBeforeIterator">

  <zorba:description author="Zorba Team">
  Returns a new sequence constructed from the value of the first parameter with
  the value of third parameter inserted at the position specified by the value
  of the second parameter.
  </zorba:description>

  <zorba:function>

    <zorba:signature localname="insert-before" prefix="fn">
      <zorba:param>item()*</zorba:param>
      <zorba:param>xs:integer</zorba:param>
      <zorba:param>item()*</zorba:param>
      <zorba:output>item()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getReturnType/>
      <zorba:ignoresSortedNodes/>
      <zorba:ignoresDuplicateNodes/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>

  <zorba:state>
    <zorba:member type="xs_integer" name="theCurrentPos"
                  defaultValue="numeric_consts&lt;xs_integer&gt;::zero()" brief="the current position in the sequence"/>

    <zorba:member type="xs_integer" name="thePosition"
                  defaultValue="numeric_consts&lt;xs_integer&gt;::zero()" brief=""/>

    <zorba:member type="store::Item_t" name="theTargetItem"
                  defaultValue="NULL" brief=""/>
  </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
  15.1.8 fn:remove($target as item()*, $position as xs:integer) as item()*
********************************************************************************/
-->
<zorba:iterator name="FnRemoveIterator">

  <zorba:description author="Zorba Team">
  Returns a new sequence constructed from the value of aTarget with the item at
  the position specified by the value of aPosition removed.
  </zorba:description>

  <zorba:function>

    <zorba:signature localname="remove" prefix="fn">

      <zorba:param>item()*</zorba:param>
      <zorba:param>xs:integer</zorba:param>
      <zorba:output>item()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getReturnType/>
      <zorba:propagatesDistinctNodes producer="0"/>
      <zorba:propagatesSortedNodes producer="0"/>
      <zorba:ignoresSortedNodes/>
      <zorba:ignoresDuplicateNodes/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>

  <zorba:state>
    <zorba:member type="xs_integer" name="theCurrentPos"
                  defaultValue="numeric_consts&lt;xs_integer&gt;::zero()" brief="the current position in the sequence"/>

    <zorba:member type="xs_integer" name="thePosition"
                  defaultValue="numeric_consts&lt;xs_integer&gt;::zero()" brief="the position to delete"/>

    <zorba:member type="XQPCollator*" name="theCollator"
                  defaultValue="0" brief="the collator"/>
  </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
  15.1.9 fn:reverse($arg as item()*) as item()*
********************************************************************************/
-->
<zorba:iterator name="FnReverseIterator">

  <zorba:description author="Zorba Team">
  fn:reverse
  </zorba:description>

  <zorba:function>

    <zorba:signature localname="reverse" prefix="fn">
      <zorba:param>item()*</zorba:param>
      <zorba:output>item()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getReturnType/>
      <zorba:propagatesDistinctNodes producer="0"/>
      <zorba:ignoresSortedNodes/>
      <zorba:ignoresDuplicateNodes/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>

  <zorba:state generateInit="false" generateReset="false">
    <zorba:member type="std::stack&lt;store::Item_t&gt;"
                  name="theStack" brief=""/>
  </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
  15.1.10 fn:subsequence($sourceSeq as item()*,
                         $startingLoc as xs:double) as item()*

          fn:subsequence($sourceSeq as item()*,
                         $startingLoc as xs:double,
                         $length as xs:double) as item()*
********************************************************************************/
-->
<zorba:iterator name="FnSubsequenceIterator"
                generateResetImpl="true">

  <zorba:description author="Zorba Team">
  fn:subsequence
  </zorba:description>

  <zorba:function generateCodegen="false">

    <zorba:signature localname="subsequence" prefix="fn">
      <zorba:param>item()*</zorba:param>
      <zorba:param>xs:double</zorba:param>
      <zorba:output>item()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="subsequence" prefix="fn">
      <zorba:param>item()*</zorba:param>
      <zorba:param>xs:double</zorba:param>
      <zorba:param>xs:double</zorba:param>
      <zorba:output>item()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getReturnType/>
      <zorba:propagatesDistinctNodes producer="0"/>
      <zorba:propagatesSortedNodes producer="0"/>
      <zorba:mustCopyInputNodes value="false"/>
      <zorba:specializable/>
    </zorba:methods>

  </zorba:function>

  <zorba:state>

    <zorba:member type="xs_long" name="theRemaining"
                  defaultValue="0" brief=""/>
    <zorba:member type="bool" name="theIsChildReset" defaultValue="false"/>
    

  </zorba:state>

</zorba:iterator>


<!--
/*******************************************************************************
  zorbaop:subsequence-int
********************************************************************************/
-->
<zorba:iterator name="SubsequenceIntIterator"
                generateResetImpl="true">

  <zorba:description author="Zorba Team">
    zorbaop:subsequence-int
  </zorba:description>

  <zorba:function generateCodegen="false">

    <zorba:signature localname="subsequence-int" prefix="op-zorba">
      <zorba:param>item()*</zorba:param>
      <zorba:param>xs:integer</zorba:param>
      <zorba:output>item()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="subsequence-int" prefix="op-zorba">
      <zorba:param>item()*</zorba:param>
      <zorba:param>xs:integer</zorba:param>
      <zorba:param>xs:integer</zorba:param>
      <zorba:output>item()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getReturnType/>
      <zorba:propagatesDistinctNodes producer="0"/>
      <zorba:propagatesSortedNodes producer="0"/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>

  <zorba:state>

    <zorba:member type="xs_long" name="theRemaining"
                  defaultValue="0" brief=""/>
    <zorba:member type="bool" name="theIsChildReset" defaultValue="false"/>

  </zorba:state>

</zorba:iterator>


<!--
/*******************************************************************************
   zorbaop:sequence-point-access($sourceSeq as item()*,
                                 $pos as xs:integer) as item()?
********************************************************************************/
-->
<zorba:iterator name="SequencePointAccessIterator"
                generateResetImpl="true">

  <zorba:description author="Zorba Team">
    zorbaop:sequence-point-access
  </zorba:description>

  <zorba:function generateCodegen="false">

    <zorba:signature localname="sequence-point-access" prefix="op-zorba">
      <zorba:param>item()*</zorba:param>
      <zorba:param>xs:integer</zorba:param>
      <zorba:output>item()?</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getReturnType/>
      <zorba:propagatesDistinctNodes producer="0"/>
      <zorba:propagatesSortedNodes producer="0"/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>

  <zorba:state>
    <zorba:member type="bool" name="theIsChildReset" defaultValue="false"/>
  </zorba:state>

</zorba:iterator>


<!--
/*******************************************************************************
  15.1.11 fn:unordered(($sourceSeq as item()*) as item()*

  see in ../func_sequences_impl.h
********************************************************************************/
-->


<!--
/*******************************************************************************
  15.2.1 fn:zero-or-one($arg as item()*) as item()?
********************************************************************************/
-->
<zorba:iterator name="FnZeroOrOneIterator">

  <zorba:description author="Zorba Team">
  Returns $arg if it contains zero or one items. Otherwise, raises err:FORG0003.
  </zorba:description>

    <zorba:function generateCodegen="false">
      <zorba:signature localname="zero-or-one" prefix="fn">
        <zorba:param>item()*</zorba:param>
        <zorba:output>item()?</zorba:output>
      </zorba:signature>

    <zorba:methods>
      <zorba:getReturnType/>
      <zorba:ignoresSortedNodes/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

   </zorba:function>

    <zorba:constructor>
        <zorba:parameter type="bool" name="doDistinct" defaultValue="false"/>
    </zorba:constructor>

    <zorba:member type="bool" name="theDoDistinct" brief=""/>

</zorba:iterator>

<!--
/*******************************************************************************
  15.2.2 fn:one-or-more($arg as item()*) as item()+
********************************************************************************/
-->
<zorba:iterator name="FnOneOrMoreIterator">

  <zorba:description author="Zorba Team">
  Returns $arg if it contains one or more items. Otherwise, raises err:FORG0004.
  </zorba:description>

  <zorba:function>

    <zorba:signature localname="one-or-more" prefix="fn">
      <zorba:param>item()*</zorba:param>
      <zorba:output>item()+</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getReturnType/>
      <zorba:isMap producer="0"/>
      <zorba:propagatesDistinctNodes producer="0"/>
      <zorba:propagatesSortedNodes producer="0"/>
      <zorba:ignoresSortedNodes/>
      <zorba:ignoresDuplicateNodes/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
  15.2.3 fn:exactly-one($arg as item()*) as item()
********************************************************************************/
-->
<zorba:iterator name="FnExactlyOneIterator" generateCodegen="false">

  <zorba:description author="Zorba Team">
  Returns $arg if it contains exactly one item. Otherwise, raises err:FORG0005.
  </zorba:description>

  <zorba:constructor>
      <zorba:parameter type="bool" name="raiseError" defaultValue="true"/>
      <zorba:parameter type="bool" name="doDistinct" defaultValue="false"/>
  </zorba:constructor>

  <zorba:member type="bool" name="theRaiseError" brief=""/>
  <zorba:member type="bool" name="theDoDistinct" brief=""/>

</zorba:iterator>

<!--
/*******************************************************************************
  15.3.1 fn:deep-equal($parameter1 as item()*,
                       $parameter2 as item()*) as xs:boolean

         fn:deep-equal($parameter1 as item()*,
                       $parameter2 as item()*,
                       $collation as string) as xs:boolean
********************************************************************************/
-->
<zorba:iterator name="FnDeepEqualIterator">

  <zorba:description author="Zorba Team">
  This function assesses whether two sequences are deep-equal to each other. To
  be deep-equal, they must contain items that are pairwise deep-equal; and for
  two items to be deep-equal, they must either be atomic values that compare equal,
  or nodes of the same kind, with the same name, whose children are deep-equal.
  </zorba:description>

  <zorba:function>

    <zorba:signature localname="deep-equal" prefix="fn">
      <zorba:param>item()*</zorba:param>
      <zorba:param>item()*</zorba:param>
      <zorba:output>xs:boolean</zorba:output>
    </zorba:signature>

    <zorba:signature localname="deep-equal" prefix="fn">
      <zorba:param>item()*</zorba:param>
      <zorba:param>item()*</zorba:param>
      <zorba:param>xs:string</zorba:param>
      <zorba:output>xs:boolean</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:mustCopyInputNodes/>
    </zorba:methods>

  </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
  15.3.2 op:union($parameter1 as node()*, $parameter2 as node()*) as node()*

   union is implemented using concat and sort
********************************************************************************/
-->

<!--
/*******************************************************************************
  15.3.3 op:intersect($parameter1 as node()*, $parameter2 as node()*) as node()*

  intersect is implemented by the HashSemiJoinIterator below
********************************************************************************/
-->

<!--
/*******************************************************************************
  15.3.4 op:except($parameter1 as node()*, $parameter2 as node()*) as node()*

  except is implemented by the HashSemiJoinIterator below
********************************************************************************/
-->

<zorba:iterator name="HashSemiJoinIterator"
                generateCodegen="false">

  <zorba:description author="Zorba Team">
  Hashing semi/anti join iterator.

  First producer goes in the result if a match in the second producer is
  found/not found. The order of the first producer is retained. No duplicate
  elimination is performed.
  </zorba:description>

  <zorba:state generateInit="false" generateReset="false"
               generateConstructor="false" generateDestructor="false">
    <zorba:member type="StructuredItemHandleHashSet*" name="theRightInput" brief=""/>
  </zorba:state>

  <zorba:constructor>
    <zorba:parameter type="bool" name="antijoin" defaultValue="false"/>
  </zorba:constructor>

  <zorba:member type="bool" name="theAntijoin" brief=""/>

</zorba:iterator>


<zorba:iterator name="SortSemiJoinIterator"
                generateCodegen="false">

  <zorba:description author="Zorba Team">
  Sortmerge based semijoin iterator.

  First producer goes in the result if a match in the second producer is found.
  Precondition: both inputs must be sorted.
  Postcondition: the order of the first producer is retained.

  If either of the inputs is guaranteed to contain no duplicates, then the
  output will be duplicate-free. Otherwise the output may contain duplicates.
  </zorba:description>
</zorba:iterator>

<!--
/*******************************************************************************
  15.4.1 fn:count($arg as item()*) as xs:integer
********************************************************************************/
-->
<zorba:iterator name="FnCountIterator">

    <zorba:description author="Zorba Team">fn:count</zorba:description>

  <zorba:function generateCodegen="false">
    <zorba:signature localname="count" prefix="fn">
      <zorba:param>item()*</zorba:param>
      <zorba:output>xs:integer</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:ignoresSortedNodes/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
  15.4.2 fn:avg($arg as xs:anyAtomicType*) as xs:anyAtomicType?
********************************************************************************/
-->
<zorba:iterator name="FnAvgIterator">

    <zorba:description author="Zorba Team">
      fn:avg
    </zorba:description>

  <zorba:function >
    <zorba:signature localname="avg" prefix="fn">
      <zorba:param>xs:anyAtomicType*</zorba:param>
      <zorba:output>xs:anyAtomicType?</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:ignoresSortedNodes/>
    </zorba:methods>
  </zorba:function>

</zorba:iterator>


<!--
/*******************************************************************************
  15.4.3 fn:max($arg as xs:anyAtomicType*) as xs:anyAtomicType?

         fn:max($arg as xs:anyAtomicType*,
                $collation as string) as xs:anyAtomicType?
********************************************************************************/
-->


<!--
/*******************************************************************************
  15.4.4 fn:min($arg as xs:anyAtomicType*) as xs:anyAtomicType?

         fn:min($arg as xs:anyAtomicType*,
                $collation as string) as xs:anyAtomicType?
********************************************************************************/
-->


<!--
/*******************************************************************************
  15.4.5 fn:sum($arg as xs:anyAtomicType*) as xs:anyAtomicType

         fn:sum($arg as xs:anyAtomicType*,
                $zero as xs:anyAtomicType?) as xs:anyAtomicType?
********************************************************************************/
-->
<zorba:iterator name="FnSumIterator">

  <zorba:description author="Zorba Team">
  Returns a value obtained by adding together the values in $arg. If $zero is
  not specified, then the value returned for an empty sequence is the xs:integer
  value 0. If $zero is specified, then the value returned for an empty sequence
  is $zero.
  </zorba:description>

  <zorba:function specializable="true">

    <zorba:signature localname="sum" prefix="fn">
      <zorba:param>xs:anyAtomicType*</zorba:param>
      <zorba:output>xs:anyAtomicType</zorba:output>
    </zorba:signature>

    <zorba:signature localname="sum" prefix="fn">
      <zorba:param>xs:anyAtomicType*</zorba:param>
      <zorba:param>xs:anyAtomicType?</zorba:param>
      <zorba:output>xs:anyAtomicType?</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:ignoresSortedNodes/>
    </zorba:methods>

  </zorba:function>

</zorba:iterator>


<zorba:iterator name="FnSumDoubleIterator">

    <zorba:description author="Zorba Team">
      fn:sum with arguments xs:double
    </zorba:description>

  <zorba:function>

    <zorba:signature localname="sum_double" prefix="op">
      <zorba:param>xs:double*</zorba:param>
      <zorba:output>xs:double</zorba:output>
    </zorba:signature>

    <zorba:signature localname="sum_double" prefix="op">
      <zorba:param>xs:double*</zorba:param>
      <zorba:param>xs:anyAtomicType?</zorba:param>
      <zorba:output>xs:anyAtomicType?</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:ignoresSortedNodes/>
    </zorba:methods>

  </zorba:function>

</zorba:iterator>


<zorba:iterator name="FnSumFloatIterator">

    <zorba:description author="Zorba Team">
      fn:sum with arguments xs:float
    </zorba:description>

  <zorba:function >

    <zorba:signature localname="sum_float" prefix="op">
      <zorba:param>xs:float*</zorba:param>
      <zorba:output>xs:float</zorba:output>
    </zorba:signature>

    <zorba:signature localname="sum_float" prefix="op">
      <zorba:param>xs:float*</zorba:param>
      <zorba:param>xs:anyAtomicType?</zorba:param>
      <zorba:output>xs:anyAtomicType?</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:ignoresSortedNodes/>
    </zorba:methods>

  </zorba:function>

</zorba:iterator>


<zorba:iterator name="FnSumDecimalIterator">

    <zorba:description author="Zorba Team">
      fn:sum with arguments xs:decimal
    </zorba:description>

  <zorba:function >

    <zorba:signature localname="sum_decimal" prefix="op">
      <zorba:param>xs:decimal*</zorba:param>
      <zorba:output>xs:decimal</zorba:output>
    </zorba:signature>

    <zorba:signature localname="sum_decimal" prefix="op">
      <zorba:param>xs:decimal*</zorba:param>
      <zorba:param>xs:anyAtomicType?</zorba:param>
      <zorba:output>xs:anyAtomicType?</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:ignoresSortedNodes/>
    </zorba:methods>

  </zorba:function>

</zorba:iterator>


<zorba:iterator name="FnSumIntegerIterator">

    <zorba:description author="Zorba Team">
      fn:sum with arguments xs:integer
    </zorba:description>

  <zorba:function >

    <zorba:signature localname="sum_integer" prefix="op">
      <zorba:param>xs:integer*</zorba:param>
      <zorba:output>xs:integer</zorba:output>
    </zorba:signature>

    <zorba:signature localname="sum_integer" prefix="op">
      <zorba:param>xs:integer*</zorba:param>
      <zorba:param>xs:anyAtomicType?</zorba:param>
      <zorba:output>xs:anyAtomicType?</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:ignoresSortedNodes/>
    </zorba:methods>

  </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
  15.5.1 op:to($firstval as xs:integer, $lastval as xs:integer) as xs:integer*
********************************************************************************/
-->
<zorba:iterator name="OpToIterator">

    <zorba:description author="Zorba Team">op:to</zorba:description>

  <zorba:function >
    <zorba:signature localname="to" prefix="op">
      <zorba:param>xs:integer?</zorba:param>
      <zorba:param>xs:integer?</zorba:param>
      <zorba:output>xs:integer*</zorba:output>
    </zorba:signature>
  </zorba:function>

  <zorba:state>
    <zorba:member type="xs_integer" name="theCurInt"
                  defaultValue="numeric_consts&lt;xs_integer&gt;::zero()" brief="the current integer"/>

     <zorba:member type="xs_integer" name="theFirstVal"
                   defaultValue="numeric_consts&lt;xs_integer&gt;::zero()" brief="first integer"/>

     <zorba:member type="xs_integer" name="theLastVal" defaultValue="numeric_consts&lt;xs_integer&gt;::zero()"
                   brief="last integer"/>
  </zorba:state>

</zorba:iterator>


<!--
/*******************************************************************************
  14.5.2 fn:id($arg as xs:string*) as element()*

         fn:id($arg as xs:string*, $node as node()) as element()*

********************************************************************************/
-->
<zorba:iterator name="FnIdIterator">

  <zorba:description author="Zorba Team">
  Returns the sequence of element nodes that are in the target document and have
  an ID value matching the value of one or more of the IDREF values supplied in
  $arg. The target document is the document containing $node, or the document
  containing the context item (.) if the second argument is omitted.
  </zorba:description>

  <zorba:function>

    <zorba:signature localname="id" prefix="fn">
      <zorba:param>xs:string*</zorba:param>
      <zorba:output>element()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="id" prefix="fn">
      <zorba:param>xs:string*</zorba:param>
      <zorba:param>node()</zorba:param>
      <zorba:output>element()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:producesDistinctNodes returnValue="YES"/>
      <zorba:producesSortedNodes returnValue="YES"/>
      <zorba:ignoresSortedNodes/>
      <zorba:ignoresDuplicateNodes/>
      <zorba:mustCopyInputNodes producer="1"/>
    </zorba:methods>

  </zorba:function>

  <zorba:state baseClassName="DescendantAxisState" generateInit="false" generateReset="false">
    <zorba:member type="bool" name="theIsInitialized"/>
    <zorba:member type="std::vector&lt;zstring&gt;" name="theIds"/>
    <zorba:member type="store::Item_t" name="theDocNode"/>
    <zorba:member type="rchandle&lt;store::AttributesIterator&gt;" name="theAttrsIte"/>
  </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
  14.5.3 fn:element-with-id($arg as xs:string*) as element()*

         fn:element-with-id($arg as xs:string*, $node as node()) as element()*

********************************************************************************/
-->
<zorba:iterator name="FnElementWithIdIterator">

  <zorba:description author="Zorba Team">
  The effect of this function is identical to fn:id in respect of elements that
  have an attribute with the is-id property. However, it behaves differently in
  respect of element nodes with the is-id property. Whereas the fn:id, for legacy
  reasons, returns the element that has the is-id property, this function returns
  the element identified by the ID, which is the parent of the element having the
  is-id property.
  </zorba:description>

  <zorba:function>

    <zorba:signature localname="element-with-id" prefix="fn">
      <zorba:param>xs:string*</zorba:param>
      <zorba:output>element()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="element-with-id" prefix="fn">
      <zorba:param>xs:string*</zorba:param>
      <zorba:param>node()</zorba:param>
      <zorba:output>element()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:producesDistinctNodes returnValue="YES"/>
      <zorba:producesSortedNodes returnValue="YES"/>
      <zorba:ignoresSortedNodes/>
      <zorba:ignoresDuplicateNodes/>
      <zorba:mustCopyInputNodes producer="1"/>
    </zorba:methods>

  </zorba:function>

  <zorba:state baseClassName="DescendantAxisState" generateInit="false" generateReset="false">
    <zorba:member type="bool" name="theIsInitialized"/>
    <zorba:member type="std::vector&lt;zstring&gt;" name="theIds"/>
    <zorba:member type="store::Item_t" name="theDocNode"/>
    <zorba:member type="rchandle&lt;store::AttributesIterator&gt;" name="theAttrsIte"/>
  </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
  14.5.4 fn:idref($arg as xs:string*) as node()*

         fn:idref($arg as xs:string*, $node as node()) as node()*
********************************************************************************/
-->
<zorba:iterator name="FnIdRefIterator">

  <zorba:description author="Zorba Team">fn:idref</zorba:description>

  <zorba:function>

    <zorba:signature localname="idref" prefix="fn">
      <zorba:param>xs:string*</zorba:param>
      <zorba:output>node()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="idref" prefix="fn">
      <zorba:param>xs:string*</zorba:param>
      <zorba:param>node()</zorba:param>
      <zorba:output>node()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:producesDistinctNodes returnValue="YES"/>
      <zorba:producesSortedNodes returnValue="YES"/>
      <zorba:ignoresSortedNodes/>
      <zorba:ignoresDuplicateNodes/>
      <zorba:mustCopyInputNodes producer="1"/>
    </zorba:methods>

  </zorba:function>

  <zorba:state baseClassName="DescendantAxisState" generateInit="false" generateReset="false">
    <zorba:member type="bool" name="theIsInitialized"/>
    <zorba:member type="std::vector&lt;zstring&gt;" name="theIds"/>
    <zorba:member type="store::Item_t" name="theDocNode"/>
    <zorba:member type="rchandle&lt;store::AttributesIterator&gt;" name="theAttrsIte"/>
  </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
  15.5.5 fn:doc($uri as xs:string?) as document-node()?
********************************************************************************/
-->
<zorba:iterator name="FnDocIterator">

    <zorba:description author="Zorba Team">fn:doc</zorba:description>

  <zorba:function>

    <zorba:signature localname="doc" prefix="fn">
      <zorba:param>xs:string?</zorba:param>
      <zorba:output>document-untyped?</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:isSource returnValue="true"/>
    </zorba:methods>

  </zorba:function>

</zorba:iterator>


<!--
/*******************************************************************************
  15.5.6 fn:doc-available($uri as xs:string?) as xs:boolean
********************************************************************************/
-->
<zorba:iterator name="FnDocAvailableIterator">

  <zorba:description author="Zorba Team">fn:doc-available</zorba:description>

  <zorba:function>
    <zorba:signature localname="doc-available" prefix="fn">
      <zorba:param>xs:string?</zorba:param>
      <zorba:output>xs:boolean</zorba:output>
    </zorba:signature>
  </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
  14.8.9 fn:available-environment-variables
********************************************************************************/
-->

<zorba:iterator name="FnAvailableEnvironmentVariablesIterator">
  <zorba:description author="Zorba Team">
    Summary: returns a list of environment variable names that are suitable for
    passing to fn:environment-variable, as a (possible empty) sequence of
    strings.

    The function returns a sequence of strings, being the names of the environment
    variables in the dynamic context in some implementation-defined order.
  </zorba:description>

  <zorba:function>
    <zorba:signature localname="available-environment-variables" prefix="fn" version="3.0">
      <zorba:output>xs:string*</zorba:output>
    </zorba:signature>
    
    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
    </zorba:methods>

  </zorba:function>

  <zorba:state generateInit="false" generateReset="false">
    <zorba:member type="store::Iterator_t" name="theIterator"
                  brief="the current iterator"/>
  </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
14.8.8 fn:environment-variable
********************************************************************************/
-->

<zorba:iterator name="FnEnvironmentVariableIterator">
  <zorba:description author="Zorba Team">
    Summary: Returns the value of a system environment variable, if it exists.

    If there is no environment variable with a matching name, the function returns
    the empty sequence.
  </zorba:description>

  <zorba:function>
    <zorba:signature localname="environment-variable" prefix="fn" version="3.0">
      <zorba:param>xs:string</zorba:param>
      <zorba:output>xs:string?</zorba:output>
    </zorba:signature>
    
    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
    </zorba:methods>
    
  </zorba:function>
  
</zorba:iterator>

<!--
/*******************************************************************************
14.8.5 fn:unparsed-text
********************************************************************************/
-->

<zorba:iterator name="FnUnparsedTextIterator">
  <zorba:description author="Zorba Team">
    Summary: The fn:unparsed-text function reads an external resource (for
    example, a file) and returns its contents as a string.
  </zorba:description>

  <zorba:function>

    <zorba:signature localname="unparsed-text" prefix="fn" version="3.0">
      <zorba:param>xs:string?</zorba:param>
      <zorba:output>xs:string?</zorba:output>
    </zorba:signature>

    <zorba:signature localname="unparsed-text" prefix="fn" version="3.0">
      <zorba:param>xs:string?</zorba:param>
      <zorba:param>xs:string</zorba:param>
      <zorba:output>xs:string?</zorba:output>
    </zorba:signature>
    
    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:isSource returnValue="true"/>
    </zorba:methods>
    
  </zorba:function>

 
</zorba:iterator>

<!--
/*******************************************************************************
14.8.5 fn:unparsed-text
********************************************************************************/
-->

<zorba:iterator name="FnUnparsedTextAvailableIterator">
  <zorba:description author="Zorba Team">
    Because errors in evaluating the fn:unparsed-text function are
    non-recoverable, these two functions are provided to allow an application
    to determine whether a call with particular arguments would succeed.
  </zorba:description>

  <zorba:function>

    <zorba:signature localname="unparsed-text-available" prefix="fn" version="3.0">
      <zorba:param>xs:string?</zorba:param>
      <zorba:output>xs:string?</zorba:output>
    </zorba:signature>

    <zorba:signature localname="unparsed-text-available" prefix="fn" version="3.0">
      <zorba:param>xs:string?</zorba:param>
      <zorba:param>xs:string</zorba:param>
      <zorba:output>xs:string?</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:isSource returnValue="true"/>
    </zorba:methods>

  </zorba:function>
 
</zorba:iterator>

<!--
/*******************************************************************************
14.8.6 fn:unparsed-text-lines
********************************************************************************/
-->

  <zorba:iterator name="FnUnparsedTextLinesIterator">
    <zorba:description author="Zorba Team">
      Reads an external resource and returns its contents as a sequence of strings,
      separated at newline boundaries.
    </zorba:description>

    <zorba:function>

      <zorba:signature localname="unparsed-text-lines" prefix="fn" version="3.0">
        <zorba:param>xs:string?</zorba:param>
        <zorba:output>xs:string*</zorba:output>
      </zorba:signature>

      <zorba:signature localname="unparsed-text-lines" prefix="fn" version="3.0">
        <zorba:param>xs:string?</zorba:param>
        <zorba:param>xs:string</zorba:param>
        <zorba:output>xs:string*</zorba:output>
      </zorba:signature>
      
      <zorba:methods>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:isSource returnValue="true"/>
      </zorba:methods>
      
    </zorba:function>

    
    <zorba:state generateInit="false" generateReset="false"
                 generateDestructor="false">
      <zorba:member type="std::unique_ptr&lt;std::istream, StreamReleaser&gt;*" name="theStream"
                    brief="the current stream"/>
      <zorba:member type=" internal::StreamResource*" name="theStreamResource"
                  brief="the current iterator"/>
    </zorba:state> 
    
  </zorba:iterator>

</zorba:iterators>
