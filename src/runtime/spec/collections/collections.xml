<?xml version="1.0" encoding="UTF-8"?>

<zorba:iterators
  xmlns:zorba="http://www.zorba-xquery.com"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.zorba-xquery.com ../runtime.xsd">

<zorba:source>
  <zorba:include form="Quoted">store/api/iterator.h</zorba:include>
</zorba:source>

<zorba:header>
  <zorba:fwd-decl ns="zorba">StaticallyKnownCollection</zorba:fwd-decl>
  <zorba:include form="Quoted">runtime/collections/collections_base.h</zorba:include>
</zorba:header>

<!--========================================================================-->

<zorba:iterator name="ZorbaCreateCollectionIterator">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="create"
                     prefix="zorba-store-static-collections-ddl">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="create"
                     prefix="zorba-store-static-collections-ddl">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="create"
                     prefix="zorba-store-dynamic-collections-ddl">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="create"
                     prefix="zorba-store-dynamic-collections-ddl">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:mustCopyInputNodes producer="1"/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" />
  </zorba:constructor>

  <zorba:method const="true"
                name="getCollection"
                return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>

  <zorba:member type="bool" name="theIsDynamic"/>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaDeleteCollectionIterator">
  <zorba:function generateCodegen="false">

    <zorba:signature localname="delete"
                     prefix="zorba-store-static-collections-ddl">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="delete"
                     prefix="zorba-store-dynamic-collections-ddl">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" />
  </zorba:constructor>

  <zorba:member type="bool" name="theIsDynamic"/>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="IsAvailableCollectionIterator">
  <zorba:function generateCodegen="false">

    <zorba:signature localname="is-available-collection" 
                     prefix="zorba-store-static-collections-ddl">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>xs:boolean</zorba:output>
    </zorba:signature>

    <zorba:signature localname="is-available-collection"
                     prefix="zorba-store-dynamic-collections-ddl">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>xs:boolean</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
    </zorba:methods>
  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic"/>
  </zorba:constructor>

  <zorba:member type="bool" name="theIsDynamic"/>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="AvailableCollectionsIterator">
  <zorba:function generateCodegen="false">

    <zorba:signature localname="available-collections" 
                     prefix="zorba-store-static-collections-ddl">
      <zorba:output>xs:QName*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="available-collections"
                     prefix="zorba-store-dynamic-collections-ddl">
      <zorba:output>xs:QName*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
    </zorba:methods>
  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic"/>
  </zorba:constructor>

  <zorba:member type="bool" name="theIsDynamic"/>

  <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
    <zorba:member type="store::Iterator_t" name="nameItState"/>
  </zorba:state>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="FnCollectionIterator">
  <zorba:function>

    <zorba:signature localname="collection" prefix="fn">
      <zorba:output>node()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="collection" prefix="fn">
      <zorba:param>xs:string?</zorba:param>
      <zorba:output>node()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:isSource returnValue="true"/>
    </zorba:methods>

  </zorba:function>

  <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
    <zorba:member type="store::Iterator_t" name="theIterator"/>
    <zorba:member type="bool" name="theIteratorOpened" defaultValue="false"/>
  </zorba:state>

  <zorba:method name="countImpl" const="true" return="bool">
      <zorba:param name="result" type="store::Item_t&amp;"/>
      <zorba:param name="planState" type="PlanState&amp;"/>
  </zorba:method>

  <zorba:method name="getCollection" const="true" return="store::Collection_t">
      <zorba:param name="planState" type="PlanState&amp;"/>
  </zorba:method>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaCollectionIterator">
  <zorba:function generateCodegen="false">

    <zorba:signature localname="collection"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="collection"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>xs:integer</zorba:param><!-- nodes to skip -->
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="collection"
                      prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>xs:anyURI</zorba:param><!-- start ref -->
      <zorba:param>xs:integer</zorba:param><!-- nodes to skip -->
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="collection"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="collection"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>xs:integer</zorba:param><!-- start to skip -->
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="collection"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>xs:anyURI</zorba:param><!-- node ref-->
      <zorba:param>xs:integer</zorba:param><!-- nodes to skip -->
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:getReturnType/>
      <zorba:isSource returnValue="true"/>
      <zorba:producesDistinctNodes returnValue="YES"/>
      <zorba:producesSortedNodes returnValue="YES"/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic"/>
  </zorba:constructor>

  <zorba:member type="bool" name="theIsDynamic" getterName="isDynamic"/>

  <zorba:method const="true" name="isCountOptimizable" return="bool" />
  
  <zorba:method name="countImpl" const="true" return="bool">
      <zorba:param name="result" type="store::Item_t&amp;"/>
      <zorba:param name="planState" type="PlanState&amp;"/>
  </zorba:method>
  
  <zorba:method name="skipImpl" const="true" return="bool">
    <zorba:param name="count" type="int64_t"/>
    <zorba:param name="planState" type="PlanState&amp;"/>
  </zorba:method>
  
  <zorba:method name="initCollection" const="true" return="void">
    <zorba:param name="planState" type="PlanState&amp;"/>
    <zorba:param name="skipCount" type="int64_t"/>
  </zorba:method>

  <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
    <zorba:member type="store::Iterator_t" name="theIterator"/>
    <zorba:member type="bool" name="theIteratorOpened" defaultValue="false"/>
  </zorba:state>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaCollectionNameIterator">
  <zorba:function>

    <zorba:signature localname="collection-name"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>structured-item()</zorba:param>
      <zorba:output>xs:QName</zorba:output>
    </zorba:signature>

    <zorba:signature localname="collection-name"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>structured-item()</zorba:param>
      <zorba:output>xs:QName</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaIndexOfIterator">
  <zorba:function generateCodegen="false">

    <zorba:signature localname="index-of"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>structured-item()</zorba:param>
      <zorba:output>xs:integer</zorba:output>
    </zorba:signature>

    <zorba:signature localname="index-of"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>structured-item()</zorba:param>
      <zorba:output>xs:integer</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic"/>
  </zorba:constructor>

  <zorba:member type="bool" name="theIsDynamic"/>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaApplyInsertIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaApplyInsertIterator, ZorbaApplyInsertIteratorState>"
  generateVisitor="false">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="apply-insert"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="APPLYING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:propagatesInputNodes/>
      <zorba:mustCopyInputNodes producer="1"/>
      <zorba:processPragma/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" base="true"/>
    <zorba:parameter type="bool" name="needToCopy" base="true"/>
  </zorba:constructor>

  <zorba:method const="true" name="getCollection"
                return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>

  <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
    <zorba:member type="std::vector&lt;store::Item_t>" name="nodes"
                  brief="the nodes that have been inserted"/>
    <zorba:member type="std::vector&lt;store::Item_t>::const_iterator" name="iterator"
        brief="iterator over the nodes"/>
  </zorba:state>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaInsertAfterIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaInsertAfterIterator, PlanIteratorState>"
  generateVisitor="false">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="insert-after"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="insert-after"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:mustCopyInputNodes producer="2"/>
      <zorba:processPragma/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" base="true"/>
    <zorba:parameter type="bool" name="needToCopy" base="true"/>
  </zorba:constructor>

  <zorba:member type="bool" name="theIsDynamic"/>

  <zorba:method const="true" name="getCollection" 
                return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaInsertBeforeIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaInsertBeforeIterator, PlanIteratorState>"
generateVisitor="false">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="insert-before"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="insert-before"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:mustCopyInputNodes producer="2"/>
      <zorba:processPragma/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" base="true"/>
    <zorba:parameter type="bool" name="needToCopy" base="true"/>
  </zorba:constructor>

  <zorba:method const="true" name="getCollection" 
                return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaInsertFirstIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaInsertFirstIterator,PlanIteratorState>"
  generateVisitor="false">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="insert-first"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="insert-first"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:mustCopyInputNodes producer="1"/>
      <zorba:processPragma/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" base="true"/>
    <zorba:parameter type="bool" name="needToCopy" base="true"/>
  </zorba:constructor>

  <zorba:method const="true" name="getCollection" 
                return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaInsertLastIterator"
base="ZorbaCollectionIteratorHelper&lt;ZorbaInsertLastIterator, PlanIteratorState>"
generateVisitor="false">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="insert-last"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="insert-last"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:mustCopyInputNodes producer="1"/>
      <zorba:processPragma/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" base="true"/>
    <zorba:parameter type="bool" name="needToCopy" base="true"/>
  </zorba:constructor>

  <zorba:method const="true" name="getCollection" 
                return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaApplyInsertFirstIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaApplyInsertFirstIterator, ZorbaApplyInsertFirstIteratorState>"
  generateVisitor="false">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="apply-insert-first"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="apply-insert-first"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="APPLYING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:propagatesInputNodes/>
      <zorba:mustCopyInputNodes producer="1"/>
      <zorba:processPragma/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" base="true"/>
    <zorba:parameter type="bool" name="needToCopy" base="true"/>
  </zorba:constructor>

  <zorba:method const="true" name="getCollection" 
                return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>

  <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
    <zorba:member type="std::vector&lt;store::Item_t>" name="nodes"
                  brief="the nodes that have been inserted"/>
    <zorba:member type="std::vector&lt;store::Item_t>::const_iterator" name="iterator"
        brief="iterator over the nodes"/>
  </zorba:state>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaApplyInsertLastIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaApplyInsertLastIterator, ZorbaApplyInsertLastIteratorState>"
  generateVisitor="false">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="apply-insert-last"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="apply-insert-last"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="APPLYING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:propagatesInputNodes/>
      <zorba:mustCopyInputNodes producer="1"/>
      <zorba:processPragma/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" base="true"/>
    <zorba:parameter type="bool" name="needToCopy" base="true"/>
  </zorba:constructor>

  <zorba:method const="true" name="getCollection" 
                return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>

  <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
    <zorba:member type="std::vector&lt;store::Item_t>" name="nodes"
                  brief="the nodes that have been inserted"/>
    <zorba:member type="std::vector&lt;store::Item_t>::const_iterator" name="iterator"
        brief="iterator over the nodes"/>
  </zorba:state>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaApplyInsertBeforeIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaApplyInsertBeforeIterator, ZorbaApplyInsertBeforeIteratorState>"
  generateVisitor="false">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="apply-insert-before"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="apply-insert-before"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="APPLYING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:propagatesInputNodes/>
      <zorba:mustCopyInputNodes producer="2"/>
      <zorba:processPragma/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" base="true"/>
    <zorba:parameter type="bool" name="needToCopy" base="true"/>
  </zorba:constructor>

  <zorba:method const="true" name="getCollection" 
                return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>

  <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
    <zorba:member type="std::vector&lt;store::Item_t>" name="nodes"
                  brief="the nodes that have been inserted"/>
    <zorba:member type="std::vector&lt;store::Item_t>::const_iterator" name="iterator"
        brief="iterator over the nodes"/>
  </zorba:state>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaApplyInsertAfterIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaApplyInsertAfterIterator, ZorbaApplyInsertAfterIteratorState>"
  generateVisitor="false">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="apply-insert-after"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="apply-insert-after"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>structured-item()*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="APPLYING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:propagatesInputNodes/>
      <zorba:mustCopyInputNodes producer="2"/>
      <zorba:processPragma/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" base="true"/>
    <zorba:parameter type="bool" name="needToCopy" base="true"/>
  </zorba:constructor>

  <zorba:method const="true" name="getCollection" 
                return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>

  <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
    <zorba:member type="std::vector&lt;store::Item_t>" name="nodes"
                  brief="the nodes that have been inserted"/>
    <zorba:member type="std::vector&lt;store::Item_t>::const_iterator" name="iterator"
        brief="iterator over the nodes"/>
  </zorba:state>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaDeleteIterator">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="delete"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="delete"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:ignoresSortedNodes/>
      <zorba:ignoresDuplicateNodes/>
      <zorba:mustCopyInputNodes producer="0"/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic"/>
  </zorba:constructor>

  <zorba:member type="bool" name="theIsDynamic"/>

  <zorba:method const="true" name="getCollection" return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaDeleteFirstIterator">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="delete-first"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="delete-first"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>xs:integer</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="delete-first"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="delete-first"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>xs:integer</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic"/>
  </zorba:constructor>

  <zorba:member type="bool" name="theIsDynamic"/>

  <zorba:method const="true" name="getCollection" return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaDeleteLastIterator">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="delete-last"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="delete-last"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>xs:integer</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="delete-last"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="delete-last"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>xs:integer</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:mustCopyInputNodes value="false"/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic"/>
  </zorba:constructor>

  <zorba:member type="bool" name="theIsDynamic"/>

  <zorba:method const="true" 
                name="getCollection" 
                return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaEditIterator">
  
  <zorba:function generateCodegen="false">
    
    <zorba:signature localname="edit"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>structured-item()</zorba:param>
      <zorba:param>structured-item()</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>
    
    <zorba:signature localname="edit"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>structured-item()</zorba:param>
      <zorba:param>structured-item()</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>
    
    <zorba:methods>
      <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:mustCopyInputNodes producer="1"/>
      <zorba:processPragma/>
    </zorba:methods>
    
  </zorba:function>
  
  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" base="true"/>
    <zorba:parameter type="bool" name="needToCopy" base="true"/>
  </zorba:constructor>
  
  <zorba:member type="bool" name="theIsDynamic"/>
  <zorba:member type="bool" name="theNeedToCopy"/>
  
  <zorba:method
      const="true" 
      name="getCollection" 
      return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaInsertIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaInsertIterator, PlanIteratorState>"
  generateVisitor="false">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="insert"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:param>structured-item()*</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
      <zorba:mustCopyInputNodes producer="1"/>
      <zorba:processPragma/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" base="true"/>
    <zorba:parameter type="bool" name="needToCopy" base="true"/>
  </zorba:constructor>

  <zorba:method const="true" name="getCollection"
                return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>

</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ZorbaTruncateCollectionIterator">

  <zorba:function generateCodegen="false">

    <zorba:signature localname="truncate"
                     prefix="zorba-store-static-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:signature localname="truncate"
                     prefix="zorba-store-dynamic-collections-dml">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>empty-sequence()</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
      <zorba:accessesDynCtx returnValue="true"/>
    </zorba:methods>

  </zorba:function>

  <zorba:constructor>
    <zorba:parameter type="bool" name="isDynamic" />
  </zorba:constructor>

  <zorba:member type="bool" name="theIsDynamic"/>

  <zorba:method const="true" 
                name="getCollection" 
                return="const StaticallyKnownCollection*">
    <zorba:param type="const store::Item_t&amp;" name="name"/>
    <zorba:param type="store::Collection_t&amp;" name="coll"/>
  </zorba:method>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="IsAvailableIndexIterator">
  <zorba:function>
    <zorba:signature localname="is-available-index"
                     prefix="zorba-store-indexes-static-ddl">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>xs:boolean</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
    </zorba:methods>

  </zorba:function>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="AvailableIndexesIterator">
  <zorba:function>
    <zorba:signature localname="available-indexes"
                     prefix="zorba-store-indexes-static-ddl">
      <zorba:output>xs:QName*</zorba:output>
    </zorba:signature>

    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
    </zorba:methods>
  </zorba:function>

  <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
    <zorba:member type="store::Iterator_t" name="nameItState"
                  brief="the current iterator"/>
  </zorba:state>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="IsActivatedICIterator">
  <zorba:function>
    <zorba:signature localname="is-activated-integrity-constraint"
                     prefix="zorba-store-static-integrity-constraints-ddl">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>xs:boolean</zorba:output>
    </zorba:signature>
    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
    </zorba:methods>
  </zorba:function>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="ActivatedICsIterator">
  <zorba:function>
    <zorba:signature localname="activated-integrity-constraints"
                     prefix="zorba-store-static-integrity-constraints-ddl">
      <zorba:output>xs:QName*</zorba:output>
    </zorba:signature>
    <zorba:methods>
      <zorba:accessesDynCtx returnValue="true"/>
    </zorba:methods>
  </zorba:function>

  <zorba:state generateInit="false"
               generateReset="false"
               generateDestructor="false">
    <zorba:member type="store::Iterator_t" name="nameItState"/>
  </zorba:state>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="IsDeclaredCollectionIterator">
  <zorba:function>
    <zorba:signature localname="is-declared-collection"
                     prefix="zorba-store-static-collections-ddl">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>xs:boolean</zorba:output>
    </zorba:signature>
  </zorba:function>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="DeclaredCollectionsIterator">
  <zorba:function>
    <zorba:signature localname="declared-collections"
                     prefix="zorba-store-static-collections-ddl">
      <zorba:output>xs:QName*</zorba:output>
    </zorba:signature>
  </zorba:function>
  <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
    <zorba:member type="store::Iterator_t" name="nameItState"/>
  </zorba:state>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="IsDeclaredIndexIterator">
  <zorba:function>
    <zorba:signature localname="is-declared-index"
                     prefix="zorba-store-indexes-static-ddl">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>xs:boolean</zorba:output>
    </zorba:signature>
  </zorba:function>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="DeclaredIndexesIterator">
  <zorba:function>
    <zorba:signature localname="declared-indexes"
                     prefix="zorba-store-indexes-static-ddl">
      <zorba:output>xs:QName*</zorba:output>
    </zorba:signature>
  </zorba:function>
  <zorba:state generateReset="false" generateDestructor="false">
    <zorba:member type="store::Iterator_t" name="nameItState" defaultValue="NULL"/>
  </zorba:state>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="IsDeclaredICIterator">
  <zorba:function>
    <zorba:signature localname="is-declared-integrity-constraint"
                     prefix="zorba-store-static-integrity-constraints-ddl">
      <zorba:param>xs:QName</zorba:param>
      <zorba:output>xs:boolean</zorba:output>
    </zorba:signature>
  </zorba:function>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="DeclaredICsIterator">
  <zorba:function>
    <zorba:signature localname="declared-integrity-constraints"
                     prefix="zorba-store-static-integrity-constraints-ddl">
      <zorba:output>xs:QName*</zorba:output>
    </zorba:signature>
  </zorba:function>

  <zorba:state generateReset="false" generateDestructor="false">
    <zorba:member type="store::Iterator_t" name="nameItState" defaultValue="NULL"/>
  </zorba:state>
</zorba:iterator>

<!--========================================================================-->

<zorba:iterator name="FnURICollectionIterator">
  <zorba:function>

    <zorba:signature localname="uri-collection" prefix="fn" version="3.0">
      <zorba:output>xs:anyURI*</zorba:output>
    </zorba:signature>

    <zorba:signature localname="uri-collection" prefix="fn" version="3.0">
      <zorba:param>xs:string?</zorba:param>
      <zorba:output>xs:anyURI*</zorba:output>
    </zorba:signature>
    
  </zorba:function>

  <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
    <zorba:member type="store::Iterator_t" name="theIterator"/>
    <zorba:member type="bool" name="theIteratorOpened" defaultValue="false"/>
  </zorba:state>
  
</zorba:iterator>

<!--========================================================================-->

</zorba:iterators>
<!-- vim:set et sw=2 ts=2: -->
