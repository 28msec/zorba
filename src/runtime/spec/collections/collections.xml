<?xml version="1.0" encoding="UTF-8"?>

<!--
/////////////////////////////////////////////////////////////////////////////////
//                                                                             //
//                                                                             //
/////////////////////////////////////////////////////////////////////////////////
-->
<zorba:iterators
  xmlns:zorba="http://www.zorba-xquery.com"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.zorba-xquery.com ../runtime.xsd">

<zorba:source>
    <zorba:include  form="Quoted">store/api/iterator.h</zorba:include>
</zorba:source>

<zorba:header>
    <zorba:fwd-decl ns="zorba">StaticallyKnownCollection</zorba:fwd-decl>
    <zorba:include form="Quoted">runtime/collections/collections_base.h</zorba:include>
</zorba:header>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="FnCollectionIterator">

    <zorba:description author="Zorba Team">
      fn:collection
    </zorba:description>

    <zorba:function>

      <zorba:signature localname="collection" prefix="fn">
        <zorba:output>node()*</zorba:output>
      </zorba:signature>

      <zorba:signature localname="collection" prefix="fn">
        <zorba:param>xs:string</zorba:param>
        <zorba:output>node()*</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:isSource returnValue="true"/>
      </zorba:methods>

    </zorba:function>

    <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
      <zorba:member type="store::Iterator_t" name="theIterator"
                    brief="the current iterator"/>
      <zorba:member type="bool" name="theIteratorOpened" defaultValue="false"
                    brief="flag indicating whether theIterator was opened"/>
    </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaCollectionIterator">

    <zorba:description author="Zorba Team">
      zorba:collection
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="collection" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>node()*</zorba:output>
      </zorba:signature>

      <zorba:signature localname="collection" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>node()*</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:isSource returnValue="true"/>
        <zorba:producesDistinctNodes returnValue="YES"/>
        <zorba:producesSortedNodes returnValue="YES"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" />
    </zorba:constructor>

    <zorba:method const="true" name="getCollection"
      return="const StaticallyKnownCollection*">
      <zorba:param type="const static_context*" name="sctx"/>
      <zorba:param type="const store::Item_t&amp;" name="name"/>
      <zorba:param type="const QueryLoc&amp;" name="loc"/>
      <zorba:param type="bool" name="dyn_coll"/>
      <zorba:param type="store::Collection_t&amp;" name="coll"/>
    </zorba:method>

    <zorba:member type="bool" name="theDynamicCollection"
      getterName="isDynamic"
      brief="whether it's the function of the dynamic or the static collection module"/>

    <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
      <zorba:member type="store::Iterator_t" name="theIterator"
                    brief="the current iterator"/>
      <zorba:member type="bool" name="theIteratorOpened" defaultValue="false"
                    brief="flag indicating whether theIterator was opened"/>
    </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaIndexOfIterator" >

    <zorba:description author="Zorba Team">
      zorba:index-of
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="index-of" prefix="zorba-store-collections-static-dml">
        <zorba:param>node()</zorba:param>
        <zorba:output>xs:integer</zorba:output>
      </zorba:signature>

      <zorba:signature localname="index-of" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>node()</zorba:param>
        <zorba:output>xs:integer</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:mustCopyInputNodes value="false"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" />
    </zorba:constructor>

    <zorba:method const="true" name="getCollection"
      return="const StaticallyKnownCollection*">
      <zorba:param type="const static_context*" name="sctx"/>
      <zorba:param type="const store::Item_t&amp;" name="name"/>
      <zorba:param type="const QueryLoc&amp;" name="loc"/>
      <zorba:param type="bool" name="dyn_coll"/>
      <zorba:param type="store::Collection_t&amp;" name="coll"/>
    </zorba:method>

    <zorba:member type="bool" name="theDynamicCollection"
      brief="whether it's the function of the dynamic or the static collection module"/>

</zorba:iterator>


<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaCreateCollectionIterator" >

    <zorba:description author="Zorba Team">
      zorba:create
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="create" prefix="zorba-store-collections-static-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="create" prefix="zorba-store-collections-static-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="create" prefix="zorba-store-dynamic-collections-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="create" prefix="zorba-store-dynamic-collections-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:mustCopyInputNodes producer="1"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" />
    </zorba:constructor>

    <zorba:method const="true" name="getCollection"
      return="const StaticallyKnownCollection*">
      <zorba:param type="const static_context*" name="sctx"/>
      <zorba:param type="const store::Item_t&amp;" name="name"/>
      <zorba:param type="const QueryLoc&amp;" name="loc"/>
      <zorba:param type="bool" name="dyn_coll"/>
      <zorba:param type="store::Collection_t&amp;" name="coll"/>
    </zorba:method>

    <zorba:member type="bool" name="theDynamicCollection"
      brief="whether it's the function of the dynamic or the static collection module"/>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaDeleteCollectionIterator" >

    <zorba:description author="Zorba Team">
      zorba:delete
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="delete" prefix="zorba-store-collections-static-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="delete" prefix="zorba-store-dynamic-collections-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>


      <zorba:methods>
        <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
       <zorba:mustCopyInputNodes value="false"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" />
    </zorba:constructor>

    <zorba:method const="true" name="getCollection"
      return="const StaticallyKnownCollection*">
      <zorba:param type="const static_context*" name="sctx"/>
      <zorba:param type="const store::Item_t&amp;" name="name"/>
      <zorba:param type="const QueryLoc&amp;" name="loc"/>
      <zorba:param type="bool" name="dyn_coll"/>
      <zorba:param type="store::Collection_t&amp;" name="coll"/>
    </zorba:method>

    <zorba:member type="bool" name="theDynamicCollection"
      brief="whether it's the function of the dynamic or the static collection module"/>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaInsertNodesIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaInsertNodesIterator, PlanIteratorState>">

    <zorba:description author="Zorba Team">
      zorba:insert-nodes
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="insert-nodes" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <!-- not available because dynamic collections are always ordered
      <zorba:signature localname="insert-nodes" prefix="zorba-store-collections">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>
      -->

      <zorba:methods>
        <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:mustCopyInputNodes producer="1"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" base="true"/>
    </zorba:constructor>

    <zorba:method const="true" name="getCollection" return="const StaticallyKnownCollection*">
      <zorba:param type="const static_context*" name="sctx"/>
      <zorba:param type="const store::Item_t&amp;" name="name"/>
      <zorba:param type="const QueryLoc&amp;" name="loc"/>
      <zorba:param type="bool" name="dyn_coll"/>
      <zorba:param type="store::Collection_t&amp;" name="coll"/>
    </zorba:method>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaInsertNodesFirstIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaInsertNodesFirstIterator, PlanIteratorState>">

    <zorba:description author="Zorba Team">
      zorba:insert-nodes-first
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="insert-nodes-first" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="insert-nodes-first" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>


      <zorba:methods>
        <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:mustCopyInputNodes producer="1"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" base="true"/>
    </zorba:constructor>

    <zorba:method const="true" name="getCollection" return="const StaticallyKnownCollection*">
      <zorba:param type="const static_context*" name="sctx"/>
      <zorba:param type="const store::Item_t&amp;" name="name"/>
      <zorba:param type="const QueryLoc&amp;" name="loc"/>
      <zorba:param type="bool" name="dyn_coll"/>
      <zorba:param type="store::Collection_t&amp;" name="coll"/>
    </zorba:method>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaInsertNodesLastIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaInsertNodesLastIterator, PlanIteratorState>">

    <zorba:description author="Zorba Team">
      zorba:insert-nodes-last
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="insert-nodes-last" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="insert-nodes-last" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:mustCopyInputNodes producer="1"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" base="true"/>
    </zorba:constructor>

    <zorba:method const="true" name="getCollection" return="const StaticallyKnownCollection*">
      <zorba:param type="const static_context*" name="sctx"/>
      <zorba:param type="const store::Item_t&amp;" name="name"/>
      <zorba:param type="const QueryLoc&amp;" name="loc"/>
      <zorba:param type="bool" name="dyn_coll"/>
      <zorba:param type="store::Collection_t&amp;" name="coll"/>
    </zorba:method>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaInsertNodesBeforeIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaInsertNodesBeforeIterator, PlanIteratorState>">

    <zorba:description author="Zorba Team">
      zorba:insert-nodes-before
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="insert-nodes-before" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="insert-nodes-before" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:mustCopyInputNodes producer="2"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" base="true"/>
    </zorba:constructor>

    <zorba:method const="true" name="getCollection" return="const StaticallyKnownCollection*">
      <zorba:param type="const static_context*" name="sctx"/>
      <zorba:param type="const store::Item_t&amp;" name="name"/>
      <zorba:param type="const QueryLoc&amp;" name="loc"/>
      <zorba:param type="bool" name="dyn_coll"/>
      <zorba:param type="store::Collection_t&amp;" name="coll"/>
    </zorba:method>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaInsertNodesAfterIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaInsertNodesAfterIterator, PlanIteratorState>">

    <zorba:description author="Zorba Team">
      zorba:insert-nodes-after
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="insert-nodes-after" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="insert-nodes-after" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:mustCopyInputNodes producer="2"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" base="true"/>
    </zorba:constructor>

    <zorba:member type="bool" name="theDynamicCollection"
      brief="whether it's the function of the dynamic or the static collection module"/>

    <zorba:method const="true" name="getCollection" return="const StaticallyKnownCollection*">
      <zorba:param type="const static_context*" name="sctx"/>
      <zorba:param type="const store::Item_t&amp;" name="name"/>
      <zorba:param type="const QueryLoc&amp;" name="loc"/>
      <zorba:param type="bool" name="dyn_coll"/>
      <zorba:param type="store::Collection_t&amp;" name="coll"/>
    </zorba:method>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaApplyInsertNodesIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaApplyInsertNodesIterator, ZorbaApplyInsertNodesIteratorState>">

    <zorba:description author="Zorba Team">
      zorba:apply-insert-nodes
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="apply-insert-nodes" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>node()*</zorba:output>
      </zorba:signature>

      <!-- not available because dynamic collections are always ordered
      <zorba:signature localname="apply-insert-nodes" prefix="zorba-store-collections">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>node()*</zorba:output>
      </zorba:signature>
      -->

      <zorba:methods>
        <zorba:getScriptingKind returnValue="APPLYING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:propagatesInputNodes/>
        <zorba:mustCopyInputNodes producer="1"/>
      </zorba:methods>
    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" base="true"/>
    </zorba:constructor>

    <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
      <zorba:member type="std::vector&lt;store::Item_t>" name="nodes"
                    brief="the nodes that have been inserted"/>
      <zorba:member type="std::vector&lt;store::Item_t>::const_iterator" name="iterator"
          brief="iterator over the nodes"/>
    </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaApplyInsertNodesFirstIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaApplyInsertNodesFirstIterator, ZorbaApplyInsertNodesFirstIteratorState>">

    <zorba:description author="Zorba Team">
      zorba:apply-insertnodes-first
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="apply-insert-nodes-first" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>node()*</zorba:output>
      </zorba:signature>

      <zorba:signature localname="apply-insert-nodes-first" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>node()*</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:getScriptingKind returnValue="APPLYING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:propagatesInputNodes/>
        <zorba:mustCopyInputNodes producer="1"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" base="true"/>
    </zorba:constructor>

    <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
      <zorba:member type="std::vector&lt;store::Item_t>" name="nodes"
                    brief="the nodes that have been inserted"/>
      <zorba:member type="std::vector&lt;store::Item_t>::const_iterator" name="iterator"
          brief="iterator over the nodes"/>
    </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaApplyInsertNodesLastIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaApplyInsertNodesLastIterator, ZorbaApplyInsertNodesLastIteratorState>">

    <zorba:description author="Zorba Team">
      zorba:apply-insertnodes-last
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="apply-insert-nodes-last" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>node()*</zorba:output>
      </zorba:signature>

      <zorba:signature localname="apply-insert-nodes-last" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>node()*</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:getScriptingKind returnValue="APPLYING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:propagatesInputNodes/>
        <zorba:mustCopyInputNodes producer="1"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" base="true"/>
    </zorba:constructor>

    <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
      <zorba:member type="std::vector&lt;store::Item_t>" name="nodes"
                    brief="the nodes that have been inserted"/>
      <zorba:member type="std::vector&lt;store::Item_t>::const_iterator" name="iterator"
          brief="iterator over the nodes"/>
    </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaApplyInsertNodesBeforeIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaApplyInsertNodesBeforeIterator, ZorbaApplyInsertNodesBeforeIteratorState>">

    <zorba:description author="Zorba Team">
      zorba:apply-insert-nodes-before
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="apply-insert-nodes-before" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>node()*</zorba:output>
      </zorba:signature>

      <zorba:signature localname="apply-insert-nodes-before" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>node()*</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:getScriptingKind returnValue="APPLYING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:propagatesInputNodes/>
        <zorba:mustCopyInputNodes producer="2"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" base="true"/>
    </zorba:constructor>

    <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
      <zorba:member type="std::vector&lt;store::Item_t>" name="nodes"
                    brief="the nodes that have been inserted"/>
      <zorba:member type="std::vector&lt;store::Item_t>::const_iterator" name="iterator"
          brief="iterator over the nodes"/>
    </zorba:state>
</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaApplyInsertNodesAfterIterator"
  base="ZorbaCollectionIteratorHelper&lt;ZorbaApplyInsertNodesAfterIterator, ZorbaApplyInsertNodesAfterIteratorState>">

    <zorba:description author="Zorba Team">
      zorba:apply-insertnodes-after
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="apply-insert-nodes-after" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>node()*</zorba:output>
      </zorba:signature>

      <zorba:signature localname="apply-insert-nodes-after" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>node()</zorba:param>
        <zorba:param>node()*</zorba:param>
        <zorba:output>node()*</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:getScriptingKind returnValue="APPLYING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:propagatesInputNodes/>
        <zorba:mustCopyInputNodes producer="2"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" base="true"/>
    </zorba:constructor>

    <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
      <zorba:member type="std::vector&lt;store::Item_t>" name="nodes"
                    brief="the nodes that have been inserted"/>
      <zorba:member type="std::vector&lt;store::Item_t>::const_iterator" name="iterator"
          brief="iterator over the nodes"/>
    </zorba:state>

</zorba:iterator>


<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaDeleteNodesIterator" >

    <zorba:description author="Zorba Team">
      zorba:delete-nodes
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="delete-nodes" prefix="zorba-store-collections-static-dml">
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="delete-nodes" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>node()*</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:ignoresSortedNodes/>
        <zorba:ignoresDuplicateNodes/>
        <zorba:mustCopyInputNodes producer="0"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" />
    </zorba:constructor>

    <zorba:member type="bool" name="theDynamicCollection"
      brief="whether it's the function of the dynamic or the static collection module"/>

    <zorba:method const="true" name="getCollection" return="const StaticallyKnownCollection*">
      <zorba:param type="const static_context*" name="sctx"/>
      <zorba:param type="const store::Item_t&amp;" name="name"/>
      <zorba:param type="const QueryLoc&amp;" name="loc"/>
      <zorba:param type="bool" name="dyn_coll"/>
      <zorba:param type="store::Collection_t&amp;" name="coll"/>
    </zorba:method>
</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaDeleteNodesFirstIterator" >

    <zorba:description author="Zorba Team">
      zorba:delete-node-first
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="delete-node-first" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="delete-nodes-first" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>xs:integer</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="delete-node-first" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="delete-nodes-first" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>xs:integer</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:mustCopyInputNodes value="false"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" />
    </zorba:constructor>

    <zorba:member type="bool" name="theDynamicCollection"
      brief="whether it's the function of the dynamic or the static collection module"/>

    <zorba:method const="true" name="getCollection" return="const StaticallyKnownCollection*">
      <zorba:param type="const static_context*" name="sctx"/>
      <zorba:param type="const store::Item_t&amp;" name="name"/>
      <zorba:param type="const QueryLoc&amp;" name="loc"/>
      <zorba:param type="bool" name="dyn_coll"/>
      <zorba:param type="store::Collection_t&amp;" name="coll"/>
    </zorba:method>
</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaDeleteNodesLastIterator" >

    <zorba:description author="Zorba Team">
      zorba:delete-node-last
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="delete-node-last" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="delete-nodes-last" prefix="zorba-store-collections-static-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>xs:integer</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="delete-node-last" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:signature localname="delete-nodes-last" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>xs:QName</zorba:param>
        <zorba:param>xs:integer</zorba:param>
        <zorba:output>empty-sequence()</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:getScriptingKind returnValue="UPDATING_EXPR"/>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:mustCopyInputNodes value="false"/>
      </zorba:methods>

    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" />
    </zorba:constructor>

    <zorba:member type="bool" name="theDynamicCollection"
      brief="whether it's the function of the dynamic or the static collection module"/>

    <zorba:method const="true" name="getCollection" return="const StaticallyKnownCollection*">
      <zorba:param type="const static_context*" name="sctx"/>
      <zorba:param type="const store::Item_t&amp;" name="name"/>
      <zorba:param type="const QueryLoc&amp;" name="loc"/>
      <zorba:param type="bool" name="dyn_coll"/>
      <zorba:param type="store::Collection_t&amp;" name="coll"/>
    </zorba:method>
</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="ZorbaCollectionNameIterator" >

    <zorba:description author="Zorba Team">
      zorba:collection-name
    </zorba:description>

    <zorba:function>

      <zorba:signature localname="collection-name" prefix="zorba-store-collections-static-dml">
        <zorba:param>node()</zorba:param>
        <zorba:output>xs:QName</zorba:output>
      </zorba:signature>

      <zorba:signature localname="collection-name" prefix="zorba-store-dynamic-collections-dml">
        <zorba:param>node()</zorba:param>
        <zorba:output>xs:QName</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:accessesDynCtx returnValue="true"/>
        <zorba:mustCopyInputNodes value="true"/>
      </zorba:methods>

    </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="IsAvailableCollectionIterator">

    <zorba:description author="Zorba Team">
      dc:is-available-collection
    </zorba:description>

    <zorba:function generateCodegen="false">
      <zorba:signature localname="is-available-collection"
                       prefix="zorba-store-collections-static-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>xs:boolean</zorba:output>
      </zorba:signature>

      <zorba:signature localname="is-available-collection"
                       prefix="zorba-store-dynamic-collections-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>xs:boolean</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:accessesDynCtx returnValue="true"/>
      </zorba:methods>
    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" />
    </zorba:constructor>

    <zorba:method const="true" name="getCollection" return="const StaticallyKnownCollection*">
      <zorba:param type="const static_context*" name="sctx"/>
      <zorba:param type="const store::Item_t&amp;" name="name"/>
      <zorba:param type="const QueryLoc&amp;" name="loc"/>
      <zorba:param type="bool" name="dyn_coll"/>
      <zorba:param type="store::Collection_t&amp;" name="coll"/>
    </zorba:method>

    <zorba:member type="bool" name="theDynamicCollection"
      brief="whether it's the function of the dynamic or the static collection module"/>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="AvailableCollectionsIterator">

    <zorba:description author="Zorba Team">
      dc:available-collections
    </zorba:description>

    <zorba:function generateCodegen="false">

      <zorba:signature localname="available-collections"
                       prefix="zorba-store-collections-static-ddl">
        <zorba:output>xs:QName*</zorba:output>
      </zorba:signature>

      <zorba:signature localname="available-collections"
        prefix="zorba-store-dynamic-collections-ddl">
        <zorba:output>xs:QName*</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:accessesDynCtx returnValue="true"/>
      </zorba:methods>
    </zorba:function>

    <zorba:constructor>
      <zorba:parameter type="bool" name="aDynamicCollection" />
    </zorba:constructor>

    <zorba:member type="bool" name="theDynamicCollection"
      brief="whether it's the function of the dynamic or the static collection module"/>

    <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
      <zorba:member type="store::Iterator_t" name="nameItState"
                    brief="the current iterator"/>
    </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="IsAvailableIndexIterator">

    <zorba:description author="Zorba Team">
      dc:is-available-index
    </zorba:description>

    <zorba:function>
      <zorba:signature localname="is-available-index"
        prefix="zorba-store-indexes-static-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>xs:boolean</zorba:output>
      </zorba:signature>

      <zorba:methods>
        <zorba:accessesDynCtx returnValue="true"/>
      </zorba:methods>

    </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="AvailableIndexesIterator">

    <zorba:description author="Zorba Team">
      dc:available-indexes
    </zorba:description>

    <zorba:function>
      <zorba:signature localname="available-indexes"
                       prefix="zorba-store-indexes-static-ddl">
        <zorba:output>xs:QName*</zorba:output>
      </zorba:signature>
      <zorba:methods>
        <zorba:accessesDynCtx returnValue="true"/>
      </zorba:methods>
    </zorba:function>

    <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
      <zorba:member type="store::Iterator_t" name="nameItState"
                    brief="the current iterator"/>
    </zorba:state>

</zorba:iterator>


<!--
/*******************************************************************************
*******************************************************************************/
-->
<zorba:iterator name="IsActivatedICIterator">

    <zorba:description author="Zorba Team">
      dc:is-activated-integrity-constraint
    </zorba:description>

    <zorba:function>
      <zorba:signature localname="is-activated-integrity-constraint"
                       prefix="zorba-store-integrity_constraints-static-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>xs:boolean</zorba:output>
      </zorba:signature>
      <zorba:methods>
        <zorba:accessesDynCtx returnValue="true"/>
      </zorba:methods>
    </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
*******************************************************************************/
-->
<zorba:iterator name="ActivatedICsIterator">

    <zorba:description author="Zorba Team">
      dc:activated-integrity-constraints
    </zorba:description>

    <zorba:function>
      <zorba:signature localname="activated-integrity-constraints"
                       prefix="zorba-store-integrity_constraints-static-ddl">
        <zorba:output>xs:QName*</zorba:output>
      </zorba:signature>
      <zorba:methods>
        <zorba:accessesDynCtx returnValue="true"/>
      </zorba:methods>
    </zorba:function>

    <zorba:state  generateInit="false"
                  generateReset="false"
                  generateDestructor="false">
      <zorba:member type="store::Iterator_t" name="nameItState"
                    brief="the current iterator"/>
    </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="IsDeclaredCollectionIterator">

    <zorba:description author="Zorba Team">
      sc:is-declared-collection
    </zorba:description>

    <zorba:function>
      <zorba:signature localname="is-declared-collection"
                       prefix="zorba-store-collections-static-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>xs:boolean</zorba:output>
      </zorba:signature>
    </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="DeclaredCollectionsIterator">

    <zorba:description author="Zorba Team">
      sc:declared-collections
    </zorba:description>

    <zorba:function>
      <zorba:signature localname="declared-collections"
                       prefix="zorba-store-collections-static-ddl">
        <zorba:output>xs:QName*</zorba:output>
      </zorba:signature>
    </zorba:function>

    <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
      <zorba:member type="store::Iterator_t" name="nameItState"
                    brief="the current iterator"/>
    </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="IsDeclaredIndexIterator">

    <zorba:description author="Zorba Team">
      sc:is-declared-index
    </zorba:description>

    <zorba:function>
      <zorba:signature localname="is-declared-index"
                       prefix="zorba-store-indexes-static-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>xs:boolean</zorba:output>
      </zorba:signature>
    </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="DeclaredIndexesIterator">

    <zorba:description author="Zorba Team">
      sc:declared-indexes
    </zorba:description>

    <zorba:function>
      <zorba:signature localname="declared-indexes"
                       prefix="zorba-store-indexes-static-ddl">
        <zorba:output>xs:QName*</zorba:output>
      </zorba:signature>
    </zorba:function>

    <zorba:state generateReset="false" generateDestructor="false">
      <zorba:member type="store::Iterator_t" name="nameItState" defaultValue="NULL"
                    brief="the current iterator"/>
    </zorba:state>

</zorba:iterator>

<!--
/*******************************************************************************
*******************************************************************************/
-->
<zorba:iterator name="IsDeclaredICIterator">

    <zorba:description author="Zorba Team">
      sc:is-declared-integrity-constraint
    </zorba:description>

    <zorba:function>
      <zorba:signature localname="is-declared-integrity-constraint"
                       prefix="zorba-store-integrity_constraints-static-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>xs:boolean</zorba:output>
      </zorba:signature>
    </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
*******************************************************************************/
-->
<zorba:iterator name="DeclaredICsIterator">

    <zorba:description author="Zorba Team">
      sc:declared-integrity-constrints
    </zorba:description>

    <zorba:function>
      <zorba:signature localname="declared-integrity-constraints"
                       prefix="zorba-store-integrity_constraints-static-ddl">
        <zorba:output>xs:QName*</zorba:output>
      </zorba:signature>
    </zorba:function>

    <zorba:state generateReset="false" generateDestructor="false">
      <zorba:member type="store::Iterator_t" name="nameItState"
        defaultValue="NULL" brief="the current iterator"/>
    </zorba:state>
</zorba:iterator>

<!--
/*******************************************************************************
14.8.5 fn:uri-collection
********************************************************************************/
-->
  <zorba:iterator name="FnURICollectionIterator">
    <zorba:description author="Zorba Team">
      Returns a sequence of xs:anyURI values representing the document URIs of the 
      documents in a collection.
    </zorba:description>

    <zorba:function>

      <zorba:signature localname="uri-collection" prefix="fn">
        <zorba:output>xs:anyURI*</zorba:output>
      </zorba:signature>

      <zorba:signature localname="uri-collection" prefix="fn">
        <zorba:param>xs:string?</zorba:param>
        <zorba:output>xs:anyURI*</zorba:output>
      </zorba:signature>
      
    </zorba:function>

    <zorba:state generateInit="false" generateReset="false" generateDestructor="false">
      <zorba:member type="store::Iterator_t" name="theIterator"
                    brief="the current iterator"/>
      <zorba:member type="bool" name="theIteratorOpened" defaultValue="false"
                    brief="flag indicating whether theIterator was opened"/>
    </zorba:state>
    
  </zorba:iterator>

</zorba:iterators>
