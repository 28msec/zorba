<?xml version="1.0" encoding="UTF-8"?>

<!--
/////////////////////////////////////////////////////////////////////////////////
//                                                                             //
//                                                                             //
/////////////////////////////////////////////////////////////////////////////////
-->
<zorba:iterators xmlns:zorba="http://www.zorba-xquery.com">
    
<zorba:header>
</zorba:header>

<zorba:source>
  <zorba:include  form="Quoted">store/api/iterator.h</zorba:include>
</zorba:source>

<zorba:codegen>
  <zorba:cpp>
    <!--    <zorba:include form="Quoted">functions/Index.h</zorba:include>-->
  </zorba:cpp>
</zorba:codegen>


<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="CreateIndexIterator" arity="unary">

    <zorba:description author="Zorba Team">
  create-index($indexName as xs:QName) as pul()

  This is an updating function. During normal runtime (see CreateIndexIterator),
  it checks that index does not exist already (in the store) and generates an
  update primitive. During applyUpdates(), it creates the index container in
  the store and populates it according to the index definition.

  The specification for the index to create is taken from the static context,
  which stores a mapping from the index uri to ValueIndex obj (defined in
  indexing/value_index.h).

  The population of the index is done by a runtime plan that implements
  the following flwor expr:

    for $$dot at $$pos in domainExpr
    return index-entry-builder($$dot, fieldExpr1, ..., fieldExprN);

  This plan is generated "on-the-fly" by the CreateIndexIterator. The generated
  plan is stored in the update primitive, and during applyUpdates(), it is given
  as an arg to the SimpleStore::createIndex() method. 
    </zorba:description>

    <zorba:function isUpdating="true" requiresDynamicContext="true"> 
      <zorba:signature localname="create-index" prefix="fn-zorba-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>item()*</zorba:output>
      </zorba:signature>
    </zorba:function>

</zorba:iterator>

<!--
/*******************************************************************************
********************************************************************************/
-->
<zorba:iterator name="DeleteIndexIterator" arity="unary">

    <zorba:description author="Zorba Team">
  drop-index($indexName as xs:QName) as ()

  This is an updating function. During normal runtime (see DropIndexIterator),
  it checks that index exists (in the dynamic context) and generates an update
  primitive. During applyUpdates(), it destroys the index container in the store
  and removes the index entry from the dynamic context. 
    </zorba:description>

    <zorba:function isUpdating="true" requiresDynamicContext="true"> 
      <zorba:signature localname="delete-index" prefix="fn-zorba-ddl">
        <zorba:param>xs:QName</zorba:param>
        <zorba:output>item()*</zorba:output>
      </zorba:signature>
    </zorba:function>

</zorba:iterator>

</zorba:iterators>
